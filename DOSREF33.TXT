
ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º                               DOSREF    SWv3.3                             º
º         Programmer's Technical Reference for MSDOS and the IBM PC          º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

 This archive contains a demo version of DOSREF.  It contains 95% of the
basic information you actually need to program a PC under DOS.  You're
welcome to use this demo without obligation or payment, with my compliments.

 However, if you want MORE STUFF, you might want to register your copy of
DOSREF.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   Why register DOSREF instead of relying on one of those public domain
 "interrupt lists"?  Sheer size, for one.  Even in LHarc format DOSREF
 bulks out to over two megabytes.  Registered users also get support via:

        The Courts of Chaos BBS (DOSREF support board)
        internet
        CompuServe
        airmail

  You get the very latest edition of this manual on disk, with no worries
 about corrupted or tampered text.  DOSREF is a quality product, in use
 by the US Navy, CalTech, Borland, NEC, Wang, General Motors, Citicorp,
 Rockwell, Honeywell, Digital Research, Central Point Software, 20th Century
 Fox, Associated Press, hospitals, universities, and government agencies
 around the world.

  The Registered User reference consists of over two megabytes of compressed
 technical reference, appendices, and sample source code. That's about four
 megabytes of raw data when uncompressed, or several times larger than the
 shareware version.

  The Registered User version contains information on device drivers, mouse
 programming, Virtual Control Program Interface, hard drives, hardware
 information, virus and Trojan programs, EMS 3.2, LIM 4.0, EEMS 3.2, CD-ROM,
 network programming, DOS 5.0, various multitasking and network APIs, and
 more.

  Registered users will be advised by mail of updates.

  Several people who have downloaded copies many years old have written
 to see if I was still supporting the Reference.  The answer is yes.  Not only
 that, but my book contract calls for keeping the information current.  If
 you're concerned, just drop a postcard.

 *****************************************************************************

 Foreign langauge versions are available!

  Klaus Overhage of Stuttgart, West Germany has licensed DOSref for
 redistribution and is now able to provide versions in German.  Klaus' version
 is a separate product from this one and must be purchased separately. Klaus
 is providing full support for German users.  If you'd like a copy in German,
 please contact:

                             Klaus Overhage
                             Rosenstrasse 15 A
                             7000 Stuttgart 50
                             Germany

  I hope to have other languages available soon.  If you are interested in
purchase or translation, please contact me for details.

 *****************************************************************************

  For payment in British pounds, Canadian dollars or EuroCheques, see
 INVOICE.TRF and PAYMENT.  I fully support foreign users!  If you're having
 trouble arranging payment, write (or leave E-Mail) and I'll try to work
 something out.

  Do you live outside the US?  If so, you're probably familiar with the
 hassles of keeping up with the latest information - the three to five month
 lead time for US publication, plus time for local book dealers to catalog
 new releases, plus problems in trying to order... plus the delays while your
 book comes in on special order, goes through Customs, the inevitable price
 hikes through all the middlemen, taxes...  not only is DOSREF priced
 well below the price of good printed computer books in the US, it's probably
 far cheaper than you could expect to pay for US books locally.  Plus your
 order will show up in your very own mailbox by air mail.

 *****************************************************************************

  Printed copies of the Tech Ref are available for œ16.95 or US$35.10 from
Sigma Press, marketed by John Wiley & Sons UK. Address orders to:

        Programmer's Technical Reference
        by Dave Williams

        ISBN 185058-199-1
        John Wiley & Sons
        Baffins Lane
        Chichester
        West Sussex PO19 1UD
        England

 They accept checks, most credit cards, or purchase orders.

 *****************************************************************************

  The latest shareware version is always available on BIX the ibm.dos/listings
 area, the GEnie IBM file area, or:

 The Courts of Chaos, (501)985-0059, (support BBS)



 GroupMed, (206) 581-9088  (sysop: Ismail Arslangiray)
 Tacoma WA, USA  FIDOnet 1:138/120 2400bps, 1:138/116 9600bps USR HST
 instant access, latest DOSREF is FREQable

 The Drake BBS   Sysop: Paolo Masetti   Cosysop: Roberto Bianchi
 Langhirano, Italy, 0522 828800 <- 9600 v32
                         824379 <- 2400 mnp5
 Fidonet node 2:332/502



   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



                       How to use this Reference


  This reference changes so often that any attempt to format it for 
pagination would be a tremendous waste of time.  Simply printing the 
thing out and letting the pagebreaks fall where they may is how most 
people do it.  The neatest solution is Vern Buerg's LIST.COM or 
SideKick's file view function. 

  An efficient method of using the Reference is to concatenate all the 
chapters together with the COPY command, ie COPY CONTENTS + 
CHAPTER.001 + CHAPTER.002 + ..... + CHAPTER.010   REF.  (REF being the 
new file name for the concatenated files.) With LIST.COM, the 
backslash (\) or F9 key will search for strings. You can then dump 
pieces of text to a disk file or your printer. 

  If you work better with a printout than scanning with a file viewer, 
try setting your printer to 132 columns.  This allows a nice margin 
for writing notes, and eliminates the problem some printers have when 
printing 80 character wide text.  Some of the text and charts in the 
reference are a full 80 columns wide; unfortunately some printers wrap 
automatically at 79 columns. Some printers don't handle a combination 
of compressed print and graphics characters very well either.  You may 
have to use the PRTRFIX.COM program provided on Disk 1 to squelch the 
graphics for printing. 


   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


 This version of DOSREF is a bit different from the older shareware
versions.  As you may have noticed, I'm now promoting it as a "demo"
of the real thing.  You're welcome to use this copy of DOSREF with
my compliments - no need to feel guilty.  Hey, I'm a nice guy.  <grin>

 This "demo" version has quite a bit more detail than the previous
2.3c version.  You get nine chapters.  In these chapters, you now get
95% of the stuff in the full super-whoopie paid-for version's equivalent
chapters.  I left out some of the really esoteric or bulky stuff to keep
the file size down, but you have a majority of what you need to program
with, plus a ton of wierdo little facts that ought to keep you amused for
hours on end.

 Now, the object of this is to get you to buy the "real" DOSREF, of course.
If you look in the CONTENTS file, you'll see there's all sorts of other
stuff in the full version, as minutely detailed as what you just got.

 You get even more of the type of stuff you have in this archive, plus
over two megabytes of MORE stuff - XMS, EMS, VCPI, sound cards, APIs for
386 Multiware, Alloy NTNX, VMiX/386, Concurrent DOS/386 (most of which
applies to DR-Multiuser-DOS), Multi-DOS PLUS, NDIS networking, a complete
functioning TSR disk formatter with source to use as an example for writing
TSRs, or just yank for formatter code for your own programs.  You get dozens
of appendices covering everything from sound board file formats to address
lists.  Plus anything else I've added since this archive went out.

You can compare DOSREF against the stuff on the shelves at B.Dalton or
Waldenbooks, then look at what those Johnny-come-lately references COST.
Now, for only $25 you could get the full DOSREF and have as much info as
you could get from a whole shelf-full of books.  How can you beat a deal
like that?  


 Either way, please use and enjoy this demo copy of DOSREF.


                                        Regards,
                                                        Dave Williams

       **  Programmer's Technical Reference for MSDOS and the IBM PC **
                USA copyright TXG 392-616  ALL RIGHTS RESERVED
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ISBN 1-878830-02-3 (disk-based text)
                    Copyright (c) 1987, 1994 Dave Williams
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³ Shareware Version, 01/20/94 ³
                        ³  Please Register Your Copy  ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


 The rest of the chapters aren't included in this shareware demonstration
package.  Since the complete manual takes about 2000 Kb even compressed in
LHarc format, something had to give somewhere.

 Here's a sample of what you're missing:


 Appendices             Mouse API               Networking

 EMS                    XMS                     VCPI

 Video                  chip-level stuff        386 Multiware API

 MS TSR Specification   Alloy NTNX API          Concurrent DOS/386 API

 MultiDOS Plus API      PC-MOS/386 API          Sound Blaster programming

 NDIS network spec      X-DOS 3.3 info          VMiX/386 API

 working TSR samples    VESA APIs

 MORE!



                           TABLE OF CONTENTS


INTRO           Introduction, credits, copyrights


CHAPTER 1       DOS and the PC

Some History ..................................................... 1**1
What is DOS? ..................................................... 1**2
Other Operating Systems .......................................... 1**3
Specific Versions of MS/PC-DOS ................................... 1**4
The Operating System Heirarchy ................................... 1**5
DOS Structure .................................................... 1**6
DOS Initialization ............................................... 1**7


CHAPTER 2       Low Memory and Absolute Addresses

Introduction ..................................................... 2**1
System Memory Map ................................................ 2**2
A Brief Guide to Current Memory Terminology ...................... 2**3
PC Port Assignment ............................................... 2**4
Reserved Memory Locations ........................................ 2**5
Absolute Addresses ............................................... 2**6
The IBM PC System Interrupts (Overview) .......................... 2**7
Quick Chart of Interrupts 00h-0FFh ............................... 2**8
IRQ Usage Chart .................................................. 2**9
The IBM-PC System Interrupts 00h-0Fh (in detail) ................. 2**10
                                                            

CHAPTER 3       ROM BIOS and Serice Interrupts

Calling the ROM BIOS ............................................. 3**1
Interrupt 10h  Video Services .................................... 3**2
Interrupt 11h  Equipment Check ................................... 3**3
Interrupt 12h  Memory Size ....................................... 3**4
Interrupt 13h  Disk Functions .................................... 3**5
Interrupt 14h  Initialize and Access Serial Port ................. 3**6
FOSSIL Drivers ................................................... 3**7
Interrupt 15h  Cassette I/O ...................................... 3**8
Interrupt 16h  Keyboard I/O ...................................... 3**9
Interrupt 17h  Printer ........................................... 3**10
Interrupt 18h  ROM BASIC ......................................... 3**11
Interrupt 19h  Bootstrap Loader .................................. 3**12
Interrupt 1Ah  Time of Day ....................................... 3**13
Interrupt 1Bh  Control-Break ..................................... 3**14
Interrupt 1Ch  Timer Tick ........................................ 3**15
Interrupt 1Dh  Vector of Video Initialization Parameters ......... 3**16
Interrupt 1Eh  Vector of Diskette Controller Parameters .......... 3**17
Interrupt 1Fh  Ptr to Graphics Char Extensions (Graphics Set 2) .. 3**18


CHAPTER 4       DOS Function Requests

General Programming Guides ....................................... 4**1
DOS Registers .................................................... 4**2
DOS Stacks ....................................................... 4**3
DOS Interrupts ................................................... 4**4
Interrupt 20h (Terminate) ........................................ 4**5
DOS Services (quick list) ........................................ 4**6
Calling the DOS Services ......................................... 4**7
Version Specific Information ..................................... 4**8
Compatibility Problems With DOS 4.0+ ............................. 4**9
PCjr Cartridge Support ........................................... 4**10
eDOS 4.0 ......................................................... 4**11
DOS Services in Detail ........................................... 4**12


CHAPTER 5       Interrupts 22h through 0FFh

Interrupt 22h   Terminate Address ................................ 5**1
Interrupt 23h   Ctrl-Break Exit Address .......................... 5**2
Interrupt 24h   Critical Error Handler ........................... 5**3
Interrupt 25h   Absolute Disk Read ............................... 5**4
Interrupt 26h   Absolute Disk Write .............................. 5**5
Interrupt 27h   Terminate And Stay Resident ...................... 5**6
Interrupt 28h   (not documented by Microsoft) .................... 5**7
Interrupt 29h   (not documented by Microsoft) .................... 5**8
Interrupt 2Ah   Microsoft Networks - Session Layer Interrupt ..... 5**9
Interrupt 2Bh   Unknown .......................................... 5**10
Interrupt 2Ch   Unknown .......................................... 5**11
Interrupt 2Dh   Unknown .......................................... 5**12
Interrupt 2Eh   Alternate EXEC (DOS 2.0+) ........................ 5**13
Interrupt 2Fh   Multiplex Interrupt .............................. 5**14
Interrupt 30h   FAR jump instruction for CP/M-style calls ........ 5**15
Interrupt 31h   Unknown .......................................... 5**16
Interrupt 32h   Unknown .......................................... 5**17
Interrupt 33h   Used by Microsoft Mouse Driver Function Calls .... 5**18
Interrupt 34h   Turbo C/Microsoft languages - Floating Point ....  5**19
Interrupt 35h   Turbo C/Microsoft languages - Floating Point ....  5**20
Interrupt 36h   Turbo C/Microsoft languages - Floating Point ....  5**21
Interrupt 37h   Turbo C/Microsoft languages - Floating Point ....  5**22
Interrupt 38h   Turbo C/Microsoft languages - Floating Point ....  5**23
Interrupt 39h   Turbo C/Microsoft languages - Floating Point ....  5**24
Interrupt 3Ah   Turbo C/Microsoft languages - Floating Point ....  5**25
Interrupt 3Bh   Turbo C/Microsoft languages - Floating Point ....  5**26
Interrupt 3Ch   Turbo C/Microsoft languages - Floating Point ....  5**27
Interrupt 3Dh   Turbo C/Microsoft languages - Floating Point ....  5**28
Interrupt 3Eh   Turbo C/Microsoft languages - Floating Point ..... 5**29
Interrupt 3Fh   Overlay Manager Interrupt (Microsoft LINK.EXE) ... 5**30
Interrupt 40h   Hard Disk BIOS ................................... 5**31
Interrupt 41h   Hard Disk Parameters ............................. 5**32
Interrupt 42h   Pointer to screen BIOS entry ..................... 5**33
Interrupt 43h   Pointer to EGA Graphics Character Table .......... 5**34
Interrupt 44h   Pointer to graphics character table .............. 5**35
Interrupt 45h   Reserved by IBM  (not initialized) ............... 5**36
Interrupt 46h   Pointer to second hard disk parameter block ...... 5**37
Interrupt 47h   Reserved by IBM  (not initialized) ............... 5**38
Interrupt 48h   Cordless Keyboard Translation .................... 5**39
Interrupt 49h   Non-kbd Scan Code Translation Table Addr (PCjr) .. 5**40
Interrupt 4Ah   Real-Time Clock Alarm (Convertible, PS/2) ........ 5**41
Interrupt 4Bh   Reserved by IBM  (not initialized) ............... 5**42
Interrupt 4Ch   Reserved by IBM  (not initialized) ............... 5**43
Interrupt 4Dh   Reserved by IBM  (not initialized) ............... 5**44
Interrupt 4Eh   Reserved by IBM  (not initialized) ............... 5**45
Interrupt 4Fh   Reserved by IBM  (not initialized) ............... 5**46
Interrupt 50-57 IRQ0-IRQ7 Relocation ............................. 5**47
Interrupt 58h   Reserved by IBM  (not initialized) ............... 5**48
Interrupt 59h   Reserved by IBM  (not initialized) ............... 5**49
Interrupt 5Ah   Reserved by IBM  (not initialized)  .............. 5**50
Interrupt 5Bh   Reserved by IBM  (not initialized) ............... 5**51
Interrupt 5Ah   Cluster Adapter BIOS entry address ............... 5**52
Interrupt 5Bh   Reserved by IBM  (not initialized) ............... 5**53
Interrupt 5Ch   NETBIOS interface entry port, TOPS ............... 5**54
Interrupt 5Dh   Reserved by IBM  (not initialized) ............... 5**55
Interrupt 5Eh   Reserved by IBM  (not initialized) ............... 5**56
Interrupt 5Fh   Reserved by IBM  (not initialized) ............... 5**57
Interrupt 60h-67h  User Program Interrupts ....................... 5**58
Interrupt 60h   Network OS Interface ............................. 5**59
Interrupt 67h   Expanded Memory Board Driver Interrupt ........... 5**60
Interrupt 68h   Not Used  (not initialized) ...................... 5**61
Interrupt 69h   Not Used  (not initialized) ...................... 5**62
Interrupt 6Ah   Not Used  (not initialized) ...................... 5**63
Interrupt 6Bh   Not Used  (not initialized) ...................... 5**64
Interrupt 6Ch   System Resume Vector (Convertible) ............... 5**65
Interrupt 6Dh   Not Used  (not initialized) ...................... 5**66
Interrupt 6Eh   Not Used  (not initialized) ...................... 5**67
Interrupt 6Fh   10-Net API........................................ 5**68
Interrupt 70h   IRQ 8, Real Time Clock Int (AT, XT/286, PS/2) .... 5**69
Interrupt 71h   IRQ 9, Redirected to IRQ 8 (AT, XT/286, PS/2) .... 5**70
Interrupt 72h   IRQ 10  (AT, XT/286, PS/2)  Reserved ............. 5**71
Interrupt 73h   IRQ 11  (AT, XT/286, PS/2)  Reserved ............. 5**72
Interrupt 74h   IRQ 12  Mouse Interrupt (PS/2) ................... 5**73
Interrupt 75h   IRQ 13, Coprocessor Error (AT) ................... 5**74
Interrupt 76h   IRQ 14, Hard Disk Controller (AT, XT/286, PS/2) .. 5**75
Interrupt 77h   IRQ 15 (AT, XT/286, PS/2)  Reserved .............. 5**76
Interrupt 78h   Not Used ......................................... 5**77
Interrupt 79h   Not Used ......................................... 5**78
Interrupt 7Ah   Reserved ......................................... 5**79
Interrupt 7Bh-7Eh  Not Used by IBM ............................... 5**80
Interrupt 7Ch   REXX-PC API ...................................... 5**81
Interrupt 7Fh   IBM 8514/A Graphics Adapter API .................. 5**82
Interrupt 80h-85h  Reserved by BASIC ............................. 5**83
Interrupt 86h   Int 18 when relocated by NETBIOS ................. 5**84
Interrupt 86h-0F0h  Used by BASICA ............................... 5**85
Interrupt 0A4h  Right Hand Man API ............................... 5**86
Interrupt 0D4h  PC-MOS/386 API ................................... 5**87
Interrupt 0E0h  Digital Research CP/M-86 function calls .......... 5**88
Interrupt 0E1h  PC Cluster Disk Server Information ............... 5**89
Interrupt 0E2h  PC Cluster Program ............................... 5**90
Interrupt 0E4h  Logitech Modula-2 v2.0   Monitor Entry ........... 5**91
Interrupt 0E5h  Not Used ......................................... 5**92
Interrupt 0E6h  Not Used ......................................... 5**93
Interrupt 0E7h  Not Used ......................................... 5**94
Interrupt 0E8h  Not Used ......................................... 5**95
Interrupt 0E9h  Not Used ......................................... 5**96
Interrupt 0EAh  Not Used ......................................... 5**97
Interrupt 0EBh  Not Used ......................................... 5**98
Interrupt 0ECh  Not Used ......................................... 5**99
Interrupt 0EDh  Not Used ......................................... 5**100
Interrupt 0EEh  Not Used ......................................... 5**101
Interrupt 0EFh  GEM interface (Digital Research) ................. 5**102
Interrupt 0F0h  unknown .......................................... 5**103
Interrupts 0F1h-0FFh  (absolute addresses 3C4h-3FFh) ............. 5**104
Interrupt 0F4h  Not Used ............ ............................ 5**105
Interrupt 0F5h  Not Used ............ ............................ 5**106
Interrupt 0F8h  Set Shell Interrupt (OEM) ........................ 5**107
Interrupt 0F9h  Reserved ......................................... 5**108
Interrupt 0FAh  USART ready (RS-232C) ............................ 5**109
Interrupt 0FBh  USART RS ready (keyboard) ........................ 5**110
Interrupt 0FCh  Unknown ...........................................5**111
Interrupt 0FDh  reserved for user interrupt ...................... 5**112
Interrupt 0FEh  reserved by IBM .................................. 5**113
Interrupt 0FFh  reserved by IBM .................................. 5**114



CHAPTER 6       DOS Control Blocks and Work Areas

DOS Address Space ................................................ 6**1
Storage Blocks ................................................... 6**2
Disk Transfer Area (DTA) ......................................... 6**3
Program Segment Prefix ........................................... 6**4
Memory Control Blocks ............................................ 6**5
DOS Program Segment .............................................. 6**6


CHAPTER 7       DOS File Information

File Management Functions ........................................ 7**1
FCB Function Calls ............................................... 7**2
Handle Function Calls ............................................ 7**3
Special File Handles ............................................. 7**4
Raw and Cooked File I/O .......................................... 7**5
Number of Open Files Allowed  .................................... 7**6
Restrictions on FCB Usage ........................................ 7**7
Restrictions on Handle usage ..................................... 7**8
Allocating Space to a File ....................................... 7**9
MSDOS / PCDOS Differences ........................................ 7**10
.COM File Structure .............................................. 7**11
.EXE File Structure .............................................. 7**12
The Relocation Table ............................................. 7**13
"NEW" .EXE Format (Microsoft Windows and OS/2) ................... 7**14
Standard File Control Block ...................................... 7**15
Extended File Control Block ...................................... 7**16
Disk Transfer Area ............................................... 7**17


CHAPTER 8       DOS Disk Information

The DOS Area ..................................................... 8**1
The Boot Record .................................................. 8**2
DOS File Allocation Table (FAT) .................................. 8**3
        Media Descriptor Byte .................................... 8**4
        12 Bit FATs .............................................. 8**5
        16 Bit FATs .............................................. 8**6
Cluster Size Information ......................................... 8**7
DOS Disk Directory ............................................... 8**8
The Data Area .................................................... 8**9
Floppy Disk Types ................................................ 8**10
Hard Disk Layout ................................................. 8**11
System Initialization ............................................ 8**12
Boot Record/Partition Table ...................................... 8**13
Hard Disk Technical Information .................................. 8**14
Determining Hard Disk File Allocation ............................ 8**15
BIOS Disk Functions .............................................. 8**16


CHAPTER 9       DOS Device Drivers


CHAPTER 10      EMS, EEMS, and VCPI Memory Specifications 

History .......................................................... 10**1
Uses of Expanded Memory .......................................... 10**2
DOS and Expanded Memory .......................................... 10**3
Different Memory Types ........................................... 10**4
AST/Quadram/Ashton-Tate Enhanced EMM ............................. 10**5
EMS Address Space Map ............................................ 10**6
Writing Programs That Use Expanded Memory ........................ 10**7
Page Frames ...................................................... 10**8
Calling the Manager .............................................. 10**9
Detecting EMS .................................................... 10**10
Terminate and Stay Resident (TSR) Program Cooperation ............ 10**11
Expanded Memory Services Quick List .............................. 10**12
Expanded Memory Services ......................................... 10**13
        LIM 3.2 Specification .................................... 10**14
        LIM 4.0 Specification .................................... 10**15
        AQA EEMS 3.2 Specification ............................... 10**16
        VCPI API 1.0 ............................................. 10**17
Expanded Memory Manager Error Codes .............................. 10**18


CHAPTER 11      Microsoft Extended Memory (XMS) Specification


CHAPTER 12      TSR Programming


CHAPTER 13      PC-MOS/386 Application Program Interface

Introduction ..................................................... 13**1
Programming For PC-MOS ........................................... 13**2
Extended Services Interrupt ...................................... 13**3
MOS Extended Services in Detail .................................. 13**4
ESI Error Codes .................................................. 13**5
PC-MOS Data Structures ........................................... 13**6
Terminal Device Interface ........................................ 13**7
Serial Device Interface .......................................... 13**8
NETBIOS Interface ................................................ 13**9
Memory Manager Interface ......................................... 13**10
INT 6 Handler .................................................... 13**11
User's Overview .................................................. 13**12


CHAPTER 14      Concurrent DOS/386 Application Program Interface

Introduction ..................................................... 14**1
General Programming Guides ....................................... 14**2
Quick Function List .............................................. 14**3
AUX Functions .................................................... 14**4
CONSOLE Functions ................................................ 14**5
DEVICE Functions ................................................. 14**6
DRIVE Functions .................................................. 14**7
FILE Functions ................................................... 14**8
LST Functions .................................................... 14**9
MEMORY Functions ................................................. 14**10
PROCESS Functions ................................................ 14**11
QUEUE Functions .................................................. 14**12
SYSTEM Functions ................................................. 14**13
TIME Functions ................................................... 14**14


CHAPTER 15      Register-Level Programming

8255 Peripheral Interface ........................................ 15**1
8259 Interrupt Controller ........................................ 15**2
AT CMOS RAM Configuration ........................................ 15**3
8250 Serial UART ................................................. 15**4
8327 DMA Controller .............................................. 15**5
8253 Triple Timer ................................................ 15**6
NEC 765 Diskette Controller....................................... 15**7


CHAPTER 16      Video Programming

Quick List of BIOS Interrupt 10h Functions ....................... 16**1
PC Video Subsystems .............................................. 16**2
BIOS Interrupt 10h Functions in Detail ........................... 16**3


CHAPTER 17      Multitasking Shells

Introduction ..................................................... 17**1
Programming Practices ............................................ 17**2
TopView/DESQview API (interrupt 15h, "System Services" interface)  17**3
TopView/DESQview API (interrupt 16h, "BIOS Video" interface) ..... 17**4


CHAPTER 18      Viruses and Trojan Horses


CHAPTER 19      Tips and Tricks


CHAPTER 20      Conversion Between Operating Systems

Overview ......................................................... 20**1
Special Considerations ........................................... 20**2
Example Operating Systems ........................................ 20**3
Atari ST ......................................................... 20**4
CP/M ............................................................. 20**5
MacOS ............................................................ 20**6
AmigaDOS ......................................................... 20**7
OS/2 ............................................................. 20**8
UNIX ............................................................. 20**9


CHAPTER 21      Microsoft Virtual DMA Specification 1.0

Introduction ..................................................... 21**1
VDS Function List ................................................ 21**2
VDS Functions .................................................... 21**3
DMA Descriptor Structure ......................................... 21**4
DX Flag Bits ..................................................... 21**5
VDS Error Codes .................................................. 21**6


CHAPTER 22      Mouse Programming

General Information .............................................. 22**1
Register Usage ................................................... 22**2
Interrupt 33h Function Requests .................................. 22**3
Interrupt 10h Function Requests .................................. 22**4


CHAPTER 23      Network APIs

FTP Driver - PC/TCP Packet Driver Specification .................. 23**1
10-Net Network ................................................... 23**2
LANtastic LANOS API .............................................. 23**3
Novell NetWare 2.11 API .......................................... 23**4
APPC/PC .......................................................... 23**5


CHAPTER 24      MultiDos Plus API


CHAPTER 25      VMiX 2.6x API

What is VMiX? .................................................... 25**1
Assembler Interface .............................................. 25**2


CHAPTER 26      X-DOS 3.3 


MISCSTUF        Miscellaneous Stuff

AFTERWRD        Afterword

CREDITS         Credits and Bibliography



 A P P E N D I C E S

APPENDIX  1     Keyboard scan code chart

APPENDIX  2     ASCII character chart

APPENDIX  3     IBM PC character set

APPENDIX  4     IBM PC error code listing

APPENDIX  5     Addresses of various manufacturers

APPENDIX  6     Hard disk information

APPENDIX  7     Floppy and Tape Devices

APPENDIX  8     Pinouts of various connectors on the IBM PC

APPENDIX  9     Sizes of various drivers installed in CONFIG.SYS

APPENDIX  10    Common modem instruction sets

APPENDIX  11    Glossary of computer terminology

APPENDIX  12    Various busses used in MSDOS machines

APPENDIX  13    Common filename extensions

APPENDIX  14    Clock speeds of various expansion cards

APPENDIX  15    Header formats used by various archive utilities

APPENDIX  16    Miscellaneous Hardware Information

APPENDIX  17    HP LaserJet Setup Codes

APPENDIX  18    ANSI.SYS Escape Sequences

APPENDIX  19    DEC VT100 Escape Sequences

APPENDIX  20    Various Paint Program Formats

APPENDIX  21    Some Commonly Used Hot-Keys

APPENDIX  22    Sound Blaster API

APPENDIX  23    French-Canadian accented character chart

APPENDIX  24    Compuserve Graphic Image Format '89a

APPENDIX  25    Hex Chart

APPENDIX  26    Microsoft TSR Specification 1.0

APPENDIX  27    Baud vs BPS Explained

APPENDIX  28    Borland BGI Stroked Font .CHR File Format

APPENDIX  29    Differences From DOS 4.0 In The OS/2 1.3 DOS Box

APPENDIX  30    IBM Interrupt Sharing Protocol

APPENDIX  31    CCITT v.XX Protocol Overview

APPENDIX  32    CCITT x.XX Protocol Overview

APPENDIX  33    Miscellaneous Switch Settings

APPENDIX  34    DOS BACKUP Format

APPENDIX  35    .WAV File Format





   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                        C H A P T E R    O N E

                          DOS AND THE IBM PC


                            C O N T E N T S

Some History ................................................... 1**1
What is DOS? ................................................... 1**2
Other Operating Systems ........................................ 1**3
Specific Versions of MS/PC-DOS ................................. 1**4
The Operating System Heirarchy ................................. 1**5
DOS Structure .................................................. 1**6
DOS Initialization ............................................. 1**7



Some History ................................................... 1**1

  Development of MSDOS/PCDOS began in October 1980, when IBM began 
searching the market for an operating system for the yet-to-be-
introduced IBM PC.

  IBM had originally intended to use Digital Research's (actually, 
they had the somewhat pretentious name of "Intergalactic Digital 
Research" at the time) CP/M was then the industry standard operating 
system - you either ran a BASIC with disk functions, someone's 
proprietary OS, or CP/M. 

  Folklore reports various stories about the rift between DRI and IBM.  
The most popular story claims Gary Kildall or DRI snubbed the IBM 
executives by flying his airplane when the meeting was scheduled.  
Another story claims Kildall didn't want to release the source for 
CP/M to IBM, which would be odd, since they released it to other 
companies.  One noted industry pundit claims Kildall's wife killed the 
deal by insisting on various contract changes.  I suspect the deal was 
killed by the good ol' boy network.  It's hard to imagine a couple of 
junior IBM executives giving up when ordered to a task as simple as 
licensing an operating system from a vendor.  It wouldn't look good on 
their performance reports.  It would be interesting to hear IBM's 
story... 

  IBM then talked to a small company called Microsoft.  Microsoft 
was a language vendor.  Bill Gates and Paul Allen had written 
Microsoft BASIC and were selling it on punched tape or disk to early 
PC hobbyists, which was probably a step up from the company's original 
name and goal - they were Traf-O-Data before, making car counters for
highway departments.
  
  Microsoft had no 8086 real operating system to sell, but quickly made
a deal to license Seattle Computer Products' 86-DOS operating system,
which had been written by Tim Paterson earlier in 1980 for use on that
company's line of 8086, S100 bus micros.  86-DOS (also called QDOS, for
Quick and Dirty Operating System) had been written as more or less a
16-bit version of CP/M, since Digital Research was showing no hurry in
introducing CP/M-86.  Paterson's DOS 1.0 was approximately 4000 lines of
assembler source. 

  This code was quickly polished up and presented to IBM for 
evaluation.

  IBM found itself left with Microsoft's offering of "Microsoft Disk 
Operating System 1.0".  An agreement was reached between the two, and 
IBM agreed to accept 86-DOS as the main operating system for their new 
PC.  Microsoft purchased all rights to 86-DOS in July 1981, and "IBM 
Personal Computer DOS 1.0" was ready for the introduction of the IBM 
PC in October 1981.  IBM subjected the operating system to an 
extensive quality-assurance program, reportedly found well over 300 
bugs, and decided to rewrite the programs.  This is why PC-DOS is 
copyrighted by both IBM and Microsoft. 

  Some early OEM versions of DOS had different names, such as Compaq-
DOS, Z-DOS, Software Bus 86, etc.  By version 2 Microsoft managed to 
persuade everyone but IBM to refer to the product as "MS-DOS." 

  It is sometimes amusing to reflect on the fact that the IBM PC was 
not originally intended to run MS-DOS.  The target operating system at 
the end of the development was for a (not yet in existence) 8086 
version of CP/M.  On the other hand, when DOS was originally written 
the IBM PC did not yet exist!  Although PC-DOS was bundled with the 
computer, Digital Research's CP/M-86 would probably have been the main 
operating system for the PC except for two things - Digital Research 
wanted $495 for CP/M-86 (considering PC-DOS was essentially free) and 
many software developers found it easier to port existing CP/M 
software to DOS than to the new version of CP/M. 

  The IBM PC shipped without an operating system.  IBM didn't start 
bundling DOS until the second generation AT/339 came out.  You could 
order one of three operating systems for your PC, assuming you popped 
for the optional disk drive and 64k RAM upgrade (base models had 16k 
and a cassette player port).  These operating systems were IBM
Personal Computer DOS 1.0, a version of the UCSD p-System, which was 
an integrated Pascal operating system something like the souped-up 
BASIC operating systems used by the Commodore 64 and others, or 
Digital Research's CP/M-86, which was officially an option although 
you couldn't buy it until later.  Since IBM's $39.95 DOS was far 
cheaper than anyone else's alternative, darned near everyone bought 
DOS.

  The upgrade from DOS 3.3 to 4.0 was done in-house by IBM.  DOS 4.0 
was a completely IBM product, later licensed back to Microsoft.  In 
early 1990 IBM announced that it was ceasing development of DOS and 
all further work would be done solely by Microsoft.  

  Microsoft Press' "MSDOS Encyclopedia" shows a reproduction of a late 
DOS 1.25 OEM brochure.  Microsoft was touting future enhancements to 
1.25 including Xenix-compatible pipes, process forks, and 
multitasking, as well as "graphics and cursor positioning, kanji 
support, multi-user and hard disk support, and networking."  Microsoft 
certainly thought big, but, alas, the forks, multitasking, and 
multiuser support never came about, at least in US versions of DOS.  
Oddly, the flyer claims: 

  "MS-DOS has no practical limit on disk size. MS-DOS uses 4-byte XENIX 
OS compatible pointers for file and disk capacity up to 4 gigabytes." 

  Umm... yeah.  One sort of gets the idea nobody at Microsoft had a 
hard disk larger than 32 megabytes... 

  For the record they actually delivered:

Xenix-compatible pipes:
             DOS 2.0  ("|" operator)

process forks, and multitasking:
            eDOS 4.0  (not delivered in the US)

multi-user:
            never delivered

graphics and cursor positioning:
            DOS 2.0  (ANSI.SYS)

kanji support:
            DOS 2.01, 2.25 (double-byte character set)

hard disk support:
            DOS 2.0  (subdirectories)

networking:
            DOS 3.1  (file locking support MS Networks)
            DOS 6.0  (bundled Interlink in with DOS)

  Early Microsoft ads pumped DOS' Xenix-like features and promised 
Xenix functionality in future releases. 

  We'll probably never know what the real story was behind eDOS/DOS 4/ 
DOS 5/286DOS/OS2.  Microsoft had announced their intent to build a 
multitasking, multiuser version of MSDOS as early as 1982.  They 
shipped betas of "DOS 4.0" in '86 and early '87, before 3.3 was even 
announced.  Microsoft UK announced they had licensed 4.0 to Apricot 
Computer, and the French Postal Service was supposed to be running it.  
I've never been able to find out if Apricot ever shipped any 4.0 to 
end users. 

  Despite Gordon Letwin's acid comments about problems with the 80286 
processor, I doubt the '286 was the barrier between users and a 
multitasking MS-DOS.  I also doubt there was any shortage of 
programming talent at Microsoft - Digital Research's Concurrent DOS 
and Software Link's PC-MOS/386 were developed without undue trouble. 


  MSDOS and PC-DOS have been run on more than just the IBM-PC and 
clones. Some of the following have been done: 

  Hardware PC Emulation:

        Apple II            ->    TransPC 8088 board
        Apple MacIntosh     ->    AST 80286 board
        Atari 400/800       ->    Co-Power 88 board
        Atari ST            ->    PC-Ditto II cartridge
        Amiga 2000          ->    8088 or A2286D 80286 Bridge Board
        IBM PC/RT           ->    80286 AT adapter
        Kaypro 2            ->    Co-Power Plus board

 Software PC Emulation:

        Apple MacIntosh     ->    SoftPC
        Atari ST            ->    PC-Ditto I
        IBM RS/6000         ->    DOS emulation

 DOS Emulation:

        AIX (IBM RS/6000)   ->    DOS emulation with "PCSIMulator"
        OS/2 1.x            ->    DOS emulation in "Compatibility Box"
        OS/2 2.x            ->    executes Virtual DOS Machine
        QNX                 ->    DOS window
        SunOS               ->    DOS window
        Xenix               ->    DOS emulation with DOSMerge


What Is DOS?.................................................... 1**2

  DOS exists as a high-level interface between an application program 
and the computer.  DOS stands for "Disk Operating System", which 
reflects the fact that its main original purpose was to provide an 
interface between the computer and its disk drives. 

  DOS now lets your programs do simple memory management, I/O from the 
system console, and assorted system tasks (time and date, etc) as well 
as managing disk operations.  Versions 3.1 and up also incorporate 
basic networking functions. 

  With the introduction of installable device drivers and TSR 
(terminate but stay resident) programs in DOS 2.0, the basic DOS 
functions may be expanded to cover virtually any scale of operations 
required. 


Other Operating Systems ........................................ 1**3

  There are a number of compatible replacements for Microsoft's MSDOS. 
Some are: 

Alloy 386 Multiware                  (multitasking control prog,
                                      licensed DOS)
Consortium Technologies MultiDOS     (multitasking, multiuser)
Digital Research Concurrent DOS      (multitasking)
Digital Research Concurrent DOS 386  (for 80386 computers)
Digital Research Concurrent DOS XM   (multitasking, multiuser)
Digital Research DR-DOS              (PC-DOS clones)
Digital Research Multiuser DOS       (multitasking, multiuser)
PC-MOS/386                           (multitasking, multiuser)
Wendin-DOS                           (multitasking, multiuser)
VM/386                               (multitasking)
X-DOS                                (DOS 3.31 compatible)

  Various other operating systems are available for the IBM PC. These 
include: 

Digital Research CP/M-86
Digital Research Concurrent CP/M-86 (multitasking)
Minix (multitasking UNIX workalike)
Pick  (database-operating system)
QNX   (multitasking, multiuser)
UCSD p-System  (Pascal interpreter and operating system)
UNIX  (various systems from IBM itself, Microsoft-SCO, Bell, and
       various UNIX clones, single and multi user, such as AIX,
       Xenix, AT&T System V, etc.)

  "Shell" programs exist which use DOS only for disk management while 
they more or less comprise a new operating system.  These include: 

     DESQview               Windows                   OmniView 
     GEM                    TopView                   TaskView 
     GeoWorks 


  TopView and TaskView (later called OmniView) and Omniview are no 
longer sold. 

  Systems using the NEC V-series CPUs can execute Intel 8080/8085 8-bit 
instructions as well as the 16-bit 8088-up instructions.  They can run 
standard Digital Research 8-bit CP/M and MP/M directly, as well as 
other operating systems developed for that processor. 



Specific Versions of MS/PC-DOS ................................. 1**4

  DOS 1.x is essentially 86-DOS.  DOS 2.x kept the multiple file layout 
(the two hidden files and COMMAND.COM) but for all practical purposes 
is an entirely different operating system with backwards compatibility 
with 1.x.  I seriously doubt there has been much code from 1.x 
retained in 2.x.  DOS 3.x is merely an enhancement of 2.x; there seems 
little justification for jumping a whole version number.  The disk 
handling routines were considerably extended in 3.1, allowing disk 
access in a "virtual" fashion, independent of whether the drive was a 
local or network device.  DOS 4.0, originating as it did from outside 
Microsoft, can justify a version jump.  Unfortunately, 4.0 seemed to 
have very little reason to justify its existence - virtually all of 
its core features could be found in one version or another of DOS 3.x.  
According to Microsoft's Gordon Letwin, DOS 5.0 was a complete rewrite 
with the kernel done in hand optimized assembly language. 

  DOS version nomenclature: major.minor.minor.  The digit to the left 
of the decimal point indicates a major DOS version change.  1.0 was 
the first version. 2.0 added support for subdirectories, 3.0 added 
support for networking, 4.0 added some minimal support for Lotus-
Intel-Microsoft EMS. 

  The first minor version indicates customization for a major 
application.  For example, 2.1 for the PCjr, 3.3 for the PS/2s.  The 
second minor version does not seem to have any particular meaning. 

  The main versions of DOS are:

 86-DOS       February 1981  Paterson's Quick'n'Dirty DOS first runs
                             on IBM's wirewrapped PC prototype

 PC-DOS 1.0   August   1981  original IBM release

 PC-DOS 1.05  -------- ----  fixes to BASIC interpreter

 PC-DOS 1.1   June     1982  bugfix, double sided drive support

 MS-DOS 1.25  July     1982  for early compatibles. This is the first
                             non-IBM OEM version

 PC-DOS 2.0   March    1983  for PC/XT, Unix-type subdirectory support,
                             installable device drivers, I/O
                             redirection, subdirectories, hard disk
                             support, handle calls

 PC-DOS 1.85  April    1983  internal IBM - extended 1.1 - not released
                             I found a copy of this one on an old 
                             diskette.  It added a whole host of 
                             features, including an enhanced COMMAND.COM
                             with command line editing.  Too bad none
                             of the goodies made it into DOS 2.0!

 MS-DOS 2.01  -------- 1983  first support for individual country
                             formats, Kanji 

 PC-DOS 2.1   October  1983  for IBM PCjr, bugfixes for 2.0.
                             No country support

 MS-DOS 2.11  December 1983  basically a cross of PC-DOS 2.1 and
                             MS-DOS 2.01

 MS-DOS 2.12  -------- ----  special version for TI Professional
                             (nonstandard video and keyboard)

 PC-DOS 3.0   August   1984  1.2 meg drive for PC/AT, some new system
                             calls, new external programs, 16-bit FAT,
                             specific support for IBM network

 MS-DOS 3.05  November 1984  first OEM version of 3.x

 PC-DOS 3.1   November 1984  bugfix for 3.0, implemented generic
                             network support

 MS-DOS 2.25  October  1985  extended foreign language support

 PC-DOS 3.2   January  1986  720k 3.5 inch drive support, special
                             support for laptops (IBM PC Convertible),
                             XCOPY

 MS-DOS 4.0   April    1986  multitasking (Europe only) - withdrawn
                             from market after a very short run

 PC-DOS 3.3   April    1987  for PS/2 series, 1.44 meg support,
                             multiple DOS partition support, code page
                             switching, improved foreign language
                             support, some new function calls, support
                             for the AT's CMOS clock.

 MS-DOS 3.31  November 1987  over-32 meg DOS partitions. Different
                             versions from different OEMs (not
                             Microsoft).  Compaq and Wyse are most
                             common.

 PC-DOS 3.4   -------- ----  internal IBM - not released (4.0
                             development)

 MS-DOS 2.11R -------- 1988  bootable ROM DOS for Tandy machines

 PC-DOS 4.0   August   1988  32mb disk limit officially broken, minor
                             EMS support, more new function calls,
                             enhanced network support for external
                             commands.  PCjr support dropped.

 MS-DOS 4.01  January? 1989  Microsoft version with some bugfixes

 MS-DOS 3.21R September1989  DOS in ROM, Flash File System for laptops

 MS-DOS 3.3R  -------- 1990  DOS in ROM, introduced for TI laptops

 MS-DOS 5.0   June     1991  high memory support, uses up to 8 hard
                             disks, command line editor and aliasing,
                             2.88 floppies, ROMable OEM kit available

 MS-DOS V     February 1993  Japanese-market version of 5, with double 
                             byte Kanji character support

 MS-DOS 6.0   March    1993  disk compression (Doublespace), multiple
                             configurations in CONFIG.SYS


  IBM's PC-DOS was long considered to be the "standard" version of DOS.  
Now that MS 5.0 is a commercial product most developers will probably 
write to it. 

  Microsoft's policy was once to sell DOS only to OEMs.  Despite this, 
they sold small quantities of DOS 3.2, 3.3, and 4.0 without 
insurmountable difficulties.  DOS 5.0 was conceived from the beginning 
as an over-the-counter retail product. 

  Incidentally, IBM refers to its DOS as "The IBM Personal Computer 
DOS."  The term "PC-DOS" is a trademark of IBM's rival DEC. 

  Some versions of MS-DOS varied from PC-DOS in the available external 
commands.  Some OEMs only licensed the basic operating system code (the 
xxxDOS and xxxBIO programs, and COMMAND.COM) from Microsoft, and 
either wrote the rest themselves or contracted them from outside 
software houses like Phoenix.  Most of the external programs for DOS 
3.x and 4.x are written in "C" while the 1.x and 2.x utilities were 
written in assembly language.  Other OEMs required customized versions 
of DOS for their specific hardware configurations, such as Sanyo 55x 
and early Tandy computers, which were unable to exchange their DOS 
with the IBM version. 

  PC-DOS 3.0 was extremely buggy on release.  It did not handle the DOS 
environment correctly and there were numerous documented problems with 
the batch file parser.  The network support code was also 
nonfunctional in that DOS version.  It is recommended that users 
upgrade to at least version 3.1. 

  DEC MS-DOS versions 2.11 for the Rainbow had the ANSI.SYS device 
driver built into the main code.  The Rainbow also used a unique quad 
density, single-sided floppy drive and its DOS had special support for 
it. 

  IBM had a version 1.85 of PC-DOS in April 1983, after the 
introduction of DOS 2.0.  It was evidently for internal use only, 
supported multiple drive file searches (a primitive form of PATH), 
built in MODE sommands for screen support, a /P parameter for TYPE for 
paused screens, an editable command stack like the public domain 
DOSEDIT.COM utility, and could be set up to remain completely resident 
in RAM instead of a resident/transient part like normal DOS.  It is a 
pity some of the neat enhancements didn't make it into DOS 2.0.  IBM 
also had an "internal use only" version 3.4, evidently used while 
developing DOS 4.0. 

  Digital Research's DR-DOS is the first widely available DOS clone.  
Version 3.4, released in June 1988, was the one first available to the 
American public. It was somewhat buggy and its use is not recommended.  
DR 3.41 is extremely compatible and its use should pose no problems on 
any machine.  DR-DOS 5.0 (released May, 1990) is functionally 
equivalent to MS-DOS 5.0.  For all practical purposes, MS 5.0 is a 
clone of DR 5.0, since DR beat MS to market by over a year.  According 
to Greg Ewald, DRI's DR-DOS product manager, DR-DOS was developed from 
Concurrent DOS 386 with the multiuser and multitasking code stripped 
out.  DR-DOS 6.0 was introduced in December 1991, and added disk 
compression via bundling the third-party SuperStor program.  Novell DOS
7.0 (DRI sold out to Novell) in March 1993, at the same time as MS-DOS 
6.0.  Novell one-upped Microsoft by tossing in their Netware Lite with 
their DOS.

  Some versions of DOS used in compatibles do not maintain the 1.x, 
2.x, ... numbering system.  Columbia Data Products computers labeled 
DOS 1.25 as DOS 2.0.  Early Compaqs labeled DOS 2.0 as DOS 1.x.  Other 
versions incorporated special features - Compaq DOS 3.31 and Wyse DOS 
3.21 both support >32mb disk partitions in the same fashion as DOS 
4.x. 

  AT&T DOS 3.1 differs from generic MS-DOS 3.10 in its use of cluster-
size and file allocation table structures.  AT&T DOS appears to use 
rules not from version 3, but rather those from version 2. 

  Epson Equity III and ComputerLand 3.10 DOS's appear to use cluster 
techniques that are a cross between versions 2 and 3.  On type DOS 
partitions, these DOS's use 3.x rules if the partition is larger than 
32,680 sectors in total size. This implies 16 bit FAT entries as well.  
On partitions below this size, they will use 2.x rules, including the 
12 bit FAT entries. 

  Zenith DOS 3.x and Wyse DOS 3.2 have a builtin internal device driver 
to handle up to 4 32Mb DOS partitions on a single hard disk. Wyse DOS 
3.31 will handle single partitions up to 512Mb with a 32-bit FAT. 

  According to PC Week Magazine, July 4, 1988, Arabic versions of MS-
DOS are shipping with a hardware copy-protection system from Rainbow 
Technologies.  This is similar to the short-lived system used by 
AutoCAD 2.52 and a very few other MS-DOS programs, where an adapter 
block is plugged into the parallel port and software makes use of 
coded bytes within the block.  This type of copy protection has been 
common on Commodore products for several years, where it is called a 
"dongle." 
  The AutoCAD dongle was defeated by a small program written within 
weeks of version 2.52's debut.  Version 2.62 was released 3 months 
later, without the dongle.  The DOS dongle will, however, prevent the 
system from booting at all unless it is found. 
  This makes the Arabic version of MSDOS the first copy-protected 
operating system, a dubious distinction at best.  The modifications to 
the operating system to support the dongle are not known at this time.  
Frankly, it would seem that burning the operating system into ROMs 
would be cheaper and simpler. 

  Versions of DOS sold in Great Britain are either newer than those 
sold in the US or use a different numbering system.  DOS 3.4, 4.0, 
4.1, 4.2, and 4.3 had been released there between the US releases of 
3.3 and 4.0. 
  MSDOS 4.0 (eDOS) was introduced in mid-1987 in Europe (at SICOB in 
Paris and sometime earlier by Apricot Computer in the UK).  It offered 
multitasking provided applications were specially written for it. 
  David Fraser (Microsoft UK Managing Director) is on record saying 
that "DOS 4.0 is unlikely to set the world alight and is of interest 
only to specific OEMs who want its features for networking and 
communications."   Standard DOS applications will run under DOS 4.x as 
a foreground task according to uncertain information.  It differs from 
earlier versions only in allowing background tasks to run.  For 
further information, see Chapter 4. 

  Microsoft changed their OEM licensing agreements between DOS versions 
2.x and 3.x.  OEM versions of DOS 3.x must maintain certain data areas 
and undocumented functions in order to provide compatibility with the 
networking features of the operating system.  For this reason, TSR 
programs will be much more reliable when operating under DOS 3.x. 

  Several versions of DOS have been modified to be run out of ROM.  The 
Sharp PC5000 had MSDOS 1.25 in ROM, and the Toshiba 1000 and some 
Tandy 1000 models have MSDOS 2.11 in ROM.  In mid-September 1989 
Microsoft introduced 3.21R ROMs for laptops, and in early '90 Texas 
Instruments laptops were the first to get the 3.3R ROMs.  All versions 
of Digital Research's DR-DOS are available in ROM version and Award 
Software is marketing DR-DOS cards to OEMs as a plug-in to ISA-bus 
machines. 

  IBM's release of DOS 4.0 (and the immediate subsequent release of a 
bugfix) was a dubious step "forward."  DOS 4.0 was the first version 
of DOS to come with a warranty; the catch is that IBM warranted it 
only for a very slim list of IBM-packaged software.  4.0 had some 
minor EMS support, support for large hard disks, and not much else.  
With its voracious RAM requirements and lack of compatibility with 
previous versions of DOS (many major software packages crashed under 
DOS 4.0), plus the increase in price to a cool $150, there was no 
great rush to go to that version of DOS. 

  Microsoft undertook development of MSDOS 5.0 in early 1990, 
soliciting input from Usenet, BIX, and Compuserve among others.
This was quite a surprise after Bill Gates had announced "DOS is dead" 
at every opportunity, trying to build support for OS/2.  Alas, most of 
Microsoft's revenue came from DOS, not OS/2's few sales (at $325 per 
copy) or applications.  Apparently Microsoft realized they were 
shooting themselves in the foot and that there was still plenty of 
life left in DOS.  They dropped OS/2 development shortly after 
starting on DOS 5.0.

  5.0 is a functional clone of Digital Research's DR-DOS 5.0.  5.0's 
compatibility was assured by what has been claimed as the largest 
beta-test program in history -in his address to the Boston Computer 
Society, Bill Gates announced over 7,500 testers were involved.

  There are many versions of MS-DOS 5.0.  Microsoft's original 
revision reported "Revision A" when you used the at-first-undocumented 
VER/R command.  There was a Revision B and C, which I have personally 
seen right out of the shrinkwrap.  Microsoft has denied (at least up
to late 1992) there ever was a B or C revision, and shortly afterward
new copies started reporting "Revision A" no matter what the 
datestamps on the files were.  IBM DOS 5.0 went through a number of 
CSDs, all of which were available for free download from their BBS in 
Atlanta (see Appendix 5) but most of the revisions related to IBM 
specific hardware problems.

  MS-DOS 6.0 was introduced in March 1993.  It bundles some third 
party utilities and disk compression (developed from licensed code), 
but other than boot control via new CONFIG.SYS options, it doesn't add 
any new features.  If it weren't for marketing reasons, it would 
probably have been called DOS 5.1.



The Operating System Hierarchy ................................. 1**5

  The Disk Operating System (DOS) and the ROM BIOS serve as an 
insulating layer between the application program and the machine, and 
as a source of services to the application program. 

  As the term 'system' might imply, DOS is not one program but a 
collection of programs designed to work together to allow the user 
access to programs and data.  Thus, DOS consists of several layers of 
"control" programs and a set of "utility" programs. 

  The system hierarchy may be thought of as a tree, with the lowest 
level being the actual hardware.  The 8088 or V20 processor sees the 
computer's address space as a ladder one byte wide and one million 
bytes long.  Parts of this ladder are in ROM, parts in RAM, and parts 
are not assigned.  There are also 65,536 "ports" that the processor 
can use to control devices. 

  The hardware is normally addressed by the ROM BIOS, which will always 
know where everything is in its particular system.  The chips may 
usually also be written to directly, by telling the processor to write 
to a specific address or port.  This sometimes does not work as the 
chips may not always be at the same addresses or have the same 
functions from machine to machine. 



DOS Structure .................................................. 1**6

DOS consists of four components:

 * The boot record
 * The ROM BIOS interface  (IBMBIO.COM, DRBIOS.SYS, or IO.SYS)
 * The DOS program file    (IBMDOS.COM, DRBDOS.SYS, or MSDOS.SYS)
 * The command processor   (COMMAND.COM or aftermarket replacement)


* The Boot Record

  The boot record begins on track 0, sector 1, side 0 of every diskette 
prepared by the DOS FORMAT command.  The boot record is placed on 
diskettes to produce an error message if you try to start up the 
system with a nonsystem diskette in drive A.  For hard disks, the boot 
record resides on the first sector of the DOS partition.  All media 
supported by DOS use one sector for the boot record. 


* Read Only Memory (ROM) BIOS Interface and Extensions

  The file IBMBIO.COM or IO.SYS is the interface module to the ROM 
BIOS. This file provides a low-level interface to the ROM BIOS device 
routines and may contain extensions or changes to the system board 
ROMs.  Some compatibles do not have a ROM BIOS to extend, and load the 
entire BIOS from disk.  (Sanyo 55x, Viasyn machines).  Some versions 
of MSDOS, such as those from Compaq's MS-DOS and Digital Research's 
DRDOS 5.0, are named IBMBIO.COM but are not IBM files. 

  These low-level interface routines include the instructions for 
performing operations such as displaying information on the screen, 
reading the keyboard, sending data out to the printer, operating the 
disk drives, and so on.  It is the operating system's means of 
controlling the hardware.  IBMBIO.COM contains any modifications or 
updates to the ROM BIOS that are needed to correct any bugs or add 
support for other types of hardware such as new disk drives.  By using 
IBMBIO.COM to update the ROM BIOS on the fly when the user turns on 
their computer, IBM does not need to replace the ROM BIOS chip itself, 
but makes any corrections through the cheaper and easier method of 
modifying the IBMBIO.COM file instead. 

  IBMBIO.COM also keeps track of hardware operations on an internal 
stack or "scratch pad" area for the operating system to save 
information such as addresses it will need, etc.  An example of the 
use for this stack can be seen when running a program such as a word 
processor.  If you have told the word processor to save your letter, 
it will write the data to your disk.  During this time, if you start 
typing some more information, the keyboard generates a hardware 
interrupt.  Since you don't want the process of writing the 
information to the disk to be interrupted, DOS allocates a slot in the 
stack for the keyboard's hardware interrupt and when it gets a chance, 
(probably after the data has been written to the disk), it can process 
that interrupt and pick up the characters you may have been typing.  
The STACKS= command in DOS 3.2+'s CONFIG.SYS file controls the number 
of stack frames available for this purpose. 

  IBMBIO.COM also reads your CONFIG.SYS file and installs any device 
drivers (i.e. DEVICE=ANSI.SYS) or configuration commands it may find 
there. 



* The DOS Program

  The actual DOS program is the file IBMDOS.COM or MSDOS.SYS.  It 
provides a high-level interface for user (application) programs.  This 
program consists of file management routines, data blocking/deblocking 
for the disk routines, and a variety of built-in functions easily 
accessible by user programs. 

  When a user program calls these function routines, they accept high-
level information by way of register and control block contents.  When 
a user program calls DOS to perform an operation, these functions 
translate the requirement into one or more calls to IBMBIO.COM, 
MSDOS.SYS or system hardware to complete the request. 

  This section is often referred to as the "kernel" by systems 
programmers. 



* The Command Interpreter

  The command interpreter, COMMAND.COM, is the part you interact with 
on the command line.  COMMAND.COM has three parts.  IBM calls them the 
"resident portion", the "initialization portion" and the "transient 
portion". 

  IBM's original documentation spoke of installing alternate command 
interpreters (programs other than COMMAND.COM) with the SHELL= 
statement in CONFIG.SYS.  Unfortunately, IBM chose not to document 
much of the interaction between IBMDOS.COM and IBMBIO.COM.  By the 
time much of the interaction was widely understood, many commercial 
software programs had been written to use peculiarities of COMMAND.COM 
itself. 

  Several programs exist that perform as actual "shells" by completely 
replacing COMMAND.COM and substituting their own command interpreter 
to use with the hidden DOS files.  Examples are Command Plus, a 
commercial package, and the shareware 4DOS and FlexShell packages.  
Both supply greatly enhanced batch language and editing capabilities. 

NOTE: DOS 3.3+ checks for the presence of a hard disk, and will 
      default to COMSPEC=C:\.  Previous versions default to
      COMSPEC=A:\.  Under some DOS versions, if COMMAND.COM is not
      immediately available for reloading (i.e., swapping to a floppy 
      with COMMAND.COM on it) DOS may crash. 


Resident Portion:

  The resident portion resides in memory immediately following 
IBMDOS.COM and its data area.  This portion contains routines to 
process interrupts 22h (Terminate Address), 23h (Ctrl-Break Handler), 
and 24h (Critical Error Handler), as well as a routine to reload the 
transient portion if needed.  For DOS 3.x, this portion also contains 
a routine to load and execute external commands, such as files with 
exensions of COM or EXE. 

  When a program terminates, a checksum is used to determine if the 
application program overlaid the transient portion of COMMAND.COM.  If 
so, the resident portion will reload the transient portion from the 
area designated by COMSPEC= in the DOS environment.  If COMMAND.COM 
cannot be found, the system will halt. 

  All standard DOS error handling is done within the resident portion 
of COMMAND.COM.  This includes displaying error messages and 
interpreting the replies to the "Abort, Retry, Ignore, Fail?" message. 

  Since the transient portion of COMMAND.COM is so large (containing 
the internal commands and all those error messages), and it is not 
needed when the user is running an application it can be overlaid that 
program if that application needs the room.  When the application is 
through, the resident portion of COMMAND.COM brings the transient 
portion back into memory to show the prompt.  This is why you will 
sometimes see the message "Insert disk with COMMAND.COM".  It needs to 
get the transient portion off the disk since it was overlaid with the 
application program. 

  The initialization portion of COMMAND.COM follows the resident 
portion and is given control during the bootup procedure.  This 
section actually processes the AUTOEXEC.BAT file.  It also decides 
where to load the user's programs when they are executed.  Since this 
code is only needed during startup, it is overlaid by the first 
program which COMMAND.COM loads. 

  The transient portion is loaded at the high end of memory and it is 
the command processor itself.  It interprets whatever the user types 
in at the keyboard, hence messages such as "Bad command or file name" 
for when the user misspells a command.  This portion contains all the 
internal commands (i.e. COPY, DIR, RENAME, ERASE), the batch file 
processor (to run .BAT files) and a routine to load and execute 
external commands which are either .COM or .EXE files. 

  The transient portion of COMMAND.COM produces the system prompt, 
(C>), and reads what the user types in from the keyboard and tries to 
do something with it.  For any .COM or .EXE files, it builds a command 
line and issues an EXEC function call to load the program and transfer 
control to it. 



DOS Initialization ............................................. 1**7

  The system is initialized by a software reset (Ctrl-Alt-Del), a 
hardware reset (reset button), or by turning the computer on.  The 
Intel 80x8x series processors always look for their first instruction 
at the end of their address space (0FFFF0h) when powered up or reset.  
This address contains a jump to the first instruction for the ROM 
BIOS. 

  Built-in ROM programs (Power-On Self-Test, or POST, in the IBM) check 
machine status and run inspection programs of various sorts.  Some 
machines set up a reserved RAM area with bytes indicating installed 
equipment (AT and PCjr). 

  When the ROM BIOS finds a ROM on an adapter card, it lets that ROM 
take control of the system so that it may perform any set up necessary 
to use the hardware or software controlled by that ROM.  The ROM BIOS 
searches absolute addresses C8000h through E0000h in 2K increments in 
search of a valid ROM. A valid ROM is determined by the first few 
bytes in the ROM.  The ROM will have the bytes 55h, AAh, a length 
indicator and then the assembly language instruction to CALL FAR (to 
bring in a "FAR" routine).  A checksum is done on the ROM to verify 
its integrity, then the BIOS performs the CALL FAR to bring in the 
executible code.  The adapter's ROM then performs its initialization 
tasks and hopefully returns control of the computer back to the ROM 
BIOS so it can continue with the booting process. 

  The ROM BIOS routines then look for a disk drive at A: or an option 
ROM (usually a hard disk) at absolute address C:800h.  If no floppy 
drive or option ROM is found, the BIOS calls int 19h (ROM BASIC if it 
is an IBM) or displays an error message. 

  If a bootable disk is found, the ROM BIOS loads the first sector of 
information from the disk and then jumps into the RAM location holding 
that code.  This code normally is a routine to load the rest of the 
code off the disk, or to "boot" the system. 

  The following actions occur after a system initialization:

 1.  The boot record is read into memory and given control.

 2.  The boot record then checks the root directory to assure that the 
     first two files are IBMBIO.COM and IBMDOS.COM or their OEM
     equivalents.  These files must be in that order, with IBMBIO.COM 
     first, with its sectors in contiguous order. 
     note 1) IBMDOS.COM need not be contiguous in version 3.x+. 
          2) DR-DOS versions 3.40 through 6.0 may have DRBIOS.SYS and 
             DRDOS.SYS anywhere on the hard disk. 
          3) PC-MOS/386' $$MOS.SYS file may be anywhere on the hard 
             disk. 

 3.  The boot record loads IBMBIO.COM into memory.

 4.  The initialization code in IBMBIO.COM loads IBMDOS.COM, 
     determines equipment status, resets the disk system,
     initializes the attached devices, sets the system parameters
     and loads any installable device drivers according to the
     CONFIG.SYS file in the root directory (if present), sets the
     low-numbered interrupt vectors, relocates IBMDOS.COM downward,
     and calls the first byte of DOS. 
     note 1) CONFIG.SYS may be a hidden file. 

 5.  DOS initializes its internal working tables, initializes the 
     interrupt vectors for interrupts 20h through 27h, and builds
     a Program Segment Prefix for COMMAND.COM at the lowest
     available segment.  For DOS versions 3.10 up, DOS also
     initializes the vectors for interrupts 0Fh through 3Fh.  An
     initialization routine is included in the resident portion and 
     assumes control during startup.  This routine contains the
     AUTOEXEC.BAT file handler and determines the segment address
     where user application programs may be loaded.  The
     initialization routine is then no longer needed and is overlaid
     by the first program COMMAND.COM loads. 
     note 1) AUTOEXEC.BAT may be a hidden file. 

 6.  IBMDOS.COM uses the EXEC function call to load and start the top-
     level command processor.  The default command processor is
     COMMAND.COM in the root directory of the boot drive.  If
     COMMAND.COM is in a subdirectory or another command processor is
     to be used, it must be specified by a SHELL= statement in the
     CONFIG.SYS file.  A transient portion is loaded at the high end
     of memory.  This is the command processor itself, containing all
     of the internal command processors and the batch file processor.
     For DOS 2.x, this portion also contains a routine to load and
     execute external commands, such as files with extensions of COM
     or EXE.  This portion of COMMAND.COM also produces the DOS prompt
     (such as "A>"), reads the command from the standard input device
     (usually the keyboard or a batch file), and executes the command.
     For external commands, it builds a command line and issues an EXEC
     function call to load and transfer  control to the program. 

note 1) COMMAND.COM may be a hidden file.
     2) For IBM DOS 2.x, the transient portion of the command
        processor contains the EXEC routine that loads and executes
        external commands.  For MSDOS 2.x+ and IBM DOS 3.x+, the
        resident portion of the command processor contains the EXEC
        routine.
     3) IBMDOS only checks for a file named "COMMAND.COM".  It will
        load any file of that name if no SHELL= command is used.


  That pretty much covers the bootup process.  After the command 
processor is loaded, it runs the AUTOEXEC.BAT file and then the user 
gets their prompt to begin working. 



   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    ³ Shareware Version, 01/20/94 ³
                    ³  Please Register Your Copy  ³
                    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                         C H A P T E R   T W O
 

       CPU Port Assignments, System Memory Map, BIOS Data Area,
                         Interrupts 00h to 09h



                                C O N T E N T S

Introduction ................................................... 2**1
System Memory Map .............................................. 2**2
A Brief Guide to Current Memory Terminology .................... 2**3
PC Port Assignment ............................................. 2**4
Reserved Memory Locations ...................................... 2**5
Absolute Addresses ............................................. 2**6
The IBM PC System Interrupts (Overview) ........................ 2**7
Quick Chart of Interrupts 00h-0FFh ............................. 2**8
IRQ Usage Chart ................................................ 2**9
The IBM-PC System Interrupts 00h-0Fh (in detail) ............... 2**10



Introduction ................................................... 2**1

  For consistency in this reference, all locations and offsets are in 
hexadecimal unless otherwise specified. All hex numbers are prefaced 
with a leading zero if they begin with an alphabetic character, and 
are terminated with a lowercase H (h). The formats vary according to 
common usage. 



System Memory Map .............................................. 2**2

  The IBM PC handles its address space in 64k segments, divided into 
16k fractions and then further as necessary. 

ÚÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³start ³start³end  ³                                                ³
³addr. ³addr.³addr.³                     usage                      ³
³(dec) ³   (hex)   ³                                                ³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   *640k RAM Area*                                                 ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0k   ³         ³  start of RAM, first K is interrupt vector table ³
³ 16k  ³0000-03FF³  PC-0 system board RAM ends                      ³
³ 32k  ³0400-07FF³                                                  ³
³ 48k  ³0800-0BFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 64k  ³1000-13FF³  PC-1 system board RAM ends                      ³
³ 80k  ³1400-17FF³                                                  ³
³ 96k  ³1800-1BFF³                                                  ³
³ 112k ³1C00-1FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 128k ³2000-23FF³                                                  ³
³ 144k ³2400-27FF³                                                  ³
³ 160k ³2800-2BFF³                                                  ³
³ 176k ³2C00-2FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 192k ³3000-33FF³                                                  ³
³ 208k ³3400-37FF³                                                  ³
³ 224k ³3800-3BFF³                                                  ³
³ 240k ³3C00-3FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 256k ³4000-43FF³  PC-2 system board RAM ends                      ³
³ 272k ³4400-47FF³                                                  ³
³ 288k ³4800-4BFF³                                                  ³
³ 304k ³4C00-4FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 320k ³5000-53FF³                                                  ³
³ 336k ³5400-57FF³                                                  ³
³ 352k ³5800-5BFF³                                                  ³
³ 368k ³5C00-5FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 384k ³6000-63FF³                                                  ³
³ 400k ³6400-67FF³                                                  ³
³ 416k ³6800-6BFF³                                                  ³
³ 432k ³6C00-6FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 448k ³7000-73FF³                                                  ³
³ 464k ³7400-77FF³                                                  ³
³ 480k ³7800-7BFF³                                                  ³
³ 496k ³7C00-7FFF³                                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 512k ³8000-83FF³                                                  ³
³ 528k ³8400-87FF³                                                  ³
³ 544k ³8800-8BFF³  the original IBM PC-1 BIOS limited memory to    ³
³ 560k ³8C00-8FFF³  544k                                            ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 576k ³9000-93FF³                                                  ³
³ 592k ³9400-97FF³                                                  ³
³ 609k ³9800-9BFF³                                                  ³
³ 624k ³9C00-9FFF³ to 640k (top of RAM address space)               ³
³ 639k ³         ³ some RLL and SCSI hard disk adapters, some four  ³
³      ³         ³ floppy controller cards, some AMI and PS/2 BIOS, ³
³      ³         ³ and assorted other cards sometimes try to use the³
³      ³         ³ last K for storing temporary data.  This can     ³
³      ³         ³ cause trouble with programs which assume they    ³
³      ³         ³ have a full 640k, and will prevent backfilling   ³
³      ³         ³  memory with some memory managers.  Beware!      ³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³A0000 ***** 64k ***** EGA/VGA starting address                     ³
³A0000 ***** 64k ***** Toshiba 1000 DOS ROM (MS-DOS 2.11V)          ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 640k ³A0000-A95B0³  MCGA 320x200 256 color video buffer           ³
³      ³     -AF8C0³  MCGA 640x480 2 color video buffer             ³
³      ³     -A3FFF³                                                ³
³ 656k ³A4000-A7FFF³                                                ³
³ 672k ³A8000-ABFFF³this 64k segment may be used for contiguous DOS ³
³ 688k ³AC000-AFFFF³RAM with appropriate hardware and software      ³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³B0000 ***** 64k ***** mono and CGA address                         ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 704k ³B0000-B3FFF³4k  mono display | The PCjr and early Tandy 1000³
³ 720k ³B4000-B7FFF³                 | BIOS revector direct write to³
³ 736k ³B8000-BBFFF³16k CGA          | the B8 area to the Video Gate³
³ 756k ³BC000-BFFFF³                 | Array and reserved system RAM³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³C0000 ***** 64k *************** expansion ROM                      ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 768k ³C0000-C3FFF³16k EGA BIOS C000:001E EGA BIOS signature       ³
³      ³           ³    (the letters 'IBM')                         ³
³      ³C0000-C7FFF³32k VGA BIOS extension (typical)                ³
³ 784k ³C4000-C5FFF³                                                ³
³      ³C6000-C63FF³256 bytes IBM PGC video communications area     ³
³      ³C6400-C7FFF³                                                ³
³ 800k ³C8000-CBFFF³16k hard disk controller BIOS, drive 0 default  ³
³      ³CA000      ³    some 2nd floppy (HD) controller BIOSes      ³
³ 816k ³CC000-CDFFF³ 8k IBM PC Network NETBIOS                      ³
³      ³CE000-CFFFF³                                                ³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³D0000 ***** 64k ***** expansion ROM                                ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 832k ³D0000-D7FFF³32k IBM Cluster Adapter  | PCjr first ROM cart. ³
³      ³      DA000³voice communications     | address area.        ³
³ 848k ³D4000-D7FFF³                         | Common EMS board     ³
³ 864k ³D8000-DBFFF³                         | paging area.         ³
³      ³D8000-DBFFF³ IBM Token Ring default Share RAM address       ³
³      ³DC000      ³ IBM Token Ring default BIOS/MMIO address       ³
³ 880k ³DC000-DFFFF³                         |                      ³
³      ³DE000      ³4k  TI Pro default video buffer                 ³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³E0000 ***** 64k ***** expansion ROM                                ³
³                      wired to ROM sockets in the original IBM AT  ³
³                      used by ABIOS extensions on some PS/2 models ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 896k ³E0000-E3FFF³                         | PCjr second ROM cart.³
³ 912k ³E4000-E7FFF³                         | address area         ³
³ 928k ³E8000-EBFFF³                         |                      ³
³ 944k ³EC000-EFFFF³                         | spare ROM sockets on ³
³      ³           ³                         | IBM AT (reserved in  ³
³      ³           ³                         | hardware)            ³
ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³F0000 ***** 64k ***** system                                       ³
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 960k ³F0000-F3FFF³reserved by IBM          | cartridge address    ³
³ 976k ³F4000-     ³                         | area (PCjr cartridge ³
³      ³F6000      ³ROM BASIC Begins         | BASIC)               ³
³ 992k ³F8000-FB000³                         |                      ³
³ 1008k³FC000-FFFFF³ROM BASIC and original   |                      ³
³      ³           ³BIOS (Compatibility BIOS |                      ³
³      ³           ³in PS/2)                 |                      ³
³ 1024k³      FFFFF³end of memory (1024k) for 8088 machines         ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 384k ³100000-15FFFF³ 80286/AT extended memory area, 1Mb mbd.      ³
³ 15Mb ³100000-FFFFFF³ 80286/AT extended memory address space       ³
³ 15Mb ³160000-FDFFFF³ Micro Channel RAM expansion (15Mb ext. mem)  ³
³ 128k ³FE0000-FFFFFF³ system board ROM        (PS/2 Advanced BIOS) ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  64k ³C0000000-C000FFFF³ Weitek "Abacus" math coprocessor         ³
³      ³                 ³ memory-mapped I/O                        ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

1) Note that the ROM BIOS has a duplicated address space which causes 
   it to "appear" both at the end of the 1 megabyte real mode space
   and at the end of the 16 megabyte protected mode space.  The
   addresses from 0E0000 to 0FFFFF are equal to 0FE0000 to 0FFFFFF.
   This is necessary due to differences in the memory addressing
   between Real and Protected Modes. 

2) Late IBM XTs and ATs with support for the 101-key keyboards ran out 
   of ROM space at the top of their ROM blocks. These machines "wrap
   around" and jump to an address lower than their original entry
   point to store their code. 

                          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    1024k ³   top of memory    ³
                          ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                     976k ³ original BIOS area ³ ÄÄÄÄ¿
                          ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´     ³
                          ³ extended BIOS area ³  <ÄÄÙ
                          ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

3) IBM PS/2s reserve the last K of memory before A000 for a scratch 
   area for the ABIOS ROM routines.  This limits PS/2 machines to
   639k.  Apparently only 10 to 20 bytes of memory is actually used;
   though there was room for that much down in unused portions of
   the BIOS Data Area, IBM evidently decided to leave room to grow. 

    Sometimes other stuff can use the last K.  OMTI hard disk 
    controllers' firmware wanted the last K, as do some XTs with ROM-
    based disk caches.  These don't like to coexist at all.
    SpeedStor (disk management software) has a program called OMTIfix
    bundled to allow it to work with these controllers.  A few
    extended-VGA ANSI drivers also grab the last K.  QEMM, 386Max,
    and other memory managers can relocate this memory to give a 
    complete 640k. 

4) When running with a 286 and memory manager board or on a 386, PC-
   MOS/386 relocates its kernel to the 0C000-0F000 high memory area
   to leave more of the lower 640k for applications.  0A000-0BFFFF
   is reserved for swapping video RAM as it becomes active.  MOS
   supports monochrome and CGA modes directly. 

5) Most AT compatible machines use the entire Fxxx block for BIOS.  
   PS/2 and PS/2 compatible machines take an entire 128k from E000-
   FFFF.  Most real IBM machines also have the BASIC ROMs taking up
   some of the high address space. 



A Brief Guide to Current Memory Terminology .................... 2**3

LOW MEMORY - 0000h to around 0:5(something), comprising the 80x8x
             interrupt vector table, the BIOS Data Area, DOS Data
             Area, etc.

CONVENTIONAL MEMORY - from the end of low memory to the beginning of
             the "reserved by IBM" A000 segment (640k).

HIGH MEMORY - originally noncontiguous RAM stuffed into the "reserved
             for ROM expansion" areas, typically segments D000 and
             E000.  DOS normally can't access this memory without a
             driver of some sort, but it's easy to put RAMdisks and
             stuff in there.

HIGH DOS MEMORY - same as above.

CONVENTIONAL MEMORY - extra RAM stuck at A000, assuming the machine
             already has 640k, appears as conventional memory accessible
             to DOS and applications.  IBM clones can typically add 64k
             before bumping into a mono card or 96k before hitting a
             color card.  This address is part of the EGA/VGA video RAM
             area and most EGA cards don't like system memory at A000.
             With semi-compatible machines like the IBM PCjr or Sanyo
             55x, it was possible to get as much as 960k of real, usable
             DOS conventional memory, since they used a different video
             system and had no hard disk ROM to break up the space
             between 640k and the beginning of the ROM BIOS.

EXPANDED MEMORY - LIM 3.2, LIM 4.0, or EEMS 3.2 bank switched memory.
             A RAM "window" allows an application to save a block of
             RAM to an expansion board.  The window size and location
             varies according to the EMS standard being used.

EXTENDED MEMORY - this is the "native mode" address space of the 80286
             and later chips.  The "real mode", or 8088 addressing
             scheme, sees RAM as a collection of segments and offsets
             with a limit on segment size.  "Protected mode" addressing
             uses a flat linear addressing scheme.  8088 and 80188 chips
             do not have extended memory.

HIGH MEMORY - by fiddling a bit with the segment/offset stuff, you can
             get an extra block of addressable 8088-mode memory just
             over the 1 meg address space when using 80286 and later
             microprocessors.  Microsoft issued their "HMA" (High Memory
             Area) standard to try to standardize use of this block.
             Though it really is "high" memory, "high" had for many years
             referred to memory between 640k and 1mb.  This creates more
             confusion for new programmers.

EMS - this is expanded memory as described above

XMS - Microsoft is pushing an "Extended Memory Standard" which defines
      a page-switching scheme much like EMS.  The only real difference
      is that XMS uses protected-mode RAM instead of a special paged
      RAM board.

XMS - some severely brain-damaged jerk at IBM issued documentation for
      some IBM *EMS* boards referring to the boards as *XMS*.  This
      was a classic blunder, and now some IBM-followers are picking up
      the aberrant terminology.  This is guaranteed to confuse some
      people.  To make it simple, if it needs an expansion board, it is
      EMS no matter what the vendor calls it.

UMB - Upper Memory Blocks.  These are defined in the Microsoft XMS
      Specification.  Unfortunately, some people have begun using "UMB"
      to refer to the HMA and High DOS areas indiscriminately.



PC Port Assignment ............................................. 2**4

  The Intel 80x86 processors have a 64K I/O memory space for 
addressing external devices.  The 8088 through 80286 processors can 
divide their I/O space into either 8 bit or 16 bit ports.  The 386 and 
later can have 8, 16, or 32 bit ports. 

  Some port addresses are mapped to the motherboard, others to the 
slots. The XT's boundary was at 200h, while the AT and EISA is at 
100h.  Many cards avoid the 100h-200h zone for XT compatibility. 

  These are functions common across the IBM range.  The PCjr, PC-AT, 
PC Convertible and PS/2 (both buses) have enhancements.  In some 
cases, the AT and PS/2 series ignore, duplicate, or reassign ports 
arbitrarily.  If your code incorporates specific port addresses for 
video or system board control it would be wise to have your 
application determine the machine type and video adapter and address 
the ports as required. 


 hex address                   Function                   Models
                                                PCjr|PC|XT|AT|CVT|M30|PS2

 0000-000F    8237 DMA controller                  PC------------------
 0000-001F    8237 DMA controller 1                 -----AT---------PS2
 0020-0027    8259A interrupt controller            -------------------
 0020-002F    IOSGA interrupt function              ----------------PS2
 0020-003F    8259A interrupt controller  (AT)      -------------------
 0020-0021    interrupt controller 1, 8259A        PC----AT---------PS2
 0040-0043    programmable timer 8253              PC------------------
 0040-0047    programmable timers                   ----------------PS2
 0040-005F    8253-5 programmable timers            -----AT------------
              note 1) 0041 was memory refresh in PCs. Not used in PS/2.
                   2) A few early 80386 machines used static RAM and did
                      not use refresh at all. The PCjr refreshes by the
                      video vertical retrace signal.
 0040         8254 programmable interval timer 1 system clock (counter 0)
 0041         8254 timer 1 refresh request (counter 1)
 0042         8254 timer 1 speaker tone (counter 2) -------------------
 0043         8254 timer 1 command register         -------------------
 0049         8254 timer 2 not used (counter 1)     -------------------
 004A         programmable interval timer 2         -------------------
 004B         programmable interval timer 2         -------------------
 0060-0063    keyboard controller 8255A             PC-----------------
 0060-006F    8042 keyboard controller              -----AT------------
 0060         8042 data I/O register                -------------------
 0060         IOSGA keyboard input port             ----------------PS2
 0061         speaker                         PCjr PC-XT-AT-CVT--------
 0061         IOSGA speaker control                 ------------M30-PS2
 0061         On some clones, setting or clearing bit 2 controls
              Turbo mode
 0061         Toshiba 1000 - system command         -------------------
 0062         IOSGA configuration control           ------------M30-PS2
 0062         Toshiba 1000 - System Status, port C  -------------------
 0063         SSGA, undocumented                    ----------------PS2
 0063         Toshiba 1000 - mode set               -------------------
 0064         keyboard auxiliary device             ----------------PS2
 0064         keyboard 8042 status register         -----AT------------
 0065         AT&T 6300+ high/low chip select       -------------------
 0065-006A    SSGA, undocumented                    ----------------PS2
 0066         AT&T 6300+ system configuration switch 2
 0067         AT&T 6300+ system configuration switch 1
 0068         C&T chipsets, turbo mode              -------------------
 006B         SSGA, RAM enable/remap                ----------------PS2
 006C-006F    SSGA, undocumented                    ----------------PS2
 0070         AT CMOS write internal register       -------------------
 0071         AT CMOS read internal register        -------------------
 0070-0071    CMOS real-time clock, NMI mask        ----------------PS2
 0070-007F    CMOS real-time clock, NMI mask        -----AT, AT&T 6300+
 0074-0076    reserved                              ----------------PS2
 0080-0083    AT&T 6300+ DMA page registers (8 bit) -------------------
 0080-008F    SSGA DMA page registers               ----------------PS2
 0080-009F    DMA page registers, 74LS612           -----AT------------
              Channel 2 = 0081
              Channel 3 = 0082
              Channel 1 = 0083
              Channel 0 = 0087
              Channel 6 = 0089
              Channel 5 = 008B
 0090         central arbitration control port (Micro Channel)
 0091         card selected feedback           (Micro Channel)
 0092         system control port A            (Micro Channel)
 0092         Fast Gate A20, some C&T chipsets, Micronics motherboards
 0093         reserved                         (Micro Channel)
 0094         system board setup               (Micro Channel)
 0096         POS "CD SETUP" selector          (Micro Channel)
 00A0-00A1    Interrupt controller 2, 8259A         -----AT---------PS2
 00A0-00A3    AT&T 6300+, NMI register              -------------------
 00A0-00AF    IOSGA NMI mask register               ----------------PS2
 00B0-00BF    realtime clock/calendar, (undocumented) --------------PS2
 00C0-00C3    AT&T 6300+, reserved                  -------------------
 00C0-00CF    DOS ROM register, Toshiba 1000        -------------------
 00C0-00CF    8237A-5 word DMA controller
 00C0-00DF    reserved                        PCjr PC XT AT CVT M30
 00D0-00D3    AT&T 6300+, reserved                  -------------------
 00D0-00EF    "special" register, Toshiba 1000      -------------------
      00C0    0C1 key register, Toshiba 1000        -------------------
      00C1    keyboard transfer register, Toshiba 1000
      00C2    keyboard receive register, Toshiba 1000
      00C3    keyboard status register, Toshiba 1000-------------------
      00C8    DOS ROM page register, Toshiba 1000   -------------------
      00E0    CPU speed control, Toshiba 1000       -------------------
      00E1    keyboard status/0E2 key register, Toshiba 1000
      00E2    work register, Toshiba 1000           -------------------
      00E3    0E4 key register, Toshiba 1000        -------------------
      00E4    system control register 0, Toshiba 1000
      00E4    Weitek ABACUS NDP - bit 0=1, ABACUS is present
      00E5    0E6 key register, Toshiba 1000        -------------------
      00E6    system control register 1, Toshiba 1000
      00EE    EMS unit index, Toshiba 1000          -------------------
      00EF    EMS unit data, Toshiba 1000           -------------------
 00C0-00DF    DMA controller 2, 8237A-5             -----AT---------PS2
 00E0-00EF    realtime clock/calendar  (undocumented)-----------M30 PS2
 00E0-00FF    AT&T 6300+, 80287                     -------------------
 00F0-00FF    PS/2 math coprocessor I/O  (Model 50+)
              (diskette IO on PCjr)
 00F0         clear math coprocessor busy           -------------------
 00F1         reset math coprocessor                -------------------
 00F8-00FF    AT 80287/80387 coprocessor control    -------------------
 0100-0101    PS/2 POS adapter ID response            (Micro Channel)
 0100-010F    Always IN-2000 alternate 2            -------------------
 0100-02F7    AT&T 6300+, reserved                  -------------------
 0102-0107    PS/2 POS adapter configuration response (Micro Channel)
 0110-011F    Always IN-2000 alternate 2            -------------------
 0150         Geographics Drafting Board digitizer  -------------------
 0180         Stargate Plus 8 multiport serial board-------------------
 01F0-01F8    hard disk                             -----AT---------PS2
 0200-0201    game-control adapter (joystick)       -------------------
 0200-0207    Sound Blaster joystick port           -------------------
 0200-020F    game controller                       PC---AT------------
 0200-020F    Always IN-2000 alternate 1
 0208-0209    Chips & Technology CS8221 chipset default EMS ports
              alternate addresses: 218h, 258h, 268h, 2A8h, 2B8h, 2E8h
 0208-020F    Toshiba 1000 - EMS unit I/O #1        -------------------
 020C-020D    reserved by IBM                       -------------------
 0210-0217    IBM expansion chassis (PC, XT)        -------------------
 0218-021F    Toshiba 1000 - EMS unit I/O #2        -------------------
 021F         reserved by IBM                       -------------------
 0220         LANtastic 2mbps adapter optional      -------------------
 0220         Sound Blaster 1-6 data port opt 1     -------------------
 0221         Sound Blaster 1-6 register port opt 1 -------------------
 0222         Sound Blaster 7-12 data port opt 1    -------------------
 0223         Sound Blaster 7-12 register port opt 1-------------------
              (opt 1:220h, opt 2:210h, opt 3:230h, opt 4: 240h, opt
               5:250h, opt 5:260h, FM music and DSP ports also adjustable)
 0220-022F    Always IN-2000 SCSI adapter default addresses
 0220         IRMA 3270 terminal emulator command port
 0221         IRMA 3270 terminal emulator data port 1
 0222         IRMA 3270 terminal emulator data port 2
 0223         IRMA 3270 terminal emulator data port 3
 0224         IRMA 3270 terminal emulator reserved for future use
 0225         IRMA 3270 terminal emulator reserved for future use
 0226         IRMA 3270 terminal emulator Command Request flag
 0226         Sound Blaster DSP Reset               -------------------
 0227         IRMA 3270 terminal emulator Attention Request flag
 0228         Sound Blaster FM music data/status port
 0229         Sound Blaster FM music register port  -------------------
 022A         Sound Blaster DSP (voice I/O and MIDI) Read Data
 022C         Sound Blaster DSP Write Data or Command
 022C         Sound Blaster DSP Write Buffer Status (bit 7)
 022C         Marstek scanner adapter, optional     -------------------
 022E         Sound Blaster DSP Data Available (bit 7)
 0232-023E    Microsoft bus & InPort mouse cards (default address)
 0238-023C    Microsoft bus & InPort mouse cards (optional address)
 023C-023F    Logitech bus mouse                    -------------------
 0240         LANtastic 2mbps adapter optional      -------------------
 0240-0247    Corvus Omninet NIC opt 1              -------------------
 0248-024F    Corvus Omninet NIC opt 2              -------------------
 0250-0257    Corvus Omninet NIC opt 3              -------------------
 0258-0259    LIM EMS 3.1 (not defined in 3.2+)     -------------------
 0258-025F    Corvus Omninet NIC opt 4              -------------------
 0258-025F    Toshiba 1000 - EMS unit I/O #3        -------------------
 0260         LANtastic 2mbps adapter optional      -------------------
 0268         CompuCom internal modem, COM20, COM21, COM22
 026C         Marstek scanner adapter, optional     -------------------
 0268-026F    Toshiba 1000 - EMS unit I/O #4        -------------------
 0268-026F    Copy II PC Option Board, default      -------------------
 0278         CompuCom internal modem, COM6, COM8, COM13
 0278-027F    parallel printer port 2               -----AT------------
 0278-027B    parallel printer port 3               ----------------PS2
 0280-0281    Frecom FAX96 board default            -------------------
 0280-0284    NetWorth Engineering vLAN V2.1 NIC opt 1
 0280         LANtastic 2mbps adapter optional      -------------------
 0280         Logitech ScanMan, default             -------------------
 0280         Needham Electronics PB-10 EPROM burner, optional
 0288-0289    Frecom FAX96 board alternate 1        -------------------
 0290         Needham Electronics PB-10 EPROM burner, optional
 02A0         Logitech ScanMan, option 1            -------------------
 02A0-02BF    Gateway G-Net NIC opt 1               -------------------
 02A0         LANtastic 2mbps adapter optional      -------------------
 02A2         clock chip in early Sperry PCs        -------------------
 02A8-02AF    Toshiba 1000 - EMS unit I/O #5        -------------------
 02AC         Marstek scanner adapter, optional     -------------------
 02B0-02DF    EGA (alternate)                       PC---AT------------
 02B8-02BF    Toshiba 1000 - EMS unit I/O #6        -------------------
 02B8-02B9    Novell Star Intelligent NIC opt 1     -------------------
 02B8-02BB    Novell Standard NIC                   -------------------
 02BC-02BD    Novell Star Intelligent NIC opt 2     -------------------
 02C0-02DF    Toshiba 1000 - realtime clock         -------------------
 02C0-02C7    AST SixPackPlus clock                 -------------------
 02E0-02EF    Gateway G-Net NIC opt 2               -------------------
 02E0-02EF    Allen-Bradley VistaLAN/PC adapter, optional address 1
 02E0-02EF    Standard Microsystems ARCNET NIC opt 1-------------------
 02E0         Stac Electronics AT/16 compression board (Stacker)
 02E0         this is a common address for generic Arcnet cards
 02E1         GPIB (adapter 0)                      -----AT------------
 02E2-02E3    data acquisition (adapter 0)          -----AT------------
 02E8         "industry standard" COM4              -------------------
 03E8         CompuCom internal modem, COM17, COM18, COM19
 02E8-02EF    Toshiba 1000 - EMS unit I/O #7        -------------------
 02E8-02EF    Copy II PC Option board, optional 1   -------------------
 02EC         most Marstek scanner boards, default  -------------------
 02F0-02FF    Standard Microsystems ARCNET NIC opt 2-------------------
 02F8-02FF    serial communications (COM2)          PC---AT---------PS2
 0300         Periscope debugger card               -------------------
 0300-0307    Pelican 5.5mb floppy adapter, default address
 0300-030F    Standard Microsystems ARCNET NIC opt 3-------------------
 0300-030F    3Com EtherLink NIC opt 1              -------------------
 0300-031F    Gateway G-Net NIC opt 3               -------------------
 0300-031F    prototype card                        PC---AT------------
 0300-031F    Leading Edge Model D clock            -------------------
 0300         some Samsung XT clock/calendar on motherboard
 0300         Needham Electronics PB-10 EPROM burner, default
 0300-0303    Tecmar/Wangtek PC-36 tape controller board, default
 0300-0307    3Com 3C505 EtherLink Plus NIC opt 1   -------------------
 0300-0307    Proteon ProNET NIC w/checksum opt 1   -------------------
 0308-030F    Proteon ProNET NIC w/checksum opt 2   -------------------
 0300-031F    Torus Ethernet adapter, optional address 1
 0300-031F    Micom-Interlan N15010 Ethernet NIC opt 1
 0300-031F    Cabletron Ethernet E-1010 NIC         -------------------
 0310-0317    3Com 3C505 EtherLink Plus NIC opt 1   -------------------
 0310-0317    Proteon ProNET NIC w/checksum opt 3   -------------------
 0310-0317    Pelican 5.5mb floppy adapter, optional address 1
 0310-031F    3Com EtherLink NIC opt 2              -------------------
 0320         LANtastic 2mbps adapter optional      -------------------
 0320         Perstor HD controller, primary addr   -------------------
 0320         many CD-ROM proprietary adapters, default address
 0320-0323    AT&T 6300+, hard disk controller      -------------------
 0320-0327    3Com 3C505 EtherLink Plus NIC opt 1   -------------------
 0320-032F    hard disk controller                  PC-----------------
 0320-033F    Torus Ethernet adapter, optional address 2
 0320-033F    Micom-Interlan N15010 Ethernet NIC opt 1
 0324         Perstor PS180 HD ctrlr, 2ndary addr   -------------------
 0324-0327    C: common secondary hard disk controller address
 032C         Marstek scanner adapter, optional     -------------------
 0330         Logitech ScanMan, option 2            -------------------
 0338-033B    Tecmar PC-36 tape controller board, option 1
 0340         LANtastic 2mbps adapter optional      -------------------
 0340         Logitech ScanMan, option 3            -------------------
 0340         Sony CD-ROM adapters                  -------------------
 0340         Severn (Sony) CD-ROM adapters         -------------------
 0340-0347    Proteon ProNET NIC w/checksum opt 4   -------------------
 0340-0347    Novell Disk Coprocessor #1            -------------------
 0348-034F    Novell Disk Coprocessor #2            -------------------
 0348-0357    DCA 3278 emulator                     -------------------
 0358-0359    Novell Star Intelligent NIC opt 3     -------------------
 035C-035D    Novell Star Intelligent NIC opt 4     -------------------
 0360         LANtastic 2mbps adapter optional      -------------------
 0360-0367    PC Network (low address)              -------------------
 0360-0367    AT&T StarLAN NIC opt 1                -------------------
 0360-0367    Ungermann-Bass Net/One Personal Connection NIC
 0368         CompuCom internal modem, COM7, COM11, COM12
 0368-036B    Tecmar PC-36 tape controller board, option 2
 036C         Marstek scanner adapter, optional
 0368-036F    PC Network (high address)             -----AT------------
 0368-036F    AT&T StarLAN NIC opt 2                -------------------
 0368-036F    Ungermann-Bass Net/One Personal Connection NIC
 0368-036F    Torus Ethernet adapter, optional address 3
 0368-036F    Copy II PC Option Board, optional 2   -------------------
 0370         Colorado Memory external tape backup control port -------
              Archive external tape backup control port ---------------
 0370-0377    some "second controller" floppy cards -------------------
 0372         Systen OmniBridge floppy card, alternate address 1
 0378         CompuCom internal modem, COM5, COM9, COM10
 0378-037F    parallel printer port                 PC---AT------------
 0378-037B    parallel printer port                 ----------------PS2
 0380-0387    PCNet NIC, Orchid, Santa Clara, AST   -------------------
 0380-0387    Pelican 5.5mb floppy adapter, optional address 2 --------
 0380-0381    Frecom FAX96 board alternate 2        -------------------
 0380-0384    NetWorth Engineering vLAN V2.1 NIC opt 1
 0380-038F    Eicon Technology Network Adapter (X.25) board (default)
 0380-038F    SDLC, bi-synchronous 2                PC---AT------------
 0380-0389    BSC communications (alternate)        PC-----------------
 0388-0389    Frecom FAX96 board alternate 3        -------------------
 0388-0389    Sound Blaster FM music, alternate 2   -------------------
 0390         Needham Electronics PB-10 EPROM burner, optional
 0390-0397    Pelican 5.5mb floppy adapter, optional address 3 --------
 0390-039F    Eicon Technology Network Adapter (X.25) board (alternate)
 0390-0393    cluster (adapter 0)                   PC---AT------------
 0398-039B    Tecmar PC-36 tape controller board, option 3
 03A0-03A9    BSC communications (primary)          PC---AT------------
 03AC         Marstek scanner adapter, optional     -------------------
 03B0-03BF    monochrome/parallel printer adapter   PC---AT------------
 03B4-03B5    video subsystem                       ----------------PS2
 03B4-03BF    Hercules Mono Card                    -------------------
 03BA         video subsystem                       ----------------PS2
 03BC-03BF    parallel printer port 1               ----------------PS2
 03C0-03CF    Enhanced Graphics Adapter             -------------------
 03C0-03DA    video subsystem and DAC               ----------------PS2
 03C8-03CB    Tecmar PC-36 tape controller board, option 4
 03DA         video status register                 AT&T 6300, Olivetti PC
 03D0-03DF    CGA, MCGA, VGA adapter control        -------------------
 03DE         video mode selector register          AT&T 6300, Olivetti PC
 03E0-03EF    Allen-Bradley VistaLAN/PC adapter, optional address 1
 03E8h        "industry standard" COM3              -------------------
 03E8         CompuCom internal modem, COM14, COM15, COM16
 03E8-03EF    Copy II PC Option Board, optional 3   -------------------
 03F0-03F7    floppy disk controller                PC---AT---------PS2
 03F0         Colorado Memory internal tape backup control port -------
 03F2         DTK high-density XT floppy controller (output only)
 03F2         Systen OmniBridge floppy card, alternate address 2
 03F5         DTK high-density XT floppy controller PC-XT--------------
 03FC         Marstek scanner adapter, optional     -------------------
 03F8-03FF    serial communications (COM1)          PC---AT---------PS2
 0400-3FFF    AT&T 6300+, unused                    -------------------
 06E2-06E3    data acquisition (adapter 1)          -----AT------------
 0790-0793    cluster (adapter 1)                   PC---AT------------
 0878         Compaq 386SX VGA BIOS relocation      -----AT------------
 0920         C&T/Micronics Fast Gate A20           -------------------
 0A20-0A23    IBM Token Ring opt 1                  -------------------
 0A24-0A27    IBM Token Ring opt 2                  -------------------
 0AE2-0AE3    data acquisition (adapter 2)          -----AT------------
 0B90-0B93    cluster (adapter 2)                   PC---AT------------
 OC80-0C83    EISA Product Identifier access port   -------------------
              2 bytes  3 letters (compressed) abbreviated manufacturer ID.
                       The letters "ISA" are reserved for old bus boards.
              1 byte   2-digit product number
              1 byte   2-digit revision number
              (mfr. abbreviations are assigned by BCPR Services, the
               group that distributes the EISA specification)
 0EE2-0EE3    data acquisition (adapter 3)          -----AT------------

 1390-1393    cluster (adapter 3)                   PC---AT------------
 2160         IBM XGA adapter (not motherboard) (only 1 installed)
 22E1         GPIB (adapter 1)                      -------------------
 2390-2393    cluster (adapter 4)                   PC---AT------------
 3F00-3F1F    AT&T 6300+, -RESET CS                 -------------------
 3F20-3F3F    AT&T 6300+, -PROTECTEN                -------------------
 3F40-3F5F    AT&T 6300+, -TIME SLICEN              -------------------
 3F60-3F7F    AT&T 6300+, -TRAPCE                   -------------------
 3F80-3F9F    AT&T 6300+, -VXLATEN                  -------------------
 3FA0-3FBF    AT&T 6300+, -BITREAD                  -------------------
 3FC0-3FDF    AT&T 6300+, -ADADV                    -------------------
 3FE0-3FFF    AT&T 6300+, -CLear TRAP address       -------------------
 4258         LIM EMS 3.1 (not defined in 3.2+)     -------------------
 42E1         GPIB (adapter 2)                      -----AT------------
 62E1         GPIB (adapter 3)                      -----AT------------
 8258         LIM EMS 3.1 (not defined in 3.2+)     -------------------
 82E1         GPIB (adapter 4)                      -----AT------------
 A2E1         GPIB (adapter 5)                      -----AT------------
 C258         LIM EMS 3.1 (not defined in 3.2+)     -------------------
 C2E1         GPIB (adapter 6)                      -----AT------------
 E2E1         GPIB (adapter 7)                      -----AT------------

note 1) IOSGA = I/O Support Gate Array
        SSGA = System Support Gate Array
     2) I/O Addresses, hex 000 to 0FF, are reserved for the system
        board I/O.  Hex 100 to 3FF are available on the I/O channel.
     3) These are the addresses decoded by the current set of adapter
        cards.  IBM may use any of the unlisted addresses in the future.
     4) SDLC Communication and Secondary Binary Synchronous
        Communications cannot be used together because their port
        addresses overlap.



Reserved Memory Locations ...................................... 2**5

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ 000-3FF  - 1k DOS interrupt vector table, 4 byte vectors for 
³            interrupts 00h-0FFh.
³   30:00  - used as a stack area during POST and bootstrap routines.
³to 3F:FF    This stack area may be revectored by user applications
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ ** The BIOS Data Area ** addresses from 400h to 4FFh
ÃÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³addr.³ size  ³                         description
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³40:00³  word ³ COM1 port addr. |  These addresses are zeroed out in the
³40:02³  word ³ COM2 port addr. |  OS/2 DOS Compatibility Box if any of
³40:04³  word ³ COM3 port addr. |  the OS/2 COMxx.SYS drivers are loaded.
³40:06³  word ³ COM4 port addr. | | note: no value for COM2 was set in
³40:08³  word ³ LPT1 port addr.   |       early IBM PS/2 Model 50Zs.
³40:0A³  word ³ LPT2 port addr.     | DESQview sets 40:00-40:02 to zero
³40:0C³  word ³ LPT3 port addr.     | if a program is swappable
³40:0E³  word ³ LPT4 port addr.   (not valid in PS/2 machines)
³40:0E³  word ³ PS/2 pointer to 1k extended BIOS Data Area at top of
³40:10³  word ³ RAM equipment flag (see int 11h)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bits:
              ³ 0       0       no floppy drive present
              ³         1       if floppy drive present (see bits 6&7)
              ³ 1       0       no math coprocessor installed
              ³         1       if 80x87 installed  (not valid in PCjr)
              ³ 2,3     system board RAM   (not used on AT or PS/2)
              ³         0,0     16k             0,1     32k
              ³         1,0     48k             1,1     64k
              ³ 4,5     initial video mode
              ³         0,0     no video adapter
              ³         0,1     40 column color  (PCjr default)
              ³         1,0     80 column color
              ³         1,1     MDA
              ³ 6,7     number of diskette drives
              ³         0,0     1 drive         0,1     2 drives
              ³         1,0     3 drives        1,1     4 drives
              ³ 8       0       DMA present
              ³         1       DMA not present (PCjr, Tandy 1400,
              ³                 Sanyo 55x)
              ³ 9,A,B   number of RS232 serial ports
              ³ C       game adapter  (joystick)
              ³         0       no game adapter
              ³         1       if game adapter
              ³ D       serial printer (PCjr only)
              ³         0       no printer
              ³         1       serial printer present
       ÚÄÄÄÄÄÄÙ E,F     number of parallel printers installed
       ³note 1) The IBM PC and AT store the settings of the system board
       ÀÄÄÄ¿    switches or CMOS RAM setup information (as obtained by
           ³    the BIOS in the Power-On Self Test (POST)) at addresses
           ³    40:10h and 40:13h. 00000001b indicates "on", 00000000b
           ³    is "off".
           ³ 2) DOS only uses 40:10 when it's booting to find out how
           ³    many drives it has.  XT BIOSes use 40:10 to find out how
           ³    many drives they support, but AT BIOSes don't seem to -
           ³    they use the state bytes at 40:90/91 instead.
ÚÄÄÄÄÄÂÄÄÄÄÁÄÄ¿
³40:12³  byte ³ reserved (PC, AT)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ number of errors detected by infrared keyboard link
              ³ (PCjr) manufacturer test (Phoenix BIOS)
              ³   bits 7-1 reserved
              ³   bit  0    0 non-test mode
              ³             1 manufacturing test mode
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´ POST status (Convertible)
³40:13³  word ³ available memory size in Kbytes, less display RAM in
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ PCjr, or Extended BIOS Data Area (40:0E) if used.  This
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´ is the value returned by int 12h.
³40:15³  word ³ reserved
³40:17³  byte ³ keyboard flag byte 0 (see int 9h)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 7  insert mode on      3  alt pressed
              ³     6  capslock on         2  ctrl pressed
              ³     5  numlock on          1  left shift pressed
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     4  scrollock on        0  right shift pressed
³40:18³  byte ³ keyboard flag byte 1 (see int 9h)    (IBM, old style)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bits 0=not pressed, 1=pressed
              ³ bit 7  insert pressed      3  ctrl-numlock (pause) toggled
              ³     6  capslock pressed    2  PCjr keyboard click active
              ³     5  numlock pressed     1  PCjr ctrl-alt-capslock held
              ³     4  scrollock pressed   0
              ³
              ³ keyboard flag byte 1 (see int 9h)  (IBM, Phoenix, new style)
              ³ bit 7  insert pressed      3  ctrl-numlock (pause) toggled
              ³     6  capslock pressed    2  SysReq pressed (enhanced kbd)
              ³     5  numlock pressed     1  Left alt pressed (enhanced kbd)
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     4  scrollock pressed   0  Right alt pressed (enhanced kbd)
³40:19³  byte ³ storage for alternate keypad entry (not normally used)
³     ³       ³ Phoenix says, "Work area for Alt key and numeric keypad
³     ³       ³ input"
³40:1A³  word ³ pointer to keyboard buffer head character
³40:1C³  word ³ pointer to keyboard buffer tail character
³40:1E³32bytes³ 16 2-byte entries for keyboard circular buffer, read by
³     ³       ³ int 16h a maximum of 15 entries are used at one time
³40:3E³  byte ³ drive seek status - if bit=0, next seek will recalibrate
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ by repositioning to Track 0.
              ³ bit 7  disk hdw int occured 5  not used
              ³     6  not used             4  not used
              ³     3  drive D          bit 2  drive C
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     1  drive B              0  drive A
³40:3F³  byte ³ diskette motor status (bit set to indicate condition)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 7    0   current operation is a read or verify
              ³          1   current operation is a write or format
              ³     6        reserved
              ³     5,4      drive select states, where:
              ³          00  drive 0 selected
              ³          01  drive 1 selected
              ³          10  drive 2 selected
              ³          11  drive 3 selected
              ³     3    1   motor on (drive 3)
              ³     2    1   motor on (drive 2)
              ³     1    1   motor on (drive 1)
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     0    1   motor on (drive 0)
³40:40³  byte ³ motor off counter
³     ³       ³ starts at 37 and is decremented 1 by each system clock
³     ³       ³ tick.  Motor is shut off when count = 0.
³40:41³  byte ³ status of last diskette operation     where:
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´   (IBM XT)
              ³ bit 7 timeout failure              3 DMA overrun
              ³     6 seek failure                 2 sector not found
              ³     5 controller failure           1 address not found
              ³     4 CRC failure                  0 bad command
              ³   (Phoenix)
              ³ bit 7    1   drive not ready
              ³     6    1   seek failure
              ³     5    1   controller failure
              ³     4,0      error codes in hex, where:
              ³              01h  illegal function request
              ³              02h  address mark not found
              ³              03h  write protect error
              ³              04h  sector not found
              ³              06h  diskette change line active
              ³                   (AT & later)
              ³              08h  DMA overrun
              ³              09h  64K DMA boundary error
              ³              0Ch  media type not found
              ³              10h  uncorrectable EEC or CRC error
              ³              20h  general controller failure
              ³              40h  seek operation failed
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´              80h  timeout
³40:42³7 bytes³ NEC floppy controller chip status bytes (see Chapter 15)
³40:49³  byte ³ Video Control Data Area 1
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ current CRT mode (hex value)
              ³    00h 40x25 BW      (CGA)        01h 40x25 color   (CGA)
              ³    02h 80x25 BW      (CGA)        03h 80x25 color   (CGA)
              ³    04h 320x200 color (CGA)        05h 320x200 BW    (CGA)
              ³    06h 640x200 BW    (CGA)        07h monochrome    (MDA)
              ³extended video modes (EGA/MCGA/VGA or other)
              ³    08h lores,16 color             09h med res,16 color
              ³    0Ah hires,4 color              0Bh n/a
              ³    0Ch med res,16 color           0Dh hires,16 color
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´    0Eh hires,4 color              0Fh hires,64 color
³40:4A³  word ³ # of columns on screen, coded as hex number of columns
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ 20 col = 14h  (video mode 8, low res 160x200 CGA graphics)
              ³ 40 col = 28h
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´ 80 col = 46h
³40:4C³  word ³ screen buffer length in bytes
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄ´(# of bytes used per screen page, varies with video mode)
³40:4E³  word ³ current screen buffer starting offset (active page)
³40:50³8 words³ cursor position pages 1-8
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ the first byte of each word gives the column (0-19, 39,
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´ or 79)  The second byte gives the row (0-24)
³40:60³  byte ³ end line for cursor   (normally 1)
³40:61³  byte ³ start line for cursor (normally 0)
³40:62³  byte ³ current video page being displayed  (0-7)
³40:63³  word ³ base port address of 6845 CRT controller or equivalent
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄ´ for active display           3B4h=mono, 3D4h=color
³40:65³  byte ³ current setting of the CRT mode register
³40:66³  byte ³ current palette mask setting  (CGA)
³40:67³5 bytes³ temporary storage for SS:SP during shutdown (cassette
³     ³       ³  interface)
³40:67³2 bytes³ Phoenix BIOS, address offset of option ROM
³40:6C³  word ³ timer counter low word
³40:6E³  word ³ timer counter high word
³40:69³2 bytes³ Phoenix BIOS, address segment of option ROM
³40:69³  byte ³ HD_INSTALL (Columbia PCs) (not valid on most clones)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit  0    0  8 inch external floppy drives
              ³           1  5-1/4 external floppy drives
              ³      1,2     highest drive address which int 13 will
              ³              accept (since the floppy drives are
              ³              assigned 0-3, subtract 3 to obtain the number
              ³              of hard disks installed)
              ³      4,5     # of hard disks connected to expansion
              ³              controller
              ³      6,7     # of hard disks on motherboard controller
              ³              (if bit 6 or 7 = 1, no A: floppy is present
              ³              and the maximum number of floppies from int
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´              11h is 3)
³40:6B³  byte ³ last interrupt that occurred (used during POST only)
³40:6C³2 bytes³ least significant timer count (ints 08h, 1Ah)
³40:6E³2 bytes³ most significant timer count (ints 08h, 1Ah)
³40:70³  byte ³ 24 hour timer overflow 1 if timer went past midnight
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄ´ it is reset to 0 each time it is read by int 1Ah
³40:71³  byte ³ control-break flag (bit 7 = 1 means break key hit)
³40:72³  word ³ reset flag
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ PCjr keeps 1234h here for softboot when a cartridge is
              ³ inserted
              ³ bits 1234h = soft reset, memory check will be bypassed
              ³      4321h = preserve memory         (PS/2, Phoenix BIOS)
              ³      5678h = system suspended        (Convertible)
              ³      9ABCh = manufacturing test mode (Convertible)
              ³      ABCDh = system POST loop mode   (Convertible)
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´      0064h = burn-in mode            (Phoenix BIOS)
³40:74³  byte ³ status of last hard disk operation ; PCjr special disk
³     ³       ³ control (see Chapter 8 for codes)
³40:75³  byte ³ # of hard disks attached (0-2)     ; PCjr special disk
³     ³       ³                                    ; control
³40:76³  byte ³ HD control byte; temporary holding area for 6th 
³     ³       ³   parameter table entry
³40:77³  byte ³ port offset to current hd adapter  ; PCjr special disk
³     ³       ³                                    ; control
³40:78³4 bytes³ timeout value for LPT1, LPT2, LPT3, LPT4
³40:7C³4 bytes³ timeout value for COM1, COM2, COM3, COM4 (0-0FFh secs,
³     ³       ³     default 1)
³40:80³  word ³ pointer to start of circular keyboard buffer,
³     ³       ³     default 03:1E
³40:82³  word ³ pointer to end of circular keyboard buffer,
³     ³       ³     default 03:3E
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ note: early Zenith Z183 BIOS set these pointers to
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´       zero and ignored them.
³40:84³  .... ³ Video Control Data Area 2, 0040:0084 through 0040:008A
³40:84³  byte ³ rows on the screen minus 1 (EGA only)
³40:84³  byte ³ PCjr interrupt flag; timer channel 0  (used by POST)
³40:84³  byte ³ early AT&T 6300 PCs put 35h here for some reason,
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ messing up programs that check here for number of screen
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´ rows. Later versions of the 6300 put the screen rows here
³40:85³  word ³ bytes per character (EGA only)
³40:85³2 bytes³ (PCjr only) typamatic character to repeat
³40:86³2 bytes³ (PCjr only) typamatic initial delay
³40:87³  byte ³ mode options (EGA only)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 0   0   cursor emulation in effect
              ³         1   no cursor emulation
              ³     1   0   EGA is connected to a color display
              ³         1   EGA is connected to monochrome TTL display
              ³     2   0   wait for vertical retrace (CGA active)
              ³         1   don't wait for vertical retrace
              ³              (EGA or MDA active)
              ³     3   0   EGA is the active display,
              ³         1   "other" display is active.
              ³     4       reserved
              ³     5,6     EGA memory size
              ³             0,0   64k
              ³             0,1   128k
              ³             1,0   192k
              ³             1,1   256k
              ³     7   0   don't clear screen on mode changes
              ³         1   if the last "set mode" specified not to
              ³             clear the video buffer
              ³ mode combinations:
              ³ bit3  bit1     Meaning
              ³   0     0   EGA is active display and is color
              ³   0     1   EGA is active display and is monochrome
              ³   1     0   EGA is not active, a mono card is active
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´   1     1   EGA is not active, a CGA is active
³40:87³  byte ³ (PCjr only) current Fn key code
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄ´             80h bit indicates make/break key code?
³40:88³  byte ³ feature bits and switches (EGA only) 0=on, 1=off
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 0   switch 1
              ³     1   switch 2
              ³     2   switch 3
              ³     3   switch 4
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     4-7 feature bits
³40:88³  byte ³ (PCjr only) special keyboard status byte
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 7  function flag
              ³     6  Fn-B break
              ³     5  Fn pressed
              ³     4  Fn lock
              ³     3  typamatic (0=enable,1=disable)
              ³     2  typamatic speed (0=slow,1=fast)
              ³     1  extra delay bef.typamatic (0=enable)
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     0  write char, typamatic delay elapsed
³40:89³  byte ³ (PCjr) current value of 6845 reg 2 (horiz. synch) used
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ by ctrl-alt-cursor screen positioning routine in ROM
              ³ (VGA)
              ³ bit 0       reserved
              ³     1       video summing enabled
              ³     2   0   for color monitor attached
              ³         1   for mono monitor
              ³     3   0   for default palette loading enabled
              ³     4   0   for 8x8 text font
              ³         1   for 8x16 text font
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´     5-7     reserved
³40:8A³  byte ³ (PCjr) CRT/CPU Page Register Image, default 3Fh
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ (VGA)  Display Combination Code Index.  This is the value
              ³  set/returned by function 1Ah of the Video BIOS.  This
              ³  byte contains an index into the ROM BIOS Display
              ³  Combination Code table, which is a list of byte pairs
              ³  that specify valid combinations of one or two video
              ³  subsystems.  Video subsystems are designated by the
              ³  following values:
              ³  00h     no display
              ³  01h     MDA with monochrome display
              ³  02h     CGA with color display
              ³  03h     reserved
              ³  04h     EGA with color display
              ³  05h     EGA with monochrome display
              ³  06h     Professional Graphics Adapter
              ³  07h     VGA with analog monochrome display
              ³  08h     VGA with analog color display
              ³  09h     reserved
              ³  0Ah     MCGA with digital color display
              ³  0Bh     MCGA with analog monochrome display
              ³  0Ch     MCGA with analog color display
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´  0FFh    unrecognized video subsystem
³40:8B³  byte ³ last diskette data rate selected
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 7,6 starting data transfer rate to use
              ³         0,0      500 kb/sec
              ³         0,1      300 kb/sec
              ³         1,0      250 kb/sec
              ³         1,1      reserved
              ³     5,4 last step rate selected
              ³     3   ending data transfer rate to use
              ³     2   reserved
              ³     1   reserved
              ³     0   1    combination floppy/fixed disk controller
              ³              detected
              ³         0    XT floppy only controller (for 360kb drive)
              ³              detected
              ³                Data Transfer Rates
              ³       Kbits/sec     Media   Drive   Sectors/Track
              ³         250         360k    360k        9
              ³         300         360k    1.2M        9
              ³         500         1.2M    1.2M       15
              ³         250         720k    720k        9
              ³         250         720k    1.4M        9
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´         500         1.4M    1.4M       18
³40:8C³  byte ³ hard disk status returned by controller
³40:8D³  byte ³ hard disk error returned by controller
³40:8E³  byte ³ hard disk interrupt (bit 7 = working interrupt)
³40:8F³  byte ³ combo_card - status of drives 0 and 1   (Tandy)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 7   reserved
              ³     6   drive type determined for drive 1
              ³     5   drive multiple data rate capability for drive 1
              ³         0       no multiple data rate
              ³         1       multiple data rate
              ³     4   1 then drive 1 has 80 tracks
              ³         0 then drive 1 has 40 tracks
              ³     3   reserved
              ³     2   drive type determined for drive 0
              ³     1   drive multiple data rate capability for drive 0
              ³         0       no multiple data rate
              ³         1       multiple data rate
              ³     0   1       the drive 0 has 80 tracks
              ³         0       the drive 0 has 40 tracks
              ³
              ³ combo_card - status of drives 0 and 1   (Phoenix)
              ³ bit 7   reserved
              ³     6   drive type determined for drive 1
              ³     5   drive multiple data rate capability for drive 1
              ³         0       no multiple data rate
              ³         1       multiple data rate
              ³     4   1       drive 1 supports change line
              ³         0       drive 1 does not support change line
              ³     3   reserved
              ³     2   drive type determined for drive 0
              ³     1   drive multiple data rate capability for drive 0
              ³         0       no multiple data rate
              ³         1       multiple data rate
              ³     0   1       drive 0 supports change line
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´         0       drive 0 does not support change line
³40:90³2 bytes³ media state drive 0, 1, 2, 3
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ floppy_media_state
              ³ bit 7,6 Data transfer rate
              ³         00 - 500 K/sec
              ³         01 - 300 K/sec
              ³         10 - 250 K/sec
              ³         11 - reserved
              ³     5   double stepping required
              ³     4   media/drive determined
              ³     3   reserved
              ³     2-0 present state
              ³         000  trying 360k in 360k drive (undetermined)
              ³         001  trying 360k in 1.2M drive (undetermined)
              ³         010  trying 1.2M in 1.2M drive (undetermined)
              ³         011  known 360k in 360k (determined)
              ³         100  known 360k in 1.2M (determined)
              ³         101  known 1.2M in 1.2M (determined)
              ³         110  reserved, not used
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´         111  known 3.5" drive (determined)
³40:92³2 bytes³ Diskette media work area.  Each entry is first diskette
³     ³       ³ media work area value tried.  One byte per drive.  Drive
³     ³       ³ 0 at 92h, drive 1 at 93h.
³40:94³  byte ³ current track number for drive 0
³40:95³  byte ³ current track number for drive 1
³40:96³  byte ³ keyboard flag byte 3 (see int 9h)
³     ³       ³ bits 7  read ID in progress     3  right alt down
³     ³       ³      6  last code was first ID  2  left alt down
³     ³       ³      5  forced NumLock          1  last code was E0h
³     ³       ³      4  101/102 kbd used        0  last code was E1h
³40:97³  byte ³ keyboard flag byte 2 (see int 9h)
³     ³       ³ bits 7  keyboard error          3  reserved
³     ³       ³      6  LED update in progress  2  capslock LED status
³     ³       ³      5  kbd sent RESEND         1  numlock LED status
³     ³       ³      4  kbd sent ACK            0  scrollock LED status
³40:98³  word ³ offset of user wait flag (int 08h, 15h, 1Ah)
³40:9A³  word ³ segment of user wait flag (int 08h, 15h, 1Ah)
³40:9C³  word ³ user wait timeout value in microseconds  (low word)
³40:9E³  word ³ user wait timeout value in microseconds  (high word)
³40:A0³  byte ³ real time clock wait function in use
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bits 7    wait time elapsed and posted flag
              ³      6-1  reserved
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´      0    int 15h, function 86h (WAIT) has occurred
³40:A1³  byte ³ LAN A DMA channel flags
³40:A2³2 bytes³ status LAN A 0,1
³40:A4³ dword ³ saved hard disk interrupt vector
³40:A8³ dword ³ SAVE_PTR: EGA pointer to table of 7 parameters in
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´           segment:offset format.  Format of table:
              ³ D_1 dword   pointer to 1,472 byte table of 64 video
                            parameters
              ³ D_2 dword   reserved
              ³ D_3 dword   reserved
              ³ D_4 dword   reserved
              ³ D_5 dword   reserved for future use
              ³ D_6 dword   reserved for future use
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´ D_7 dword   reserved for future use
³40:B0³2 words³ international support                   (Tandy 1000 TX)
³40:B4³  byte ³ keyboard NMI control flags              (Convertible)
³40:B4³  byte ³ monochrome monitor hookup detect        (Tandy 1000 TX)
³     ³       ³ 00h not present   0FFh  present
³40:B5³ dword ³ keyboard break pending flags            (Convertible)
³40:B5³  byte ³ extended equipment detect  (5 bits)     (Tandy 1000 TX)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 0 = 0   drive A is 5¬
              ³         1   drive A is 3«
              ³     1 = 0   drive B is 5¬
              ³         1   drive B is 3«
              ³     2 = 0   Tandy 1000 keyboard layout
              ³         1   IBM keyboard layout
              ³     3 = 0   CPU slow mode
              ³         1   CPU fast mode
              ³     4 = 0   internal color video support enabled
              ³         1   internal color video support disabled,
              ³             external video enabled (chg from mb'd
              ³             to expansion card)
              ³     5 = 0   no external monochrome video installed
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´         1   external monochrome video installed
³40:B6³  byte ³ extended equipment detect  (1 bit)      (Tandy 1000 TX)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ bit 0 = 0   drive C is 5¬
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´         1   drive C is 3«
³40:B9³  byte ³ port 60 single byte queue               (Convertible)
³40:BA³  byte ³ scan code of last key                   (Convertible)
³40:BB³  byte ³ pointer to NMI buffer head              (Convertible)
³40:BC³  byte ³ pointer to NMI buffer tail              (Convertible)
³40:BD³16bytes³ NMI scan code buffer                    (Convertible)
³40:CE³  word ³ day counter                    (Convertible and after)
³  to ³ -04:CF³               end of BIOS Data Area
ÃÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ ** End of BIOS Data Area **
³ ** Beginning of "Extra Data Area" **
ÃÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³40:D0³-40:EF ³ reserved by IBM
³40:F0³16bytes³ Inter-Application Communications Area (for use by
³40:FF³       ³ apps to transfer data or parameters to each other)
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´  1) Used by Turbo Power's FMARK (mark memory for TSRs).
              ³  2) Used by Norton Utilities' TimeMark to store the time.
              ³  3) Used by BRIEF editor.
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´  4) TopView saves this area during task switches
                 5) Some 1992/1993 Phoenix BIOS used in Gateway 2000
                    486 DX/2 motherboards are buggy and corrupt this
                    area.
³50:00³ byte  ³ DOS print screen status flag
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´        00h    not active or successful completion
              ³        01h    print screen in progress
ÚÄÄÄÄÄÂÄÄÄÄÄÄÄ´        0FFh   error during print screen operation
³50:01³       ³ Used by BASIC
³50:02-03     ³ PCjr POST and diagnostics work area
³50:04³  byte ³ Single drive mode status byte - not used by AT&T DOS 2.11!
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´         00     logical drive A was last active
              ³         01     logical drive B was last active
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ´        0FFh    don't know (some DOS versions)
³50:05-0E     ³ PCjr POST and diagnostics work area
³50:0F³       ³ BASIC: SHELL flag (set to 02h if there is a current
                       SHELL)
³50:10³  word ³ BASIC: segment address storage (set with DEF SEG)
³50:12³4 bytes³ BASIC: int 1Ch clock int vector segment:offset storage
³50:16³4 bytes³ BASIC: int 23h ctrl-break int segment:offset storage
³50:1A³4 bytes³ BASIC: int 24h disk error int vector segment:offset
³50:1B-1F     ³ Used by BASIC for dynamic storage
³50:20-21     ³ Used by DOS for dynamic storage
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ According to the IBM TopView programmer's reference,
              ³ 50:10 through 50:21 are used by BASIC, BASICA, and
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ´ programs compiled by the IBM BASIC Compiler.
³50:22-2C     ³ Used by DOS for diskette parameter table.  See int 1Eh
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄ´ listing for values.  In DOS 1.0 this is located in the
              ³ ROM BIOS, but in DOS 1.1 and later it is a part of DOS
              ³ located at 05:22.  The first byte (out of eleven) of
              ³ the Disk Parameter Table contains the hexadecimal value
              ³ CF in DOS 1.0 and DF in DOS 1.1 and later.
              ³ DOS 1.0   24ms
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOS 1.1   26ms
³50:30-33     ³ Used by MODE command
³50:81³       ³ number of floppies installed in the system?
³50:82³       ³ first hard disk drive?
³50:83³       ³ last hard disk drive?
³50:34-FF     ³ Unknown - Reserved for DOS
³70:00        ³ PC-MOS/386 loads into the lowest available memory,
³             ³ starting from this point.
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ ** End of "Extra Data Area" **
³ ** Beginning of "Extended Data Area" **  (Phoenix specs)
³    ("EDA" is segment address of top of memory)
ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³EDA:00³ byte ³ Size of EDA in Kb (usually 1)
³EDA:22³ word ³ pointing device driver FAR call offset
³EDA:24³ word ³ pointing device driver FAR call segment
³EDA:26³ byte ³ pointing device flag (first byte)
³      ³      ³ bits 7 = 1  command in progress
³      ³      ³      6 = 1  resend
³      ³      ³      5 = 1  acknowlege
³      ³      ³      4 = 1  error
³      ³      ³      3 = 0  reserved
³      ³      ³    2-0      index count
³EDA:27³ byte ³ pointing device flag (second byte)
³      ³      ³ bits 7      device driver FAR call flag
³      ³      ³    6-3 = 0  reserved
³      ³      ³    2-0      package size
³EDA:28³ byte ³ \
³  to  ³      ³  pointing device data
³EDA:2E³ byte ³ /
³EDA:30³      ³ \
³  to  ³      ³  reserved
³EDA:38³      ³ /
³EDA:39³ word ³ initial count for fail-safe timer
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Absolute Addresses ............................................. 2**6

0008:0047 IO.SYS or IBMBIO.COM IRET instruction.  This is the dummy 
          routine that interrupts 01h, 03h, and 0Fh are initialized to
          during POST. 
C000:001E EGA BIOS signature (the letters IBM) 
F000:FA6E table of characters 00h-7Fh used by int 10h video BIOS
          The first 128 characters are stored here and each occupies 8
          bytes.  The high bit ones are somewhere on the video adapter
          card.
F000:FFFE PC model identification.  Note: some early IBM XTs return
          the PC ID code.  Clones can return anything.  To identify
          the submodel you need to do  an int 15h, AH=0C0h (Return
          System Configuration Parameters).  This call is not supported
          in early XT and AT BIOSes. 
FDFF:000E check this word value to identify GRiD machines: 
          00h  GRiDCase     (Old [first release] GRiDCase)
          03h  Tempest      (Tempest GRiDCase)
          04h  GRiDCase Plus
          14h  GRiDLite
          0Ch  GRiDCase Plus Minus
          34h  GRiD 1520    (GRiD AT clone)
          74h  GRiD 1530    (GRiD-386)
FE05B     POST entry point                          (IBM standard addr.)
FE2C3     NMI handler entry point                   (IBM standard addr.)
FE3FE     int 13h hard disk services entry point    (IBM standard addr.)
FE401     hard disk parameter table                 (IBM standard addr.)
FE729     baud rate generator table                 (IBM standard addr.)
FE739     int 14h async services entry point        (IBM standard addr.)
FE82E     int 16h keyboard services entry point     (IBM standard addr.)
FE987     int 09h keyboard services entry point     (IBM standard addr.)
FEC59     int 13h diskette services entry point     (IBM standard addr.)
FEF57     int 0Eh diskette hardware ISR entry point (IBM standard addr.)
FEFC7     diskette controller parameter table       (IBM standard addr.)
FEFD2     int 17h printer services entry point      (IBM standard addr.)
FF045     int 10h video services 0-Fh entry point   (IBM standard addr.)
FF065     int 10h video services entry point        (IBM standard addr.)
FF0A4     int 1Dh MDA/CGA video parameter table     (IBM standard addr.)
FF841     int 12h memory size service entry point   (IBM standard addr.)
FF84D     int 11h equipment list service entry point(IBM standard addr.)
FF859     int 15h System Services entry point       (IBM standard addr.)
FFA6E     CGA font table                            (IBM standard addr.)
FFE6E     int 1Ah clock services entry point        (IBM standard addr.)
FFEA5     int 08h system timer ISR entry point      (IBM standard addr.)
FFEF3     initial int vector offsets loaded by POST (IBM standard addr.)
FFF53     IRET opcode for dummy interrupt handler   (IBM standard addr.)
FFF54     int 05h print screen service entry point  (IBM standard addr.)
FFFF0     80x86 power-up entry point                (part of the CPU)
FFFFE     system ID byte:                           (IBM standard addr.)

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ ROM BIOS    Ú model byte                                            ³
³ copyright   ³    Ú submodel byte          machine                   ³
³   date      ³    ³    Ú revision                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³          ³ 00 ³ 00 ³ 00 ³ AT&T 6300, Olivetti PC                    ³
³          ³ 2D ³ -- ³ -- ³ Compaq PC        (4.77mHz original)       ³
³          ³ 30 ³ -- ³ -- ³ Sperry PC        (built by Mitsubishi)    ³
³          ³ 86 ³ -- ³ -- ³ HP-110 portable PC                        ³
³          ³ 9A ³ -- ³ -- ³ Compaq Plus      (XT compatible)          ³
³ 03/30/87 ³ F8 ³ 00 ³ 00 ³ PS/2 Model 80  8580-041 (16mhz)  (-071?)  ³
³ 08/28/87 ³ F8 ³ ?? ³ ?? ³ PS/2 Model 80-071  16mHz  8580            ³
³ 10/07/87 ³ F8 ³ 01 ³ 00 ³ PS/2 Model 80  8580-111/311 (20mhz)       ³
³ 09/17/87 ³ F8 ³ 01 ³ 01 ³ PS/2 Model 80-111  20mHz  8580            ³
³ 11/21/89 ³    ³    ³    ³ PS/2 Model 80-Axx                         ³
³ 04/11/88 ³ F8 ³ 04 ³ 02 ³ PS/2 Model 70-121 8570-121, 8570-E61      ³
³ 04/11/88 ³ F8 ³ 09 ³ 02 ³ PS/2 Model 70 desktop                     ³
³ 01/18/89 ³ F8 ³ 0B ³ 00 ³ PS/2 Model 70 Portable                    ³
³ 01/18/89 ³    ³    ³    ³ PS/2 Model 73                             ³
³ 01/29/88 ³    ³    ³    ³ PS/2 Model 70                             ³
³ 03/17/89 ³    ³    ³    ³ PS/2 Model 70-061                         ³
³ 03/17/89 ³    ³    ³    ³ PS/2 Model 70-121                         ³
³ 02/20/89 ³    ³    ³    ³ PS/2 Model 70-A21                         ³
³ 02/20/89 ³    ³    ³    ³ PS/2 Model 70-A61                         ³
³ 10/02/89 ³    ³    ³    ³ PS/2 Model 70-B21                         ³
³ 12/01/89 ³    ³    ³    ³ PS/2 Model 70-A61 --> B61                 ³
³ 09/09/88 ³ F8 ³ 0B ³ 01 ³ PS/2 8573-???                             ³
³       ?  ³ F8 ³ 0C ³ 00 ³ PS/2 8555-031/061                         ³
³ 02/20/89 ³ F8 ³ 0D ³  ? ³ PS/2 Model 70-A21                         ³
³ 06/22/88 ³ F8 ³ 0D ³ 00 ³ PS/2 Model 70 8570-A21                    ³
³ 09/13/85 ³ F9 ³ 00 ³ 00 ³ PC Convertible laptop                     ³
³ 09/02/86 ³ FA ³ 00 ³ 00 ³ PS/2 Model 30 8530-021                    ³
³ 12/12/86 ³ FA ³ 00 ³ 00 ³ PS/2 Model 30 8530-021                    ³
³ 02/05/87 ³    ³    ³    ³ PS/2 Model 30 8530-021                    ³
³ 08/25/88 ³    ³    ³    ³ PS/2 Model 30 8530-E21                    ³
³ 05/16/88 ³    ³    ³    ³ PS/2 Model 30 8530-E21                    ³
³ 06/28/89 ³    ³    ³    ³ PS/2 Model 30 8530-Exx                    ³
³ 06/26/87 ³ FA ³ 01 ³ 00 ³ PS/2 Model 25 8525                        ³
³ 01/10/86 ³ FB ³ 00 ³ 00 ³ XT-2 (early)                              ³
³ 01/10/86 ³ FB ³ 00 ³ 01 ³ XT Model 089   (101-key keyboard          ³
³ 05/09/86 ³ FB ³ 01 ³ 02 ³ XT-2 (revised) (640k m'bd, 101 key k'bd   ³
³ 01/10/84 ³ FC ³ -- ³ -- ³ AT Model 099 (original 6mHz)              ³
³ 06/10/85 ³ FC ³ 00 ³ 01 ³ AT Model 5170-239 6mHz (6.6 max governor) ³
³ 11/15/85 ³ FC ³ 01 ³ 00 ³ AT Model 5170-339 8mHz (8.6 max governor) ³
³          ³ FC ³ 01 ³ 00 ³ Compaq 386/16                             ³
³          ³ FC ³ 01 ³ 03 ³ some Phoenix 386 BIOS                     ³
³          ³ FC ³ 01 ³ 81 ³ some Phoenix 386 BIOS                     ³
³ 04/21/86 ³ FC ³ 02 ³ 00 ³ XT/286                                    ³
³ 02/13/87 ³ FC ³ 04 ³ 00 ³ PS/2 Model 50 8550-021                    ³
³ 12/22/86 ³ FC ³ 05 ³ 00 ³ PS/2 Model 60 8560                        ³
³ 02/13/87 ³ FC ³ 05 ³ 00 ³ PS/2 Model 60 8560                        ³
³          ³ FC ³ 00 ³    ³ 7531/2 Industrial AT                      ³
³          ³ FC ³ 06 ³    ³ 7552 "Gearbox"                            ³
³ 04/18/88 ³ FC ³ 04 ³ 03 ³ PS/2 50Z  8550-031/061                    ³
³ 01/24/90 ³ FC ³ 01 ³ 00 ³ Compaq Deskpro 80386/25e                  ³
³ 10/02/89 ³ FC ³ 02 ³ 00 ³ Compaq Deskpro 386s, 386SX, 16mHz         ³
³ 08/25/88 ³ FC ³ 09 ³ 00 ³ 8530-Exx (286)                            ³
³ 06/01/83 ³ FD ³ -- ³ -- ³ PCjr                                      ³
³ 11/08/82 ³ FE ³ -- ³ -- ³ XT, Portable PC, XT/370, 3270PC           ³
³ 04/24/81 ³ FF ³ -- ³ -- ³ PC-0   (original)(16k motherboard)        ³
³ 10/19/81 ³ FF ³ -- ³ -- ³ PC-1             (64k motherboard)        ³
³ 08/16/82 ³ FF ³ -- ³ -- ³ PC, XT, XT/370   (256k motherboard)       ³
³ 10/27/82 ³ FF ³ -- ³ -- ³ PC with HD/EGA BIOS upgrade chipset       ³
³ 02/08/90 ³    ³    ³    ³ PS/2 Model 65                             ³
³ 11/02/88 ³    ³    ³    ³ PS/2 Model 55SX                           ³
³ 02/07/89 ³    ³    ³    ³ PS/2 Model 73-031                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


The IBM PC System Interrupts (Overview) ........................ 2**7

  The interrupt table is stored in the very lowest location in memory, 
starting at 0000:0000h.  The locations are offset from segment 0, i.e. 
location 0000h has the address for int 0, etc.  The table is 1024 
bytes in length and contains 256 four byte vectors from 00h to 0FFh.  
Each address' location in memory can be found by multiplying the 
interrupt number by 4.  For example, int 7 could be found by (7x4=28) 
or 1Bh (0000:001Bh). 

  These interrupt vectors normally point to ROM tables or are taken 
over by DOS when an application is run.  Some applications revector 
these interrupts to their own code to change the way the system 
responds to the user.  DOS provides int 21h function 25h to change 
interrupts from a high level; altering the interrupt vector table 
directly is not recommended, nor would it really get you anywhere. 


Quick Chart of Interrupts 00h-0FFh ............................. 2**8

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³  Interrupt Address  ³                                                ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÙ                        Function                ³
³ Number³ (Hex) ³ Type                                                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   0   ³ 00-03 ³ CPU ³  Divide by Zero                                ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1   ³ 04-07 ³ CPU ³  Single Step                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   2   ³ 08-0B ³ CPU ³  Nonmaskable                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   3   ³ 0C-0F ³ CPU ³  Breakpoint                                    ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   4   ³ 10-13 ³ CPU ³  Overflow                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   5   ³ 14-17 ³ BIOS³  Print Screen                                  ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   6   ³ 18-1B ³ hdw ³  Reserved                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   7   ³ 1C-1F ³ hdw ³  Reserved                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   8   ³ 20-23 ³ hdw ³  Time of Day                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   9   ³ 24-27 ³ hdw ³  Keyboard                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   A   ³ 28-2B ³ hdw ³  Reserved                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   B   ³ 2C-2F ³ hdw ³  Communications (8259)                         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   C   ³ 30-33 ³ hdw ³  Communications                                ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   D   ³ 34-37 ³ hdw ³  Disk                                          ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   E   ³ 38-3B ³ hdw ³  Diskette                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   F   ³ 3C-3F ³ hdw ³  Printer                                       ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   10  ³ 40-43 ³ BIOS³  Video                                         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   11  ³ 44-47 ³ BIOS³  Equipment Check                               ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   12  ³ 48-4B ³ BIOS³  Memory                                        ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   13  ³ 4C-4F ³ BIOS³  Diskette/Disk                                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   14  ³ 50-53 ³ BIOS³  Serial Communications                         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   15  ³ 54-57 ³ BIOS³  Cassette, System Services                     ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   16  ³ 58-5B ³ BIOS³  Keyboard                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   17  ³ 5C-5F ³ BIOS³  Parallel Printer                              ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   18  ³ 60-63 ³ BIOS³  ROM BASIC Loader                              ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   19  ³ 64-67 ³ BIOS³  Bootstrap Loader                              ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1A  ³ 68-6B ³ BIOS³  Time of Day                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1B  ³ 6C-6F ³ BIOS³  Keyboard Break                                ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1C  ³ 70-73 ³ BIOS³  Timer Tick                                    ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1D  ³ 74-77 ³ BIOS³  Video Initialization                          ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1E  ³ 78-7B ³ BIOS³  Diskette Parameters                           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1F  ³ 7C-7F ³ BIOS³  Video Graphics Characters, second set         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   20  ³ 80-83 ³ DOS ³  General Program Termination                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   21  ³ 84-87 ³ DOS ³  DOS Services Function Request                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   22  ³ 88-8B ³ DOS ³  Called Program Termination Address            ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   23  ³ 8C-8F ³ DOS ³  Control Break Termination Address             ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   24  ³ 90-93 ³ DOS ³  Critical Error Handler                        ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   25  ³ 94-97 ³ DOS ³  Absolute Disk Read                            ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   26  ³ 98-9B ³ DOS ³  Absolute Disk Write                           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   27  ³ 9C-9F ³ DOS ³  Terminate and Stay Resident                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 28-3F ³ A0-FF ³ DOS ³  Reserved for DOS                              ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³ *29h   Fast Screen Write                       ³
                      ³ *2Ah   Microsoft Networks - Session Layer      ³
                      ³        Interrupt                               ³
                      ³  2Fh   Multiplex Interrupt                     ³
                      ³ *30h   Far jump instruction for CP/M-style     ³
                      ³        calls                                   ³
                      ³  33h   Used by Microsoft Mouse Driver          ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 40-43 ³100-115³ BIOS³  Reserved for BIOS                             ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³  40h   Hard Disk BIOS                          ³
                      ³  41h   Hard Disk Parameters  (except PC1)      ³
                      ³  42h   Pointer to screen BIOS entry  (EGA, VGA,³
                      ³        PS/2)                                   ³
                      ³  43h   Pointer to EGA initialization parameter ³
                      ³        table                                   ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   44  ³116-119³ BIOS³  First 128 Graphics Characters                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 45-47 ³120-131³ BIOS³  Reserved for BIOS                             ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³  45h   Reserved by IBM  (not initialized)      ³
                      ³  46h   Pointer to hard disk 2 params (AT, PS/2)³
                      ³  47h   Reserved by IBM  (not initialized)      ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   48  ³132-135³ BIOS³  PCjr Cordless Keyboard Translation            ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   49  ³136-139³ BIOS³  PCjr Non-Keyboard Scancode Translation Table  ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³  4Ah   Real-Time Clock Alarm (Convertible,     ³
                      ³        PS/2)                                   ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 50-5F ³140-17F³ BIOS³  Reserved for BIOS                             ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³  5Ah   Cluster Adapter BIOS entry address      ³
                      ³ *5Bh   IBM  (cluster adapter?)                 ³
                      ³  5Ch   NETBIOS interface entry port            ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 60-67 ³180-19F³  User Program Interrupts (availible for general use) ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³  60h   10-Net Network                          ³
                      ³  67h   Used by LIM & AQA EMS, EEMS             ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 68-7F ³1A0-1FF³  Reserved by IBM                                     ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³  6Ch   System Resume Vector (Convertible)      ³
                      ³  6Fh   some Novell and 10-Net API functions    ³
                      ³  70h   IRQ 8, Real Time Clock Interrupt (AT,   ³
                      ³               PS/2)                            ³
                      ³  71h   IRQ 9, LAN Adapter 1                    ³
                      ³  72h   IRQ 10  (AT, XT/286, PS/2)  Reserved    ³
                      ³  73h   IRQ 11  (AT, XT/286, PS/2)  Reserved    ³
                      ³  74h   IRQ 12  Mouse Interrupt (PS/2)          ³
                      ³  75h   IRQ 13, Coprocessor Error               ³
                      ³  76h   IRQ 14, Hard Disk Controller (AT, PS/2) ³
                      ³  77h   IRQ 15 (AT, XT/286, PS/2)  Reserved     ³
                      ³  7Ch   IBM REXX88PC command language           ³
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 80-85 ³200-217³  ROM BASIC                                           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 86-F0 ³218-3C3³  Used by BASIC Interpreter When BASIC is running     ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ F1-FF ³3C4-3FF³  Reserved by IBM                                     ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                       ³ *0F8h  Set Shell Interrupt (OEM)              ³
                       ³ *0F9h  OEM SHELL service codes                ³
                       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



IRQ Usage Chart ................................................ 2**9

  The 8259-1 Programmable Interrupt Controller (PIC) has eight 
interrupt request (IRQ) levels.  Lower numbered IRQs have higher 
priority.  On AT and PS/2 machines, a second 8259 chip is cascaded off 
the IRQ2 channel. Channels marked with an asterisk (*) are normally 
available. 

 (IRQ0)   55ms timer "tick" issued 18.2 times per second.
 (IRQ1)   keyboard
*(IRQ2)   for ATs, IRQ2 is used to support the second interrupt 
          controller.  In this case, int 71h (IRQ 9) is used to
          replace IRQ 2.  Hardware calls to int 71h are redirected
          to this interrupt to maintain compatibility. 
                IRQ 8   Real Time Clock Interrupt (AT, PS/2)
              * IRQ 9   LAN Adapter 1
              * IRQ 10  (AT, XT/286, PS/2)  Reserved
              * IRQ 11  (AT, XT/286, PS/2)  Reserved
              * IRQ 12  used by EISA machines, also PS/2 Mouse
                        Interrupt
                IRQ 13  Coprocessor Error
                IRQ 14  Hard Disk Controller (AT, PS/2)
              * IRQ 15 (AT, XT/286, PS/2)  Reserved
*(IRQ3)   Serial Port 2 (COM2)
*(IRQ4)   Serial Port 1 (COM1) or internal modem in PCjr or
          Convertible
*(IRQ5)   XT hard disk, free on standard AT
 (IRQ6)   floppy controller
 (IRQ7)   LPT1, LPT2

  Two cards generally cannot share the same IRQ without conflict on 
ISA bus machines.  EISA and PS/2 machines can share IRQs, but require 
specially designed cards to do so. 


The IBM-PC System Interrupts (in detail) ....................... 2**10

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  00h Divide by Zero                                        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0000h) (processor error).  Automatically called at end of DIV or
          IDIV operation that results in error.  Normally set by DOS to 
          display an error message and abort the program. 

note 1) On an 8086/8088, the return address points to the following
        instruction.
     2) On an 80286/80386, the return address points to the divide
        instruction.
     3) Trapped by PC-MOS/386 to provide a default handler for divide
        overflow  conditions.  If the application does not have its own
        handler, MOS will terminate the program with an appropriate
        message.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  01h Single Step                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0004h)  Taken after every instruction when CPU Trap Flag indicates
           single-step mode (bit 8 of FLAGS is 1). This is what makes
           the "T" command of DEBUG work for single stepping.  Is not
           generated after MOV to segment register or POP of segment
           register. (unless you have a very early 8088 with the
           microcode bug).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  02h Non-Maskable Interrupt (NMI)                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0008h)  Vector not disabled via CLI.  Generated by NMI signal in
           hardware.  This function is called in the event of a memory
           parity error or may occur in the event of other hardware
           problems or failures depending on the specific
           manufacturer's hardware.  Displays the appropriate error
           message and halts the processor.

           Some AT chip sets apparently use int 02h to signal I/O errors
           as well as parity errors.

           This signal has various uses:

     POST parity error:                  all except PCjr & Convertible
     80x87 coprocessor interrupt:        all except PCjr & Convertible
     Keyboard interrupt:                 PCjr, Convertible
     I/O channel check:                  Convertible, PS/2 50+
     Disk controller power-on request:   Convertible
     System suspend:                     Convertible
     Realtime clock:                     Convertible
     System watchdog timer:              PS/2 50+
     Timeout interrupt:                  PS/2 50+
     DMA timer time-out interrupt:       PS/2 50+
     Infrared keyboard link:             PCjr


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  03h Breakpoint                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:000Ch)  Taken when CPU executes the 1-byte int 3 (0CCh).  Similar to
(internal) the 8080's RST instruction.  Generally used to set
           breakpoints for DEBUG.

note 1)  Also used by Turbo Pascal versions 1,2,3 when {$U+} specified.
     2)  Int 3s are sometimes inserted by the Microsoft Linker in
         response to an unresolved symbol.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  04h Divide overflow                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0010h)  Generated by INTO instruction if OF flag is set.  If the 
(internal) flag is not set, INTO is effectively a NOP.  Used to trap
           any arithmetic errors when program is ready to handle them
           rather than immediately when they occur.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  05h Print Screen                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0014h)  Service dumps the screen to the printer.  Invoked by int 9
           for shifted key 55 (PrtSc).  Automatically called by the
           keyboard scan when PrtSc key is pressed.  Normally executes
           a routine to print the screen, but may call any routine that
           can safely be executed from inside the keyboard handler.
           Status and result bytes are at address 0050:0000.

(internal) BOUND Check Failed (80286+)
           Generated by BOUND instruction when the value to be tested
           is less than the indicated lower bound or greater than the
           indicated upper bound.

entry   AH      05h
return  absolute address 50:0
        00h     print screen has not been called, or upon return
                from a call there were no errors
        01h     print screen is already in progress
        0FFh    error encountered during printing
note 1) Uses BIOS services to read the screen.
     2) Output is directed to LPT1.
     3) Revectored into GRAPHICS.COM if GRAPHICS.COM is loaded.
     4) On the Tandy 1000TX this interrupt can be enabled or disabled
        across the expansion slots via a DIP switch.
     5) With early versions of DOS 5.0, at PrtScr of a graphics
        display gets garbage when GRAPHICS.COM is loaded.  This was
        fixed in one of the first updates.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  06h Reserved by IBM                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0018h)  On the Tandy 1000TX this interrupt can be enabled or
           disabled across the expansion slots via a DIP switch.

           PC-MOS/386 in 386 mode uses this interrupt to signal memory
           allocation errors.  The CS:IP of the offending instruction
           is placed on the stack.

(internal) Undefined Opcode (80286+)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  07h Reserved by IBM                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:00C0h)  On the Tandy 1000TX this interrupt can be enabled or
           disabled across the expansion slots via a DIP switch.

(internal) No Math Unit Available (80286+)

note    The 80286 and later can be programmed to generate an int 7
        whenever an ESC instruction is encountered.  This could be used
        to emulate an 80x87 series coprocessor in software and be
        transparent to the application software.  It could also be used
        to make a non-Intel floating point processor emulate an 80x87.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  08h Timer                                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0020h)  55ms timer "tick" issued 18.2 times per second.
 (IRQ0)    8259-1 Interrupt Controller
           Updates the system time at [0040:006C] (low word) and
           [0040:006E] (high word) and issues an int 1Ch (timer). (Int
           1Ch points to an IRET instruction unless changed by a
           resident program).  The timer interrupt is given the highest
           maskable interrupt priority upon power up.

(internal) Double Fault (80286+ protected mode)  Called when multiple
           exceptions occur on one instruction, or an exception occurs
           in an exception handler.  If an exception occurs in the
           double fault handler, the CPU goes into SHUTDOWN mode (which
           circuitry in the PC/AT converts to a reset).

entry   AH      08h
return  absolute addresses:
        40:6C   number of interrupts since power on (4 bytes)
        40:70   number of days since power on       (1 byte)
        40:67   day counter on all products after AT
        40:40   motor control count - gets decremented and shuts off
                diskette motor if zero
note 1) IBM PC LAN 1.2 and PC/MOS-386 require this count be 18.2Hz
        and will report errors if the timer rate is reprogrammed.
     2) Some "turbo" XT clones were shipped with slower-than-18.2Hz
        timers so they would appear faster to benchmark software.
        Caveat emptor.
     3) Trapped by PC-MOS/386 to ensure task switching is performed.
        This interrupt should never be disabled when running PC-MOS.
     4) Trapped by Quarterdeck's DESQview.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  09h Keyboard                                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0024h)  Taken whenever a key is pressed or released. This is
 (IRQ1)    normally a scan code, but may also be an ACK or NAK of a
           command on AT-type keyboards.  The hardware provides the key
           pressed in a non-ASCII scan code format read at I/O port
           60h.  The servicer acknowledges receipt of the key by
           toggling bit 7 of port 61h.  (Port 61h should be read first,
           then bit 7 ORed on, output to port 61h, then ANDed off, and
           resent to port 61h).

           The read key is decoded to yield an ASCII character, special
           function key (such as F1) or a control function like Left
           Shift Key.  The converted ASCII character is placed into the
           next available position in the circular keyboard queue.  It
           is put in the position indicated by queue tail when it will
           not cause the loss of earlier entered data.  The queue head
           points to the oldest key pressed in the buffer which has not
           been removed from the queue (the normal process uses int 16h
           to remove keys from the queue and return the key value to the
           int 16h caller).

           The 16 word queue holds up to 16 keys.  If the queue head
           equals the queue tail, the queue is empty.  Valid keys in
           the queue comprise the upper byte scan code and the lower
           byte ASCII character.  If the key pressed has no ASCII
           equivalent (i.e F1 to F12), the lower byte is zero.

           Toggle and shift keys are not placed in the buffer, but
           appear in the two status bytes at absolute addresses
           0040:0017 and 0040:0018.

           Special key combinations will cause other events to occur:

           a) Ctrl-Alt-Del  -  Reboot computer
           b) Print screen  -  Call int 05h to print the current screen
           c) Ctrl-Break    -  Call int 1Bh control-break key
                               processor (DOS)

(internal) Math Unit Protection Fault (80286+ protected mode)

entry   AH      09h
return  at absolute memory addresses:
        40:17   bit
                0       right shift key depressed
                1       left shift key depressed
                2       control key depressed
                3       alt key depressed
                4       ScrollLock state has been toggled
                5       NumLock state has been toggled
                6       CapsLock state has been toggled
                7       insert state is active
        40:18   bit
                0       left control key depressed
                1       left alt key depressed
                2       SysReq key depressed
                3       Pause key has been toggled
                4       ScrollLock key is depressed
                5       NumLock key is depressed
                6       CapsLock key is depressed
                7       Insert key is depressed
        40:96   bit
                0       last code was the E1h hidden code
                1       last code was the E0h hidden code
                2       right control key down
                3       right alt key down
                4       101 key Enhanced keyboard installed
                5       force NumLock if rd ID & kbx
                6       last character was first ID character
                7       doing a read ID (must be bit 0)
        40:97   bit
                0       ScrollLock indicator
                1       NumLock indicator
                2       CapsLock indicator
                3       circus system indicator
                4       ACK received
                5       resend received flag
                6       mode indicator update
                7       keyboard transmit error flag
        40:1E   keyboard buffer (20h bytes)
        40:1C   buffer tail pointer
        40:72   1234h if ctrl-alt-del pressed on keyboard
     AL   scan code
note 1) Int 05h invoked if PrtSc key pressed.
     2) Int 1Bh invoked if Ctrl-Break key sequence pressed.
     3) Int 15h, AH=85h invoked on AT and after if SysReq key is pressed.
     4) Int 15h, AH=4Fh invoked on machines after AT.
     5) Int 16h, BIOS keyboard functions, uses this interrupt.
     6) PC-MOS/386 will issue this interrupt for keystrokes ocurring on
        remote serial terminals to simulate local access.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0Ah  EGA Vertical Retrace                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0028h)  used by EGA vertical retrace
 (IRQ2)    8259-1 Interrupt Controller
note 1) The TOPS and PCnet adapters use this IRQ line by default.
     2) On systems equipped with 2 interrupt controller chips (8259),
        IRQ 2 is used to support the second interrupt controller.  In
        this case, int 71h (IRQ 9) is used to replace IRQ 2.  Hardware
        calls to int 71h are redirected to this interrupt to maintain
        compatibility.
     3) IRQ 2 is used for vertical retrace signal on PS/2s with VGA on
        the motherboard.  Most aftermarket VGA boards to not use this
        interrupt.
     4) Some early Samsung machines routed IRQ2 to the onboard system
        clock and did not continue IRQ2 to the I/O bus.
     5) The Roland LAPC-1 board uses IRQ2.
     6) Elographics touchscreens use optionally use IRQ2.

(internal) Invalid Task State Segment (80286+ protected mode)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0Bh  Communications Controller (serial port) hdw. entry   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:002Ch)  Serial Port 2 (COM2) 8259-1
 (IRQ3)
note 1) IRQ 3 may be used by SDLC (synchronous data-link control) or
        bisynchronous communications cards instead of a serial port.
     2) The TOPS and PCnet adapters use this interrupt request line as
        an alternate.
     3) On PS/2s, COM2 through COM8 share this IRQ.
     4) For most serial boards, COM4 shares this IRQ.
     5) On the Commodore Amiga 2000 with the PC Bridge Board, this
        interrupt is used for communication between the Amiga system
        board and the Bridge Board.  This was probably the lowest IRQ
        level they felt safe using, but limits the A2000's use of
        network cards, etc.
     6) This interrupt is used by part of the stack-switching code
        added to DOS 3.2 for use with Local Area Network adapters.
     7) The PS/2 puts COM3 through COM8 at port addresses above 3FFh
        (not properly decoded by older PCs) and has all of them sharing
        IRQ3.
     8) Toshiba 1600 laptop normally connects IRQ3 only to internal
        modem slot.  You must run FORCE3.COM from Toshiba to enable
        IRQ3 for the expansion slot.
     9) The BIOS Data Area was not set up to point to COM2 on POST in
        some early IBM PS/2 Model 50Z machines.
    10) Marstek 105 scanner - optional IRQ.
    11) Elographics touchscreens use optionally use IRQ 3.
    12) Default for Stargate Plus 8 multiport serial board.
    13) Tecmar/Wangtek PC-36 tape controller board - default IRQ.
    14) Older versions of Microsoft BASICA pretty well booger the IRQ 
        and port addresses for the serial ports when they exit.

(internal) Not Present (80286+ protected mode)
           Generated when loading a segment register if the segment
           descriptor indicates that the segment is not currently in
           memory.  May be used to implement virtual memory.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0Ch  COM1 Serial Port                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0030h)  Serial Port 1 (COM1) or internal modem in PCjr or Convertible
 (IRQ4)    8259-1
note 1) IRQ 4 may be used by SDLC (synchronous data-link control) or
        bisynchronous communications cards instead of a serial port.
     2) On some PCs, this interrupt is shared by COM3.
     3) Some Tandy computers use IRQ4 instead of IRQ5 for the hard disk
        interrupt.
     4) Best performance of mice sometimes happens when they are
        configured for IRQ4 instead of IRQ3, since some mouse drivers
        may lock system interrupts for long periods.
     5) Elographics touchscreens use optionally use IRQ 4.
     6) Older versions of Microsoft BASICA pretty well booger the IRQ 
        and port addresses for the serial ports when they exit.

(internal) Stack Fault (80286+ protected mode)
           Generated on stack overflow/underflow.  Note that the 80286
           will shut down in real mode if SP=1 before a push.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0Dh  Hard Disk                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0034h)  Miscellaneous uses
 (IRQ5)    8259-1
note 1) Various Tandy 1000 models may use this line for the 60Hhz RAM
        refresh or as "optional bus interrupt."
     2) Used by hard disk on IBM XT and most compatibles.
     3) LPT2 on AT, XT/286, and PS/2
     4) Dummy CRT vertical retrace on PCjr
     5) Marstek 105 scanner - default IRQ.
     6) Elographics touchscreens use IRQ 5 (2,3,4 & 7 also selectable)

(internal) General Protection Violation (80286+)
           Called in real mode when an instruction attempts to access
           a word operand located at offset 0FFFFh or a PUSH MEM or POP
           MEM instruction contains an invalid bit code in the second
           byte, or when an instruction exceeds the maximum length
           allowed (10 bytes for 80286, 15 bytes for 80386)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0Eh  Diskette Interrupt                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0038h)  Generated by floppy controller on completion of an operation
 (IRQ6)    (sets bit 8 of 40:3E)
note    Tecmar PC-36 tape controllers use this setting by default, as
        they are not intended to be used when floppies are to be
        accessed.

(internal) Page Fault (80386+ native mode)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0Fh  Reserved by IBM                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:003Ch)  IRQ7 used by 8259 PPI interrupt (LPT1, LPT2)
 (IRQ7)
note 1) Generated by the LPT1 printer adapter when printer becomes
        ready.  Many printer adapters do not reliably generate this
        interrupt.
     2) This interrupt is normally avoided.  If a bad interrupt occurs,
        it will vector to this spot (when caused by a misprogrammed
        8259 PIC)
     3) According to the Creative Labs Sound Blaster board docs, some
        Tandy 1000 models use this interrupt internally.
     4) Elographics touchscreens use optionally use IRQ 7.




   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                      C H A P T E R    T H R E E


    R O M    B I O S   A N D   S E R V I C E   I N T E R R U P T S


                            C O N T E N T S


Calling the ROM BIOS ............................................ 3**1
Interrupt 10h  Video Services ................................... 3**2
Interrupt 11h  Equipment Check .................................. 3**3
Interrupt 12h  Memory Size ...................................... 3**4
Interrupt 13h  Disk Functions ................................... 3**5
Interrupt 14h  Initialize and Access Serial Port ................ 3**6
               FOSSIL Drivers ................................... 3**7
Interrupt 15h  Cassette I/O ..................................... 3**8
Interrupt 16h  Keyboard I/O ..................................... 3**9
Interrupt 17h  Printer .......................................... 3**10
Interrupt 18h  ROM BASIC ........................................ 3**11
Interrupt 19h  Bootstrap Loader ................................. 3**12
Interrupt 1Ah  Time of Day ...................................... 3**13
Interrupt 1Bh  Control-Break .................................... 3**14
Interrupt 1Ch  Timer Tick ....................................... 3**15
Interrupt 1Dh  Vector of Video Initialization Parameters ........ 3**16
Interrupt 1Eh  Vector of Diskette Controller Parameters ......... 3**17
Interrupt 1Fh  Ptr to Graphics Char Extensions (Graphics Set 2) . 3**18



  The ROM BIOS is the lowest level of software access.  It contains 
the following routines: 

   (all)
        power-on self-test (POST)
        boostrap loader
        clock
        floppy disk I/O
        video I/O
        keyboard
        serial ports
        parallel ports
        print screen
        equipment check
        report memory size


    (AT)
        hard disk I/O
        report memory size (extended memory)
        extended memory block moves
        enhanced video and keyboard I/O
        high resolution timer
        alarm

  Machines such as the PC Convertible, PCjr, and non-IBM machines add 
additional functions. 


Calling the ROM BIOS ............................................ 3**1

  The BIOS services are invoked by placing the number of the desired 
function in register AH, subfunction in AL, setting the other 
registers to any specific requirements of the function, and invoking 
any of ints 10h through int 1Fh. 

  The original IBM PC Technical Reference gave the absolute addresses 
of the ROM routines.  Some early software jumped directly to these 
addresses, with mixed results on non-IBM BIOSes.  This practice was 
common on machines predating the PC, but there is no practical use for 
it now.  The OS/2 1.x Compatibility Box also does not support jumping 
directly into the ROM. 

  When the interrupt is called, all register and flag values are 
pushed into the stack.  The interrupt address contains a pointer into 
an absolute address in the ROM BIOS chip address space.  This location 
may be further vectored into the IBMBIO.COM (or equivalent) file or 
user file. 

  At power-up, many BIOSes point unused interrupt vectors to zero.  
Others point to an interrupt handler routine, usually just an IRET 
instruction.  Still others don't even make an attempt to initialize 
unused vectors.  A common programming mistake is to expect 
uninitialized vectors will be zero. 

  The address vector points to a particular BIOS command handler.  The 
handler pops the register values, compares them to its list of 
functions, and executes the function if valid.  When the function is 
complete, it may pass values back to the command handler.  The handler 
will push the values into the stack and then return control to the 
calling program. 

  Most functions will return an error code; some return more 
information.  Details are contained in the listings for the individual 
functions. 

  Register settings listed are the ones used by the BIOS.  Some 
functions will return with garbage values in unused registers.  Do not 
test for values in unspecified registers; your program may exhibit odd 
behavior. 


  Three sets of BIOS routines are available: PC BIOS, AT BIOS (also 
called CBIOS or "Old compatibility BIOS", and the PS/2 ABIOS "Advanced 
BIOS". 

  The Advanced BIOS is contained in PS/2 ROMs.  It is primarily 
intended for OS use rather than application use.  OS/2 can take 
advantage of ABIOS routines to reduce RAM use on PS/2 systems.  The 
ABIOS can be replaced by disk and RAM based ABIOS code if desired.  
There is a new BIOS Data Area defined in high memory that occupies one 
K of RAM.  In OS/2 systems, parts of the ABIOS are replaced by OS/2 
drivers. 

  While the CBIOS must be addressed via pointers, the routines in the 
ABIOS are fixed in absolute locations so they can be referenced 
directly by OS/2. 

  The ABIOS can run in protected mode, and is fully reentrant.  It 
supports three types of function requests - single staged, discrete 
multistaged, or continuous multistaged.  A single-staged request does 
its job immediately and returns control to the caller.  A discrete 
multistaged request may happen in two or more stages with pauses 
between the stages.  The caller may regain control during the pauses.  
A continuous multistaged request starts a staged operation that never 
ends. (sometimes called a daemon). 

  Unlike the CBIOS which is called with software interrupts, ABIOS is 
accessed with FAR calls.  ABIOS calls are completely reentrant in both 
real and protected modes.  To call an ABIOS function, the calling 
program must pass pointers to two data structures - a request block 
and a common data area.  The request block specifies the desired 
function number and the common data area is a table that contains 
pointers to all the ABIOS' other tables and data areas.  The common 
data area's internal structure contains the function transfer tables 
which have the addresses of the BIOS routines. 

ABIOS stack frame and calling conventions:
       bytes        stack contents
        2       common data area pointer (segment/selector only)
                required
        4       request block pointer - required
        4       function transfer table pointer - furnished by ABIOS
                or caller
        4       device block pointer - furnished by ABIOS or caller
        4       return address

  In ABIOS Transfer Convention, only the first two items are required. 
ABIOS assigns the second two.  In Operating System Transfer 
Convention, the caller provides the second two.  Since the parameters 
are not removed from the stack on return to the caller, the operating 
system may save the function transfer table and device addresses after 
they have been furnished by the ABIOS by a call. 

  ABIOS does no interrupt arbitration.  It assumes all interrupts are 
handled by the caller or the OS and it is called only for service.  If 
more than one device is sharing a hardware interrupt, the OS must 
determine which interrupt is valid for the ABIOS. 

  OS/2 may use the ABIOS if found, but otherwise duplicates the BIOS 
calls for the DOS Compatibility Box by vectoring BIOS calls into its 
own device drivers.  This makes it rather difficult for DOS drivers 
for mass storage, high resolution video boards, multitasking APIs 
using int 15h, etc.  If your software needs to manipulate hardware 
directly you might want to check if your code is running under OS/2.  
The simplest method is to check for DOS version 10 or higher. 


note    Some references list an "XT/2" machine, which was reputedly
        an 8mHz 8088 with 640k and a clock on the motherboard.  IBM
        doesn't list such a machine, and I have a late '86 XT, one of
        the last made.  It is pretty much like the older ones.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 10h  Video Services                                  3**2  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0040h)       The BIOS Video Services may be found in Chapter 16.

(internal) Coprocessor Error (80286+)
        Generated by the CPU when the -ERROR pin is asserted by the 
        coprocessor (usually 80x87, but may be any multimaster CPU or
        alternate NDP such as Weitek, etc.).  ATs and clones usually
        wire the coprocessor to use IRQ13, but not all get it right. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 11h  Equipment Check                                 3**3  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0044h)       Reads the BIOS Data Area and returns two bytes of setup
                information.
entry   no parameters are required
return  AX      Equipment listing word. Bits are:
                0       number of floppy drives
                        0       no drives
                        1       bootable (IPL) diskette drive installed
                1       math chip
                        0       no math coprocessor (80x87) present
                        1       math coprocessor (80x87) present
         (PS/2) 2       0       mouse not installed
                        1       mouse installed
          (PC)  2,3     system board RAM
                        0,0     16k    (PC-0, PC-1)
                        0,1     32k
                        1,0     48k
                        1,1     64k    (PC-2, XT)
                        note 1) not commonly used. Set both bits to 1
                             2) both bits always 1 in AT
                4,5     initial video mode
                        0,0     no video installed
                                (use with dumb terminal)
                        0,1     40x25 color      (CGA)
                        1,0     80x25 color
                                (CGA, EGA, PGA, MCGA, VGA)
                        1,1     80x25 monochrome (MDA or Hercules,
                                most super-hires mono systems)
                6,7     number of diskette drives (only if bit 0 is 1)
                        0,0     1 drives
                        0,1     2 drives
                        1,0     3 drives
                        1,1     4 drives
                8       0       DMA present
                        1       no DMA (PCjr, some Tandy 1000s, 1400LT)
                9,A,B   number of RS232 serial ports (0-3)
                        0,0,0   none
                        0,0,1   1
                        0,1,0   2
                        0,1,1   3
                        1,0,0   4
                C       0       no game I/O attached
                        1       game I/O attached (default for PCjr)
                D       serial accessory installation
                        0       no serial accessories installed
                        1       Convertible - internal modem installed
                                or PCjr - serial printer attached
                E,F     number of parallel printers
                        0,0     none
                        0,1     one   (LPT1, PRN)
                        1,0     two   (LPT2)
                        1,1     three (LPT3)
                        note    Models before PS/2 would allow a fourth
                                parallel printer.  Remapping of the
                                BIOS in the PS/2s does not allow the
                                use of LPT4.
        (386 extended AX)
                23d     0       Weitek ABACUS - virtual '86 EMS page
                                tables not correctly initialized
                        1       Weitek ABACUS - virtual '86 EMS page
                                tables OK

                24d     0       Weitek ABACUS NDP not present
                        1       Weitek ABACUS NDP present

note    Not all BIOSes properly return the presence of a game port.
        In my experience, most BIOSes require a joystick to actually
        be present even if the port is otherwise enabled.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 12h  Memory Size                                     3**4  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0048h)       get amount of system memory
entry   no parameters required
return  AX      number of contiguous 1K RAM blocks available for DOS
note 1) This is the same value stored in absolute address 04:13h.
     2) For some early PC models, the amount of memory returned by this
        call is determined by the settings of the DIP switches on the
        motherboard and may not reflect all the memory that is
        physically present.
     3) For the PC/AT, the value returned is the amount of functional
        memory found during the power-on self-test, regardless of the
        memory size configuration information stored in CMOS RAM.
     4) The value returned does not reflect any extended memory (above
        the 1 Mb boundary) that may be present on machines using 80286
        or later microprocessors.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 13h  Disk Functions                                  3**5  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0049h)       The service calls for BIOS disk functions are located
                in Chapter 8.




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 14h  Initialize and Access Serial Port For Int 14    3**6  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Note 1) Some IBM PS/2 Model 50Z machines were delivered with serial
        ports that did not meet specification.  Some cheap clone serial
        ports may also be troublesome.
     2) The standard IBM serial routines are unbuffered and not
        interrupt driven.  They are fairly useless for anything other
        than serial printers.  Most application software either
        programs the UARTs directly or use a driver with a high-level
        interface such as a FOSSIL.
     3) PC-MOS/386' $SERIAL.SYS driver is buffered, device-independent,
        and interrupt-driven.  It supports COM1 through COM24.

(0:0050h)       the following status is defined:

        serial status byte:
        bits    0 delta clear to send
                1 delta data set ready
                2 trailing edge ring detector
                3 delta receive line signal detect
                4 clear to send
                5 data set ready
                6 ring indicator
                7 receive line signal detect

        line status byte:
        bits    0 data ready
                1 overrun error
                2 parity error
                3 framing error
                4 break detect
                5 transmit holding register empty
                6 transmit shift register empty
                7 time out

   note: if bit 7 set then other bits are invalid

        Though present on the IBM PS/2s, COM3 and COM4 are not widely
        standardized across the industry. The most common definitions
        are:

        port    addr.   IRQ     interrupt

        COM1    3F8     IRQ4    int 0Ch
        COM2    2F8     IRQ3    int 0Bh
        COM3    3E8     IRQ4    int 0Ch
        COM4    2E8     IRQ3    int 0Bh

        As you can see, COM1/COM3 and COM2/COM4 are siamesed.  Since
        the ISA bus does not support shared interrupts, simultaneous
        access of two of a pair may cause conflict.  For example, a
        mouse and a modem would not coexist well on paired ports.


 All routines have AH=function number and DX=RS232 card number (0 
based). AL=character to send or received character on exit, unless 
otherwise noted. 

entry   AH      00h     Initialize and Access Serial Port
                        bit pattern: BBBPPSLL
                        BBB = baud rate:   110, 150, 300, 600, 1200,
                                           2400, 4800, 9600
                        PP  = parity:      01 = odd, 11 = even
                        S   = stop bits:   0 = 1, 1 = 2
                        LL  = word length: 10 = 7-bits, 11 = 8-bits
        AL      parms for initialization:
                bit pattern:
                0       word length
                1       word length
                2       stop bits
                3       parity
                4       parity
                5       baud rate
                6       baud rate
                7       baud rate
                word length     10      7 bits
                                11      8 bits
                stop bits       0       1 stop bit
                                1       2 stop bits
                parity          00      none
                                01      odd
                                11      even
                baud rate       000     110 baud
                                001     150 baud
                                010     300 baud
                                011     600 baud
                                100     1200 baud
                                101     2400 baud
                                110     4800 baud
                                111     9600 baud  (4800 on PCjr)
        DX      port number (0=COM1, 1=COM2, etc.)
return  AH      line status
        AL      modem status
note    To initialize the serial port to more than 9600 baud on PS/2
        machines, see functions 04h and 05h.


Function 01h    Send Character in AL to Comm Port
entry   AH      01h
        AL      character
        DX      port number (0 - 3)
return  AH      RS232 status code
                bit     0       data ready
                        1       overrun error
                        2       parity error
                        3       framing error
                        4       break detected
                        5       transmission buffer register empty
                        6       transmission shift register empty
                        7       timeout
        AL      modem status
                bit
                        0       delta clear-to-send
                        1       delta data-set-ready
                        2       trailing edge ring detected
                        3       change, receive line signal detected
                        4       clear-to-send
                        5       data-set-ready
                        6       ring received
                        7       receive line signal detected


Function 02h    Wait For A Character From Comm Port DX
entry   AH      02h
        DX      port number (0-3)
return  AL      character received
        AH      error code (see above)(00h for no error)


Function 03h    Fetch the Status of Comm Port DX (0 or 1)
entry   AH      03h
        DX      port (0-3)
return  AH      set bits (01h) indicate comm-line status
                bit     7       timeout
                bit     6       empty transmit shift register
                bit     5       empty transmit holding register
                bit     4       break detected ("long-space")
                bit     3       framing error
                bit     2       parity error
                bit     1       overrun error
                bit     0       data ready
        AL      set bits indicate modem status
                bit     7       received line signal detect
                bit     6       ring indicator
                bit     5       data set ready
                bit     4       clear to send
                bit     3       delta receive line signal detect
                bit     2       trailing edge ring detector
                bit     1       delta data set ready
                bit     0       delta clear to send


Function 04h    Extended Initialize
                (Convertible, PS/2)
entry   AH      04h
        AL      break status
                01h     if break
                00h     if no break
        BH      parity
                00h     no parity
                01h     odd parity
                02h     even parity
                03h     stick parity odd
                04h     stick parity even
        BL      number of stop bits
                00h     one stop bit
                01h     2 stop bits (1« if 5 bit word length)
        CH      word length
                00h     5 bits
                01h     6 bits
                02h     7 bits
                03h     8 bits
        CL      baud rate
                00h     110
                01h     150
                02h     300
                03h     600
                04h     1200
                05h     2400
                06h     4800
                07h     9600
                08h     19200
        DX      comm port (0-3)
return  AH      line control status
        AL      modem status
note    Provides a superset of fn 00h capabilities for PS/2 machines.


Function 05h    Extended Communication Port Control
                (Convertible, PS/2)
entry   AH      05h
        AL      00h     read modem control register
                01h     write modem control register
        BL      modem control register
           bits 0       DTR data terminal ready
                1       RTS request to send
                2       out1
                3       out2
                4       loop
                5,6,7   reserved
        DX      port number (0=COM1, 1=COM2, etc.)
return  AH      port status (see 00h above)
        AL      modem status (see 00h above)
        BL      modem control register (see 01h above)


Function 80-97h PC-MOS/386 Serial Device Interface
        (see PCMOS xhapter) 




FOSSIL Drivers .................................................. 3**7

Interrupt  14h  FOSSIL (Fido/Opus/Seadog Standard Interface Level)

                A FOSSIL is a device driver for handling the IBM PC
                serial communications ports in a standard fashion from
                an application (communications) program.  A FOSSIL
                chains into the int 14h BIOS communications vector and
                replaces many functions with enhanced routines which
                may be easily accessed by an application.

                For all functions, all registers not specifically 
                containing a function return value must be preserved
                across the call.


entry   AH      00h     FOSSIL: Set Baud Rate And Parameters
        AL      byte
                bits 7,6,5 baudrate
                000     19200 baud
                001     38400 baud
                010     300 baud
                011     600 baud
                100     1200 baud
                101     2400 baud
                110     4800 baud
                111     9600 baud
                bits 4,3 parity
                00      none
                01      odd
                10      none
                11      even
                bit 2 stop bits
                0       1 stop bit
                1       2 stop bits
                bit 1 char length
                0       5 bits plus value
                other   optional
        DX      port number (NOP if DX=00FFh)
return  AX      status (see fn 03h)
note    Low-order 5 bits are undefined by FOSSIL 1.0 spec.


entry   AH      01h     FOSSIL: Transmit Character With Wait
        AL      ASCII value of character to be sent
        DX      port number (NOP if DX=00FFh)
return  AX      status bits (see function 03h)
note    Character is queued for transmission.  If there is room in the
        transmitter buffer when this call is made, the character will
        be stored and control returned to caller.  If the buffer is
        full, the driver will wait for room.  Use this function with
        caution when flow control is enabled.


entry   AH      02h     FOSSIL: Receive A Character With Wait
        DX      port number (0-3) (NOP if DX=00FFh)
return  AH      RS-232 status code (see AH=00h above)
        AL      ASCII value of character received from serial port
note    Will timeout if DSR is not asserted, even if function 03h
        returns data ready.


entry   AH      03h     FOSSIL: Request Status
        DX      port number  (NOP if DX=00FFh)
return  AX      status bit mask
                AH      bit 0 set  RDA     input data is available
                                           in buffer
                            1 set  OVRN    input buffer overrun
                            2 N/A
                            3 N/A
                            4 N/A
                            5 set  THRE    room is available in output
                                           buffer
                            6 set  TSRE    output buffer is empty
                            7 N/A
                AL      bit 0 N/A
                            1 N/A
                            2 N/A
                            3 set          this bit is always set
                            4 N/A
                            5 N/A
                            6 N/A
                            7 set  DCD     carrier detect
note    Bit 3 of AL is always returned set to enable programs to use 
        it as a carrier detect bit on hardwired (null modem) links. 


entry   AH      04h     FOSSIL: Initialize FOSSIL Driver
        BX      4F50h                      (optional)
        DX      port number                (DX=00FFh special)
        ES:CX   pointer to ^C flag address (optional)
return  AX      1954h if successful
        BL      maximum function number supported (excluding 7Eh-0BFh)
        BH      revision of FOSSIL supported
note 1) DTR is raised when FOSSIL inits.
     2) Existing baudrate is preserved.
     3) If BX contains 4F50h, the address specified in ES:CX is that 
        of a ^C flag byte in the application program, to be
        incremented when ^C is detected in the keyboard service
        routines.  This is an optional service and only need be
        supported on machines where the keyboard service can't (or
        won't) perform an int 1Bh or int 23h when a control-C is 
        entered. 


entry   AH      05h     FOSSIL: Deinitialize FOSSIL Driver
        DX      port number  (DX=00FFh special)
return  none
note 1) DTR is not affected.
     2) Disengages driver from comm port.  Should be done when
        operations on the port are complete.
     3) If DX=00FFh, the initialization that was performed when
        FOSSIL function 04h with DX=00FFh should be undone.


entry   AH      06h     FOSSIL: Raise/Lower DTR 
        AL      DTR state to be set
                00h     lower DTR
                01h     raise DTR
        DX      comm port (NOP if DX=00FFh)
return  none


entry   AH      07h     FOSSIL: Return Timer Tick Parameters
return  AH      ticks per second on interrupt number shown in AL
        AL      timer tick interrupt number (not vector!)
        DX      milliseconds per tick (approximate)


entry   AH      08h     FOSSIL: Flush Output Buffer
        DX      port number (NOP if DX=00FFh)
return  none
note    Waits until all output is done.


entry   AH      09h     FOSSIL: Purge Output Buffer
        DX      port number (NOP if DX=00FFh)
return  none
note    Returns to caller immediately.


entry   AH      0Ah     FOSSIL: Purge input buffer
        DX      port number (NOP if DX=00FFh)
return  none
note 1) If any flow control restraint has been employed (dropping
        RTS or transmitting XOFF) the port will be "released" by
        doing the reverse, raising RTS or sending XON.
     2) Returns to caller immediately.


entry   AH      0Bh     FOSSIL: Transmit No Wait
        AL      ASCII character value to be sent
        DX      port number (NOP if DX=00FFh)
return  AX      0000h   character not accepted
                0001h   character accepted
note    This is exactly the same as the "regular" transmit call
        except that if there is no space available in the output
        buffer a value of zero is returned in AX, if room is
        available a value 1 (one) is returned.


entry   AH      0Ch     FOSSIL: Nondestructive Read No Wait
        DX      port number (NOP if DX=00FFh)
return  AH      character
                0FFFFh  character not available
note 1) Reads async buffer.
     2) Does not remove keycode from buffer.


entry   AH      0Dh     FOSSIL: Keyboard Read No Wait
return  AX      IBM keyboard scan code or
                0FFFFh if no keyboard character available
note 1) Use IBM-style function key mapping in the high order byte.
     2) Scan codes for non function keys are not specifically
        required but may be included.
     3) Does not remove keycode from buffer.


entry   AH      0Eh     FOSSIL: Keyboard Input With Wait
return  AX      IBM keyboard scan code
note    Returns the next character from the keyboard or waits if
        no character is available.


entry   AH      0Fh     FOSSIL: Toggle Flow Control
        AL      bit mask describing requested flow control
           bits 0       XON/XOFF on transmit (watch for XOFF while
                        sending)
                1       CTS/RTS (CTS on transmit/RTS on receive)
                2       reserved
                3       XON/XOFF on receive (send XOFF when buffer
                        near full)
                4-7     not used, FOSSIL spec calls for setting to 1
        DX      port number (NOP if DX=00FFh)
return  none
note 1) Bit 2 is reserved for DSR/DTR,  but is not currently
        supported in any implementation.
     2) TRANSMIT flow control allows the other end to restrain the
        transmitter when you are overrunning it.  RECEIVE flow control
        tells the FOSSIL to attempt to do just that if it is being
        overwhelmed.
     3) Enabling transmit XON/XOFf will cause the FOSSIL to stop
        transmitting upon receiving an XOFf. The FOSSIL will resume
        transmitting when an XON is received.
     4) Enabling CTS/RTS will cause the FOSSIL to cease transmitting
        when CTS is lowered.  Transmission will resume when CTS is
        raised.  The FOSSIL will drop RTS when the receive buffer
        reaches a predetermined percentage full.  The FOSSIL will
        raise RTS when the receive buffer empties below the
        predetermined percentage full.  The point(s) at which this
        occurs is left to the individual FOSSIL implementor.
     5) Enabling receive Xon/Xoff will cause the FOSSIL to send an XOFF
        when the receive buffer reaches a pre-determined percentage
        full.  An XON will be sent when the receive buffer empties
        below the predetermined percentage full.  The point(s) at which
        this occurs is left to the individual FOSSIL implementor.
     6) Applications using this function should set all bits ON in the
        high nibble of AL as well.  There is a compatible (but not
        identical) FOSSIL driver implementation that uses the high
        nibble as a control mask.  If your application sets the high
        nibble to all ones, it will always work, regardless of the
        method used by any given driver.


entry   AH      10h     Extended Ctrl-C/Ctrl-K Checking
                        And Transmit On/Off
        AL      flags bit mask byte (bit set if activated)
           bits 0       enable/disable Ctrl-C/Ctrl-K checking
                1       disable/enable the transmitter
                2-7     not used
        DX      port number (NOP if DX=00FFh)
return  AX      status byte
                0000h   control-C/K has not been received
                0001h   control-C/K has been received
note    This is used primarily for programs that can't trust XON/XOFF
        at FOSSIL level (such as BBS software).


entry   AH      11h     FOSSIL: Set Current Cursor Location
        DH      row (line) 0-24
        DL      column     0-79
return  none
note 1) This function looks exactly like the int 10h, fn 02h on the
        IBM PC.  The cursor location is passed in DX: row in DH and
        column in DL.  This function treats the screen as a coordinate
        system whose origin (0,0) is the upper left hand corner of the
        screen.
     2) Row and column start at 0.


entry   AH      12h     FOSSIL: Read Current Cursor Location
return  DH      row (line)
        DL      column
note 1) Looks exactly like int 10h/fn 03h in the IBM PC BIOS.  The
        current cursor location (same coordinate system as function
        16h) is passed back in DX.
     2) Row and column start at 0.


entry   AH      13h     FOSSIL: Single Character ANSI Write To Screen
        AL      value of character to display
return  none
note    This call might not be reentrant since ANSI processing may be
        through DOS.


entry   AH      14h     FOSSIL: Toggle Watchdog Processing
        AL      00h     to disable watchdog
                01h     to enable watchdog
        DX      port number (NOP if DX=00FFh)
return  none
note 1) This call will cause the FOSSIL to reboot the system if Carrier
        Detect for the specified port drops while watchdog is turned
        on.
     2) The port need not be active for this function to work.


entry   AH      15h     FOSSIL: Write Character To Screen Using BIOS
        AL      ASCII code of character to display
return  none
note 1) This function is reentrant.
     2) ANSI processing may not be assumed.


entry   AH      16h     FOSSIL: Insert or Delete a Function From The
                        Timer Tick Chain
        AL      00h     to delete a function
                01h     to add a function
        ES:DX   address of function
return  AX      0000h   successful
                0FFFFh  unsuccessful


entry   AH      17h     FOSSIL: Reboot System
        AL      boot type
                00h     cold boot
                01h     warm boot
return  none


entry   AH      18h     FOSSIL: Read Block
        CX      maximum number of characters to transfer
        DX      port number (NOP if DX=00FFh)
        ES:DI   pointer to user buffer
return  AX      number of characters transferred
note 1) This function does not wait for more characters to become
        available if the value in CX exceeds the number of characters
        currently stored.
     2) ES:DI are left unchanged by the call; the count of bytes
        actually transferred will be returned in AX.


entry   AH      19h     FOSSIL: Write Block
        CX      maximum number of characters to transfer
        DX      port number  (NOP if DX=00FFh)
        ES:DI   pointer to user buffer
return  AX      number of characters transfered
note    ES and DI are not modified by this call.


entry   AH      1Ah     FOSSIL: BREAK Signal Begin Or End
        AL      00h     stop sending 'break'
                01h     start sending 'break'
        DX      port number  (NOP if DX=00FFh)
return  none
note 1) Resets all transmit flow control restraints such as an XOFF
        received from remote.
     2) Init (fn 04h) or UnInit (fn 05h) will stop an in-progress
        break.
     3) The application must determine the "length" of the break.


entry   AH      1Bh     FOSSIL: Return Driver Information
        CX      size of user buffer in bytes
        DX      port number  (if DX=00FFh, port data will not be valid)
        ES:DI   pointer to user buffer
return  AX      number of characters transferred
        ES:DI   user buffer structure:
                00h     word    size of structure in bytes
                02h     byte    FOSSIL driver version
                03h     byte    revision level of this specific driver
                04h     dword   FAR pointer to ASCII ID string
                08h     word    size of the input buffer in bytes
                0Ah     word    number of bytes in input buffer
                0Ch     word    size of the output buffer in bytes
                0Eh     word    number of bytes in output buffer
                10h     byte    width of screen in characters
                11h     byte    screen height in characters
                12h     byte    actual baud rate, computer to modem
                                (see mask in function 00h
note 1) The baud rate byte contains the bits that fn 00h would use to
        set the port to that speed.
     2) The fields related to a particular port (buffer size, space
        left in the buffer, baud rate) will be undefined if port=0FFh
        or an invalid port is contained in DX.
     3) Additional information will always be passed after these, so
        that the fields will never change with FOSSIL revision changes.


entry   AH      7Eh     FOSSIL: Install An External Application Function
        AL      code assigned to external application
        ES:DX   pointer to entry point
return  AX      1954h   FOSSIL driver present
            not 1954h   FOSSIL driver not present
        BH      00h     failed
                01h     successful
        BL      code assigned to application (same as input AL)
note 1) Application codes 80h-0BFh are supported.  Codes 80h-83h are
        reserved.
     2) An error code of BH=00h with AX=1954h should mean that another
        external application has already been installed with the code
        specified in AL.
     3) Applications are entered via a FAR call and should make a FAR
        return.


entry   AH      7Fh     FOSSIL: Remove An External Application Function
        AL      code assigned to external application
        ES:DX   pointer to entry point
return  AX      1954h
        BH      00h     failed
                01h     successful
        BL      code assigned to application (same as input AL)



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 15h  Cassette I/O                                    3**8  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0054h)    1) Renamed "System Services" on PS/2 line.
             2) Issuing int 15h on an XT may cause a system crash.
                On AT and after, interrupts are disabled with CLI when
                the interrupt service routine is called, but most ROM
                versions do not restore interrupts with STI.
             3) For the original IBM PC, int 15h returns AH=80h and CF
                set for all calls with AH not 0,1, or 2.
             4) For the PC/XT int 15h returns AH=86h, CF set if called
                at all.  (the PC/XT ROM BIOS does not support int 15h)
             5) For the AT/339, int 15h returns AH=86h, CF set if
                called with an invalid function code.


Function 00h    Turn Cassette Motor On
                (PC, PCjr only)
entry   AH      00h
return  CF      set on error
                AH      error code
                        00h     no errors
                        01h     CRC error
                        02h     bad tape signals
                                no data transitions (PCjr)
                        03h     no data found on tape
                                not used (PCjr)
                        04h     no data
                                no leader (PCjr)
                        80h     invalid command
                        86h     no cassette present
                                not valid in PCjr
note    NOP for systems where cassette not supported.


Function 01h    Turn Cassette Motor Off
                (PC, PCjr only)
entry   AH      01h
return  CF      set on error
        AH      error code (86h)
note    NOP for systems where cassette not supported.


Function 02h    Read Blocks From Cassette
                (PC, PCjr only)
entry   AH      02h
        CX      number of bytes to read
        ES:BX   segment:offset + 1 of last byte read
return  CF      set on error
                AH      error code (01h, 02h, 04h, 80h, 86h)
        DX      count of bytes actually read
        ES:BX   pointer past last byte written
note 1) NOP for systems where cassette not supported.
     2) Cassette operations normally read 256 byte blocks.


Function 03h    Write Data Blocks to Cassette
                (PC, PCjr only)
entry   AH      03h
        CX      count of bytes to write
        ES:BX   pointer to data buffer
return  CF      set on error
                AH      error code (80h, 86h)
        CX      00h
        ES:BX   pointer to last byte written+1
note 1) NOP for systems where cassette not supported.
     2) The last block is padded to 256 bytes with zeroes if needed.
     3) No errors are returned by this service.


Function 0Fh    ESDI Format Unit Periodic Interrupt
                (PS/2 50+)
entry   AH      0Fh
        AL      phase code
                00h     reserved
                01h     surface analysis
                02h     formatting
return  CF      clear   if formatting should continue
                set     if it should terminate
note 1) Called the BIOS on the ESDI Fixed Disk Drive Adapter/A during
        a format or surface analysis operation after each cylinder is
        completed.
     2) This function call can be captured by a program so that it
        will be notified as each cylinder is formatted or analyzed.
        The program can count interrupts for each phase to determine
        the current cylinder number.
     3) The BIOS default handler for this function returns with CF set. 


Function 10h    TopView API Function Calls                (TopView)
                see Chapter 17


Function 20h    PRINT.COM  (DOS 3.1+ internal)
                (AT, XT/286, PS/2 50+)
entry   AH      20h
        AL      subfunction
                00h     disable critical region flag
                01h     set critical region flag
                        ES:BX   pointer to flag byte set while inside
                                DOS calls
                10h     set up SysReq routine
                11h     completion of SysReq routine (software only)


Function 21h    Read Power-On Self Test (POST) Error Log
                (PS/2 50+)
entry   AH      21h
        AL      00h     read POST log
                01h     write POST log
                        BH      device ID
                        BL      device error code
return  CF      set on error
        AH      status
                00h     successful read
                        BX      number of POST error codes stored
                        ES:DI   pointer to error log
                01h     list full
                80h     invalid command
                86h     function unsupported
note    The log is a series of words, the first byte of which
        identifies the error code and the second is the device ID.


Function 40h    Read/Modify Profiles
                (Convertible)
entry   AH      40h
        AL      00h     read system profile in CX,BX
                01h     write system profile from CX, BX
                02h     read internal modem profile in BX
                03h     write internal modem profile from BX
        BX      profile info
return  BX      internal modem profile (from 02h)
        CX,BX   system profile (from 00h)


Function 41h    Wait On External Event
                (Convertible)
entry   AH      41h
        AL      condition type
           bits 0-2     condition to wait for
                        0,0,0   any external event
                        0,0,1   compare and return if equal
                        0,1,0   compare and return if not equal
                        0,1,1   test and return if not zero
                        1,0,0   test and return if zero
                3       reserved
                4       0       user byte
                        1       port address
                5-7     reserved
        BH      condition compare or mask value
                condition codes:
                00h     any external event
                01h     compare and return if equal
                02h     compare and return if not equal
                03h     test and return if not zero
                04h     test and return if zero
        BL      timeout value times 55 milliseconds
                00h     if no time limit
        DX      I/O port address (if AL bit 4=1)
        ES:DI   pointer to user byte (if AL bit 4=0)


Function 42h    Request System Power Off
                (Convertible)
entry   AH      42h
        AL      00h     to use system profile
                01h     to force suspend regardless of profile
return  unknown
note    With early versions of DOS 5.0, the IBM L40SX would not
        Suspend/Resume if DOS=LOW was in CONFIG.SYS.


Function 43h    Read System Status
                (Convertible)
entry   AH      43h
return  AL      status byte
            bit 0       LCD detached
                1       reserved
                2       RS232/parallel powered on
                3       internal modem powered on
                4       power activated by alarm
                5       bad time
                6       external power in use
                7       battery low


Function 44h    Toggle Internal Modem Power
                (Convertible)
entry   AH      44h
        AL      00h      to power off
                01h      to power on
return  unknown


Function 4Fh    OS Hook - Keyboard Intercept
                (except PC, PCjr, and XT)
entry   AH      4Fh
        AL      scan code, CF set
return  AL      scan code
        CF      set     processing desired
                clear   scan code should not be used
note 1) Called by int 9 handler for each keystroke to translate scan
        codes.
     2) An OS or a TSR can capture this function to filter the raw
        keyboard data stream.  The new handler can substitute a new
        scan code, return the same scan code, or return the carry flag
        clear causing the keystroke to be discarded.  The BIOS default
        routine simply returns the scan code unchanged.
     3) A program can call int 15h/fn0C0h to determine whether the host
        machine's BIOS supports keyboard intercept.
     4) Used internally by PC-MOS/386 v4.00+ for keyboard input.
     5) Some BIOSes do not properly support this call.  Int 15h/fn 0C0h
        will tell if the BIOS is supposed to support this call.
     6) Some versions of KEYB.COM provide additional 4Fh support.


Function 70h    EEROM handler
                (Tandy 1000HX)
entry   AH      00h     read from EEROM
                BL      00h
                01h     write to EEROM
                BL      word number to write (0-15)
                DX      word value to write
return  DX      (AH=00h) word value
        CF      set on error (system is not a Tandy 1000 HX)


Function 80h    OS Hook - Device Open
                (AT, XT/286, PS/2)
entry   AH      80h
        BX      device ID
        CX      process ID
return  CF      set on error
        AH      status
                00h     OK
note 1) Acquires ownership of a logical device for a process.
     2) This call, along with fns 81h and 82h, defines a simple
        protocol that can be used to arbitrate usage of devices by
        multiple processes.  A multitasking program manager would be
        expected to capture int 15h and provide the appropriate
        service.
     3) The default BIOS routine for this function simply returns with
        CF clear and AH=00h.


Function 81h    Device Close
                (AT, XT/286, PS/2)
entry   AH      81h
        BX      device ID
        CX      process ID
return  CF      set on error
        AH      status
                00h     OK
note 1) Releases ownership of a logical device for a process.
     2) A multitasking program manager would be expected to capture
        int 15h and provide the appropriate service.
     3) The BIOS default routine for this function simply returns with
        the CF clear and AH=00h.


Function 82h    Program Termination
                (AT, XT/286, PS/2)
        AH      82h
        BX      device ID
return  CF      set on error
        AH      status
                00h     OK
note 1) Closes all logical devices opened with function 80h.
     2) A multitasking program manager would be expected to capture
        int 15h and provide the appropriate service.
     3) The BIOS default routine for this function simply returns with
        CF clear and AH=00h.


Function 83h    Event Wait
                (AT, XT/286, Convertible, PS/2 50+)
entry   AH      83h
        AL      00h     to set interval
                01h     to cancel (CX:DX and ES:BX not required)
        CX:DX   number of microseconds to wait (granularity is 976
                                                microseconds)
        ES:BX   pointer to semaphore flag (bit 7 is set when interval
                                           expires)
                (pointer is to caller's memory) (some sources list bit
                                                 15 set)
return  CF      clear   OK
                set     function already busy
note 1) Requests setting of a semaphore after a specified interval or
        cancels a previous request.
     2) The calling program is responsible for clearing the semaphore
        before requesting this function.
     3) The actual duration of an event wait is always an integral
        multiple of 976 microseconds.  The CMOS date/clock chip
        interrupts are used to implement this function.
     4) Use of this function allows programmed, hardware-independent
        delays at a finer resolution than can be obtained through use
        of the MS-DOS Get Time function (int 21h/fn 2Ch) which returns
        time in hundredths of a second.
     5) CX:DX is a four-byte integer.
     7) This function is called by int 70h and is not the normal int
        08h/1Ch clock tick.  It is generated by the MC146818A Real Time
        Clock chip.  This is the battery backed up CMOS clock chip.


Function 84h    Read Joystick Input Settings
                (AT, XT/286, PS/2)
entry   AH      84h
        DX      00h     to read current switch settings
                        (return in AL)
                01h     to read resistive inputs
return  CF      set on error
        (fn 00h)
        AL      switch settings (bits 7-4)
        (fn 01h)
        AX      stick A (X) value
        BX      stick A (Y) value
        CX      stick B (X) value
        DX      stick B (Y) value
note 1) An error is returned if DX does not contain a valid
        subfunction number.
     2) If no game adapter is installed, all returned values are 00h.
     3) Using a 250K Ohm joystick, the potentiometer values usually
        lie within the range 0-416 (0000h-01A0h).
     4) Not all BIOSes properly return the presence of a game port.
        In my experience, most BIOSes require a joystick to actually
        be present even if the port is otherwise enabled.


Function 85h    System Request (SysReq) Key Pressed
                (except PC, PCjr, XT)
entry   AH      85h
        AL      00h      key pressed
                01h      key released
return  CF      set on error
        AH      error code
note 1) Called by BIOS keyboard decode routine when the SysReq key
        is detected.
     2) The BIOS handler for this call is a dummy routine that always
        returns a success status unless called with an invalid
        subfunction number in AL.
     3) A multitasking program manager would be expected to capture
        int 15h so that it can be notified when the user strikes the
        SysReq key.


Function 86h    Wait
                (except PC, PCjr, XT)
        AH      86h
        CX:DX   4-byte integer, number of microseconds to wait
                CX high word, DX low word
return  CF      clear   after wait elapses
        CF      set     immediately due to error
note 1) Suspends the calling program for a specified interval in
        microseconds.
     2) The actual duration of the wait is always an integral multiple
        of 976 microseconds.
     3) Use of this function allows programmed, hardware-independent
        delays at a finer resolution than can be obtained through use
        of the MS-DOS Get Time function (int 21h fn 2Ch) which returns
        time in hundredths of a second.
     4) This function calls int 70h and is not the normal Int 08h/1Ch
        clock tick. It is generated by the MC146818A Real Time Clock
        chip.  This is the battery backed CMOS clock chip.


Function 87h    Memory Block Move
                (2-3-486 machines only)
        AH      87h
        CX      number of words to move
        ES:SI   pointer to Global Descriptor Table (GDT)
                offset 00h-0Fh  reserved, set to zero
                           00h  null descriptor
                           08h  uninitialized, will be made into GDT
                                descriptor
                       10h-11h  source segment length in bytes
                                (2*CX-1 or greater)
                       12h-14h  24-bit linear source address
                       15h      access rights byte (always 93h)
                       16h-17h  reserved, set to zero
                       18h-19h  destination segment length in bytes
                                (2*CX-1 or greater)
                       1Ah-1Ch  24-bit linear destination address
                       1Dh      access rights byte (always 93h)
                       1Eh-1Fh  reserved, set to zero
                           20h *uninitialized, used by BIOS
                           28h *uninitialized, will be made into SS
                                descriptor
                              (*) some sources say initialized to zero
return  CF      set on error
        AH      status
                00h     success - source copied into destination
                01h     RAM parity error
                02h     exception interrupt error
                03h     address line 20 gating failed
note 1) The GDT table is composed of six 8-byte descriptors to be
        used by the CPU in protected mode.  The four descriptors in
        offsets 00h-0Fh and 20h-2Fh are filled in by the BIOS before
        the CPU mode switch.
     2) The addresses used in the descriptor table are linear
        (physical) 24-bit addresses in the range 000000h-0FFFFFFh -
        not segments and offsets - with the least significant byte at
        the lowest address and the most significant byte at the highest
        address.
     3) Interrupts are disabled during this call; use may interfere
        with the operation of comm programs, network drivers, or other
        software that relies on prompt servicing of hardware interrupts.
     4) This call is not valid in the OS/2 Compatibility Box.
     5) This call will move a memory block from any real or protected
        mode address to any other real or protected mode address.
     6) DESQview does not intercept function 87, but QEXT and QEMM do,
        thereby allowing function 87 to work correctly inside DV.
        VDISK, which uses function 87, works inside DV.  If VDISK is
        sitting at the 1 MB mark, then the int 19h vector will have a
        VDISK signature in it.  The normal way to check for VDISK
        presence is by checking for the string "VDISK" at offset 12h
        of the segment of the int 19h vector.  If the string matches,
        then you can determine how much extended memory is reserved
        for VDISK by looking at offset 2Ch is the 3-byte address of the
        lowest extended memory address NOT in use by VDISK (i.e. if you
        see at 2Ch "00 00 14" then that means that VDISK is using
        memory up to 1 MB + 256K).


Function 88h    Get Extended Memory Size
                (AT, XT/286, PS/2)
entry   AH      88h
return  AX      number of contiguous 1K blocks of extended memory
                starting at address 0FFFFh (1024Kb)
note 1) This call will not work in the OS/2 Compatibility Box.
     2) Some BIOSes and software manipulate the Carry flag when this
        function is called.  When tested on a vanilla 386 with AMI BIOS
        the machine returned with the Carry Flag set.  When 386Max was
        loaded, the flag was not set.
     3) Used by IBM VDISK 4.0.


Function 89h    Switch Processor to Protected Mode
                (AT, XT/286, PS/2)
entry   AH      89h
        BH      interrupt number for IRQ0, written to ICW2 of 8259
                PIC #1  (must be evenly divisible by 8, determines
                IRQ0-IRQ7)
        BL      interrupt number for IRQ8, written to ICW2 of 8259
                PIC #2  (must be evenly divisible by 8, determines
                IRQ8-IRQ15)
        ES:SI   pointer to 8-entry Global Descriptor Table for
                protected mode:
                offset  00h     null descriptor, initialized to zero
                        08h     GDT descriptor
                        10h     IDT (Interrupt Descriptor Table)
                                descriptor
                        18h     DS, user's data segment
                        20h     ES, user's extra segment
                        28h     SS, user's stack segment
                        30h     CS, user's code segment
                        38h     uninitialized, used to build descriptor
                                for BIOS code segment
return  CF      set on error
                AH      0FFh  error enabling address line 20
        CF      clear   function successful (CPU is in protected mode)
                AH      00h
                CS      user-defined selector
                DS      user-defined selector
                ES      user-defined selector
                SS      user-defined selector
note 1) The user must initialize the first seven descriptors; the
        eighth is filled in by the BIOS to provide addressability for
        its own execution.  The calling program may modify and use the
        eighth descriptor for any purpose after return from this
        function call.
     2) Intercepted by Microsoft's HIMEM.SYS and Quarterdeck's
        QEMM.SYS.


Function 90h    Device Busy Loop                  (except PC, PCjr, XT)
entry   AH      90h
        AL      predefined device type code:
                00h     disk                              (may timeout)
                01h     diskette                          (may timeout)
                02h     keyboard                          (no timeout)
                03h     PS/2 pointing device              (may timeout)
                80h     network
                                                          (no timeout)
                0FCh    hard disk reset (PS/2)            (may timeout)
                0FDh    diskette motor start              (may timeout)
                0FEh    printer                           (may timeout)
        ES:BX   pointer to request block for type codes 80h through 0FFh
                (for network adapters, ES:BX is a pointer to network
                 control block)
return  CF      set     if wait time satisfied
                clear   if driver must perform wait
        AH      status
note 1) Used by NETBIOS, TOPS Network, Tom Wagner's CTASK multitasker,
        Hyperdisk disk cache.
     2) Generic type codes are allocated as follows:
        00h-7Fh   non-reentrant devices; OS must arbitrate access
                  serially reusable devices
        80h-0BFh  reentrant devices; ES:BX points to a unique control
                  block
        0C0h-0FFh wait-only calls, no complementary POST int 15/fn 91h
                  call
     3) Invoked by the BIOS disk, printer, network, and keyboard
        handlers prior to performing a programmed wait for I/O
        completion.
     4) A multitasking program manager would be expected to capture
        int 15h/fn 90h so that it can dispatch other tasks while I/O
        is in progress.
     5) The default BIOS routine for this function simply returns with
        the CF clear and AH=00h.
     6) QEMM 6.0's "Stealth" mode suppresses this call.  Quarterdeck
        claims very few programs properly handle the EMS page frame
        when using this call.


Function 91h    Interrupt Completed
                (AT, XT/286, PS/2 50+)
entry   AH      91h
        AL      type code (see AH=90h above)
                00h-7Fh  serially reusable devices
                80h-0BFh reentrant devices
        ES:BX   pointer to request block for type codes 80h through
                0BFh
return  AH       00h
note 1) Used by NETBIOS and TOPS network, Tom Wagner's CTASK
        multitasker, Hyperdisk disk cache.
     2) Invoked by the BIOS disk network, and keyboard handlers to
        signal that I/O is complete and/or the device is ready.
     3) Predefined device types that may use Device POST are:
        00H  disk                   (may timeout)
        01H  floppy disk            (may timeout)
        02H  keyboard               (no timeout)
        03H  PS/2 pointing device   (may timeout)
        80H  network                (no timeout)
     4) The BIOS printer routine does not invoke this function because
        printer output is not interrupt driven.
     5) A multitasking program manager would be expected to capture
        int 15h/fn 91h so that it can be notified when I/O is
        completed and awaken the requesting task.
     6) The default BIOS routine for this function simply returns with
        the CF flag clear and AH=00h.
     7) QEMM 6.0's "Stealth" mode suppresses this call.  Quarterdeck
        claims very few programs properly handle the EMS page frame
        when using this call.


Function 0C0h   Get System Configuration
                (XT after 1/10/86, PC Convertible, XT/286, AT, PS/2)
entry   AH      0C0h
return  CF      set     if BIOS doesn't support call
        ES:BX   pointer to ROM system descriptor table
          bytes 00h-01h number of bytes in the following table
                        (normally 16 bytes)
                02h     system ID byte; see Chapter 2 for
                        interpretation
                03h     secondary ID distingushes between AT and
                        XT/286, etc.
                04h     BIOS revision level, 0 for 1st release, 1 for
                        2nd, etc.
                05h     feature information byte
                   bits 0       reserved
                        1       Micro Channel bus (instead of ISA or
                                EISA)
                        2       extended BIOS area allocated at 640k
                        3       wait for external event supported
                                (int 15h/fn 41h), used on Convertible;
                                reserved on PS/2 systems
                        4       keyboard intercept: int 15h, fn 04Fh
                                called upon int 09h
                        5       realtime clock installed
                        6       second 8259 installed (cascaded IRQ2)
                        7       DMA channel 3 - used by hard disk
                                BIOS
                06h     unknown (set to 0) (reserved by IBM)
                07h     unknown (set to 0) (reserved by IBM)
                08h     unknown (set to 0)
                09h     unknown (set to 0) (Award BIOS copyright here)
note 1) Int 15h is also used for the Multitask Hook on PS/2 machines.
        No register settings available yet.
     2) The 1/10/86 XT BIOS returns an incorrect value for the
        feature byte.
     3) Novell documents some versions of Netware prior to 2.2 as
        having problems on PS/2 machines due to a bug which did not
        return from the interrupt correctly.
     4) Some AMI BIOSes do not support this function, such as the 
        ones in early Dell machines.


Function 0C1h   Return Extended BIOS Data Area Segment Address
                (AT & later)
entry   AH      0C1h
return  CF      set on error
        ES      segment of XBIOS data area
note 1) The XBIOS Data Area is allocated at the high end of
        conventional memory during the POST sequence.
     2) The word at 0040:0013h (memory size) is updated to reflect the
        reduced amount of memory available for DOS and application
        programs.
     3) The first byte in the XBIOS Data Area is initialized to its
        length in Kb.
     4) A program can determine whether the XBIOS Data Area exists by
        using int 15h/fn 0C0h.


Function 0C2h   Pointing Device BIOS Interface
                (DesQview 2.x) (PS/2)
entry   AH      0C2h
        AL      00h     Enable/Disable Pointing Device
                        BH      00h     disable
                                01h     enable
                01h     Reset Pointing Device
                        Resets the system's mouse or other pointing
                        device, sets the sample rate, resolution, and
                        other characteristics to their default values.
                        return  BH      device ID (0=first)
                        note 1) After a reset operation, the state of
                                the pointing device is as follows:
                                 disabled;
                                 sample rate at 100 reports per second;
                                 resolution at 4 counts per millimeter;
                                 scaling at 1 to 1.
                             2) The data package size is unchanged by
                                this function.
                             3) Apps can use the fn 0C2h subfunctions
                                to initialize the pointing device to
                                other parameters, then enable the
                                device with fn 00h.
                             4) BL is altered on return.
                02h     Set Sampling Rate
                        BH      00h     10/second
                                01h     20/second
                                02h     40/second
                                03h     60/second
                                04h     80/second
                                05h     100/second  (default)
                                06h     200/second
                03h     Set Pointing Device Resolution
                        BH      00h     one count per mm
                                01h     two counts per mm
                                02h     four counts per mm  (default)
                                03h     eight counts per mm
                04h     Get Pointing Device Type
                        return  BH      ID code for the mouse or other
                                        pointing device
                05h     Initialize Pointing Device Interface
                        Sets the data package size for the system's
                        mouse or other pointing device, and initializes
                        the resolution, sampling rate, and scaling to
                        their default values.
                        BH      data package size (1 - 8 bytes)
                        note    After this operation, the state of the
                                pointing device is as follows:
                                a) disabled;
                                b) sample rate at 100 reports per
                                   second;
                                c) resolution at 4 counts per
                                   millimeter;
                                d) scaling set at 1 to 1.
                06h     Get Status or Set Scaling Factor
                        Returns the current status of the system's
                        mouse or other pointing device or sets the
                        device's scaling factor.
                        BH      00h     return device status
                                return  BL      status byte
                                  bits  0       set if right button
                                                is pressed
                                        1       reserved
                                        2       set if left button
                                                is pressed
                                        3       reserved
                                        4       0       1:1 scaling
                                                1       2:1 scaling
                                        5       0       device disabled
                                                1       device enabled
                                        6       0       stream mode
                                                1       remote mode
                                        7       reserved
                                        CL      resolution
                                                00h     1 count per mm
                                                01h     2 counts per mm
                                                02h     4 counts per mm
                                                03h     8 counts per mm
                                        DL      sample rate (hex count)
                                                0Ah     10  reports/sec 
                                                14h     20  reports/sec
                                                28h     40  reports/sec
                                                3Ch     60  reports/sec
                                                50h     80  reports/sec
                                                64h     100 reports/sec
                                                0C8h    200 reports/sec
                                01h     set scaling to 1:1
                                02h     set scaling to 2:1
                07h     Set Pointing Device Handler Address
                        Notifies BIOS pointing device driver of the
                        address for a routine to be called each time
                        pointing device data is available.
                        ES:BX   address of user device handler
                        return  AL      00h
return  CF      set on error
        AH      status
                00h     successful
                01h     invalid function
                02h     invalid input
                03h     interface error
                04h     need to resend
                05h     no device handler installed
note 1) The values in BH for those functions that take it as input are
        stored in different locations for each subfunction.
     2) The user's handler for pointing device data is entered via a
        FAR call with four parameters on the stack:
        SS:SP+0Ah    status
        SS:SP+08h    x coordinate
        SS:SP+06h    y coordinate
        SS:SP+04h    z coordinate (always 0)
         The handler must exit via a far return without removing the
        parameters from the stack.
     3) The status parameter word passed to the user's handler is
        interpreted as follows:
        bits    0       left button pressed
                1       right button pressed
                2-3     reserved
                4       sign of x data is negative
                5       sign of y data is negative
                6       x data has overflowed
                7       y data has overflowed
                8-0Fh   reserved


Function 0C3h   Enable/Disable Watchdog Timeout
                (PS/2 50+, EISA)
entry   AH      0C3h
        AL      00h     disable watchdog
                01h     enable watchdog
                        BX      timer counter
return  CF      set on error
note 1) The watchdog timer generates an NMI.
     2) This would be subject to protection with a real OS so temporary
        masters would not be able to seize the bus forever.


Function 0C3h   Fail-Safe Timer Control
                (EISA)
entry   AH      0C3h
        AL      00h     disable fail-safe timer
        AL      01h     enable fail-safe timer
                BX      timer count value
return  CF      clear   OK
                set     invalid input
note 1) Fn 00h clears WDTIC in the Extended BIOS Data Area.
     2) Fn 01h puts the timer in Mode 0, enables the fail-safe timer
        NMI, places the value in BX in the WDTIC.  When BX counts to
        zero a fail-safe timer NMI is generated.


Function 0C4h   Programmable Option Select
                (PS/2 50+)
entry   AH      0C4h
        AL      00h     return base POS register address
                01h     enable slot
                        BL      slot number
                02h     enable adapter
return  CF      set on error
        DX      base POS register address (if function 00h)
note 1) Fn 00h returns the base Programmable Option Select register
        address, enables a slot for setup, or enables an adapter.
     2) Valid on machines with Micro Channel Architecture (MCA) bus
        only.
     3) After a slot is enabled with fn 01h, specific information can
        be obtained for the adapter in that slot by performing port
        input operations:
        Port    Function
        100h    MCA ID (low byte)
        101h    MCA ID (high byte)
        102h    Option Select Byte 1
            bit 0       0       if disabled
                        1       if enabled
        103h    Option Select Byte 2
        104h    Option Select Byte 3
        105h    Option Select Byte 4
                bits 6-7 are channel check indicators
        106h    Subaddress Extension (low byte)
        107h    Subaddress Extension (high byte)


Function 0C5h   Used by PS/2 Model 50+ and Olivetti MCA machines
                Used by Desqview 2.2
                Used by Lotus 123 Release 2.2
                Used by Microsoft Word 5.0
note    Functions unknown.  Reported by InfoWorld Nov 13 1989's Micro
        Channel 386 test as a conflict between the above software
        packages.  InfoWorld said that Quarterdeck (DESQview) was
        working on a fix for their product.  No other information.


Function 0D8h   Access System Information
                (EISA)
entry   AH      0D8h    Read Slot Information
        AL      00h     (CS specifies 16-bit addressing)
        AL      80h     (CS specifies 32-bit addressing)
        CL      slot number (0-63)
return  AH      status
                00h     OK
                80h     invalid slot number
                82h     extended CMOS RAM corrupted
                83h     specified slot is empty
                86h     invalid BIOS call
                87h     invalid system configuration
        AL      miscellaneous vendor information byte
                bits 7  duplicate IDs exist
                     6  product ID
                   5,4  slot type
                        0,0  expansion slot
                        0,1  embedded device
                        1,0  virtual device
                        1,1  reserved by EISA
                   3,0  duplicate ID number
                        0,0,0,0   no duplicated IDs
                        0,0,0,1   first duplicate ID
                        -------
                        1,1,1,1   15th duplicate ID
        BH      configuration utility, major version number
        BL      configuration utility, minor version number
        CH      configuration file, MSD of checksum
        CL      configuration file, LSD of checksum
        DH      number of device functions
        DL      combined function information
        SI:DI   four byte compressed vendor ID
        CF      clear   OK
                set     error
                AH      will be nonzero if an error occurs


entry   AH      0D8h    Read Function Information
        AL      01h     (CS specifies 16-bit addressing)
        AL      81h     (CS specifies 32-bit addressing)
        CH      function number (0-n-1)
        CL      slot number (0-63)
        DS:SI   address pointer for output data
return  AH      status
                00h     OK
                80h     invalid slot number
                82h     extended CMOS RAM corrupted
                83h     specified slot is empty
                86h     invalid BIOS call
                87h     invalid system configuration
        DS      segment for return data buffer
        SI      offset for return data buffer (16 bit)
       ESI      offset for return data buffer (32 bit)
note    320-byte data buffer:
        offset size     description
        00h     2 words compressed ID
                        byte 0
                        bits 7  reserved
                           6-2  character 1
                           1-0  character 2

                        byte 1
                           7-5  character 2
                           4-0  character 3

                        byte 2
                           7-4  second digit of product number
                           3-0  first digit of product number

                        byte 3
                           7-4  third digit of product number
                           3-0  product revision number
        04h     1 word  ID and slot information
                        byte 0
                        bits 7  0  no duplicate ID is present
                                1  duplicate ID is present
                             6  0  ID is readable
                                1  ID is not readable
                           5-4  slot type
                                0,0  expansion slot
                                0,1  embedded slot
                                1,0  virtual slot
                                1,1  reserved by EISA
                           3,0  duplicate ID number
                                0,0,0,0   no duplicated IDs
                                0,0,0,1   first duplicate ID
                                -------
                                1,1,1,1   15th duplicate ID

                        byte 1  
                        bits 7  0  configuration complete
                                1  configuration not complete
                           6-2  reserved by EISA
                             1  0  EISA IOCHKERR not supported
                                1  EISA IOCHKERR supported
                             0  0  EISA ENABLE not supported
                                1  EISA ENABLE supported

        06h     1 word  configuration file extension revision level
                        byte 0  minor revision level
                        byte 1  major revision level

        07h     13words Selections
                        byte 0  first selection
                        byte 1  second selection
                        ---- -  ----------------
                        byte 25 twenty-sixth selection

        022h    1 byte  Function Information
                        bits 7  0  function is enabled
                                1  function is disabled
                             6  configuration extension free-form data
                             5  port initialization entries follow
                             4  port range entries follow
                             3  DMA entries follow
                             2  interrupt entries follow
                             1  memory entries follow
                             0  type/subtype entries follow

        023h    80bytes Type and subtype ASCII string
                        (strings less than 80 characters padded with
                         zeroes)
                        byte 0  first ASCII character
                        byte 1  second ASCII character
                        ---- -- ----------------------
                        byte 79 eightieth ASCII character

        073h    205byts Free-Form Data Field
                        If Function Information byte 6 IS set, the
                        next 205 bytes (to the end of the 320-byte data
                        block) is a free-form data field.  Byte 0 is
                        the length of the field in bytes, and data
                        starts with byte 1.

        073h    63bytes Memory configuration information
                        (if Function Information bit 6 NOT set)
                        byte 0
                        bits 7  0  last entry
                                1  more entries follow
                             6  reserved by EISA
                             5  0  unshared memory
                                1  shared memory
                           4,3  memory type
                                0,0  SYS (base or extended)
                                0,1  EXP (expanded)
                                1,0  VIR (virtual)
                                1,1  OTH (other)
                             2  reserved by EISA
                             1  0  not cached
                                1  cached
                             0  0  read only (ROM)
                                1  read/write (RAM)

                        byte 1
                           7-4  reserved by EISA
                           3,2  decode size
                                0,0  20
                                0,1  24
                                1,0  32
                                1,1  reserved by EISA
                           1,0  data size (access size)
                                0,0  byte
                                0,1  word
                                1,0  doubleword
                                1,1  reserved by EISA

                        bytes 2-4  memory start address divided by 100h

                        bytes 5-6  memory size divided by 400h

                        Up to 8 more 7-byte entries may follow.

        0B2h    14bytes Interrupt Configuration
                        (if Function Information bit 6 is NOT set)
                        byte 0
                        bits 7  0  last entry
                                1  more entries follow
                             6  0  not shared
                                1  shared
                             5  0  edge triggered
                                1  level triggered
                             4  reserved by EISA
                           3-0  interrupt (0-F)

                        byte 1  reserved by EISA

                        Up to 6 more 2-byte entries may follow.

        0C0h    4 words DMA Channel Description
                        (if Function Information bit 6 is NOT set)
                        byte 0
                        bits 7  0  last entry
                                1  more entries follow
                             6  0  not shared
                                1  shared
                           5-3  reserved by EISA
                           2-0  DMA channel number (0-7)

                        byte 1
                           7,6  reserved by EISA
                           5,4  data timing
                                0,0  default (ISA competible)
                                0,1  type A
                                1,0  type B
                                1,1  type C (burst mode)
                           3,2  transfer size
                                0,0  8-bit
                                0,1  16-bit
                                1,0  32-bit
                                1,1  reserved by EISA
                           1,0  reserved by EISA

                        Up to 3 more 2-byte entries may follow

        0C8h    60bytes Port I/O Information
                        byte 0
                        bits 7  0  last entry
                                1  more entries follow
                             6  0  not shared
                                1  shared
                             5  reserved by EISA
                           4-0  number of sequential ports, less 1

                        bytes 1,2  I/O Port Address

                        Up to 19 more 3-byte entries may follow

        104h    60bytes Initialization Data
                        (If Function Information bit 6 is NOT set)
                        byte 0  Initialization Type
                        bits 7  0  last entry
                                1  more entries follow
                           6-3  reserved by EISA
                             2  port value or mask value
                                0  write to port without mask
                                1  write to port with mask
                           2,0  type of access
                                0,0  byte addressable
                                0,1  word addressable
                                1,0  doubleword addressable
                                1,1  reserved by EISA

                        bytes 1,2   I/O Port address

                        bytes 3-10  (Depends on value of byte 0, bit 2)
                                if bit=0, bytes 3-6 will have the
                                following values based on the access
                                type specified by byte 0, bits 0-1:

                                byte 0, bits 0-1:
                                   0,0   this byte 3 - port value
                                   0,1   this bytes 3,4 - port value
                                   1,0   this bytes 3-6 - port value
                                   1,1   reserved by EISA

                                if bit=1, bytes 3-10 will have the
                                following values based on the access
                                type specified by byte 0, bits 0-1:

                                byte 0, bits 0-1:
                                   0,0   this byte 3 - port value
                                                   4 - port mask
                                   0,1   this bytes 3,4 - port value
                                                    5,6 - port mask
                                   1,0   this bytes 3-6 - port value
                                                    7-10 - port mask
                                   1,1   reserved by EISA

                                Up to 7 more 4, 5, 7, or 11-byte entries
                                may follow.


entry   AH      0D8h    Clear Configuration Storage
        AL      02h     (CS specifies 16-bit addressing)
        AL      82h     (CS specifies 32-bit addressing)
        BH      configuration utility major revision level
        BL      configuration utility minor revision level
return  AH      00h     OK
                84h     error writing to extended CMOS RAM
                86h     invalid BIOS call
                88h     configuration utility not supported


entry   AH      0D8h    Write Function Information
        AL      03h     (CS specifies 16-bit addressing)          
        AL      83h     (CS specifies 32-bit addressing)     
        CX      length of data structure (in bytes)
        DS      segment of data buffer
        SI      offset of data buffer (16-bit)
       ESI      offset of data buffer (32-bit)
return  AH      00h     OK
                84h     error writing to extended CMOS RAM
                85h     CMOS RAM is full
                86h     invalid BIOS call

note    See Function 1 for data fields.



Function 0DEh   DESQview Services                           (DESQview)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 16h  Keyboard I/O                                    3**9  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0058h)       Access the keyboard.  Scancodes are found in Appendix
                1.  ASCII codes are found in Appendix 2.

                IBM's original keyboard layout is referred to as the
                84-key or "old style".  It has the function keys on the
                left and an embedded cursor/numeric keypad on the
                right.  The 101-key "new style" or "enhanced" keyboard
                (such as used on the PS/2s) adds several keys.  The
                early BIOS will not detect the new scancodes and the
                new BIOS for some reason added new function calls for
                this purpose instead of enhancing the old ones.  This
                causes some hassle when writing programs which need to
                support both keyboards fully.  Most programs limit
                themselves to the 84-key functions in the interest of
                backward compatibility.

                The SWITCHES CONFIG.SYS command forces DOS 4.0 to use
                the standard int 16h requests for keyboard I/O rather
                than the extended int 16h requests.

                The DOS KEYB command does not hook into the BIOS.  It
                is a total replacement for the BIOS int9 driver.  The
                only good thing about this is that you can use 101-key
                keyboards on old ATs without support for enhanced
                keyboards.  KEYB is very peculiar in its handling of
                the keyboard, causing some programs to break.  It also
                tends to disable interrupts for a long time while
                processing each scan code.

                There are machines such as the Toshiba 5200 which have
                84-key layouts but "simulate" being 101-key, at least
                as far as int 16h goes.  (always good for confusing
                your software...)

                IBM's TopView saved the state of the capslock,
                scrollock, and numlock keys during task switches.
                DESQview does not save the toggle states unless you
                change the default setup.

Function  00h   Get Keyboard Input
                Read the next character in keyboard buffer, if no key
                is ready, then wait for one.
entry   AH      00h
return  AH      scan code
        AL      ASCII character
note 1) Removes keystroke from buffer (destructive read).
     2) Does not work with the extra keys on the 101-key "enhanced"
        keyboard.


Function  01h   Check Keystroke Buffer - Do Not Clear
entry   AH      01h
return  ZF      0 (clear) if character in buffer
                1 (set)   if no character in buffer
        AH      scan code of character (if ZF=0)
        AL      ASCII character if applicable
note 1) Keystroke is not removed from buffer.  The same character and
        scan code will be returned by the next call to Int 16h/fn 00h.
     2) This call flushes the 101-key codes from the buffer if they
        precede an 84-key code.


Function  02h   Shift Status
                Fetches bit flags indicating shift status.
entry   AH      02h
return  AL      status byte (same as [0040:0017])
           bits 7       Insert on
                6       CapsLock on
                5       NumLock on
                4       ScrollLock on
                3       Alt key down
                2       Control key down
                1       Left shift (left caps-shift key) down
                0       Right shift (right caps-shift key) down
note    The Keyboard Flags Byte is stored in the BIOS Data Area at
        0000:0417h.


Function 03h    Keyboard - Set Repeat Rate
                (PCjr, AT, XT/286, PS/2)
entry   AH      03h
        AL      00h     reset typematic defaults                (PCjr)
                01h     increase initial delay                  (PCjr)
                02h     decrease repeat rate by 1/2             (PCjr)
                03h     increase both delays by 1/2             (PCjr)
                04h     turn off typematic                      (PCjr)
                05h     set typematic rate                  (AT, PS/2)
        BH      00h-03h for delays of 250ms, 500ms, 750ms, or 1 second
                        0,0     250ms
                        0,1     500ms
                        1,0     750ms
                        1,1     1 second
        BL      00h-1Fh for typematic rates of 30cps down to 2cps
                        00000 30     01011 10.9   10101 4.5
                        00001 26.7   01100 10     10110 4.3
                        00010 24     01101 9.2    10111 4
                        00011 21.8   01110 8.6    11000 3.7
                        00100 20     01111 8      11001 3.3
                        00101 18.5   10000 7.5    11010 3
                        00110 17.1   10001 6.7    11011 2.7
                        00111 16     10010 6      11100 2.5
                        01000 15     10011 5.5    11101 2.3
                        01001 13.3   10011 5.5    11110 2.1
                        01010 12     10100 5      11111 2
return  nothing
note 1) Subfunction 05h is available on ATs with ROM BIOS dated
        11/15/85 and later, the XT/286, and the PS/2.
     2) Subfunction 0 (Return to Default Keyboard State) restores the
        keyboard to its original state.  An IBM AT's original state at
        power-on is typematic on, normal initial delay and normal
        typematic rate.
     3) Subfunction 1 (Increase Initial Delay) increases the delay
        between the first character typed and the burst of typematic
        characters.
     4) For Subfunctions 0 through 4, each time the typematic rate is
        changed, all previous states are removed.
     5) Some clone keyboards (Northgate Omnikey and Focus) and 
        BIOSES (AMI) have much higher repeat rates for the same bit
        values.


Function 04h    Keyboard Click Toggle
                (PCjr and Convertible)
entry   AH      04h
        AL      00h     for click off
                01h     for click on
return  nothing


Function 05h    Load Keyboard Buffer
                (AT or PS/2 with enhanced kbd)
entry   AH      05h
        CH      scan code
        CL      ASCII character
return  CF      set on error
        AL      00h     success
                01h     if buffer full
note    Places a character and scan code at the end of the keyboard
        type-ahead buffer.


Function 06h    Keyboard Buffer Write           (Fansi-Console to 2.00)
entry   AH      06h
        BX      extended key value to place in typeahead buffer
return  unknown
note    This call may be dropped since it now duplicates function 05h.


Function 07h    Change Shift Key Status         (Fansi-Console to 2.00)
entry   AH      07h
        AL      shift key status value
return  unknown
note    Status byte is same as function 02h.


Function 10h    Get Enhanced Keystroke And Read 
                (XT/286, PS/2, AT with "Enhanced" keyboard)
entry   AH      10h
return  AH      scan code
        AL      ASCII character if applicable
note 1) Reads a character and scan code from the keyboard type-ahead
        buffer.
     2) Use this function for the enhanced keyboard instead of int 16h
        fn 00h.  It allows applications to obtain the scan codes for
        the additional F11, F12, and cursor control keys.
     3) This is the enhanced version of function 00h.


Function 11h    Check Enhanced Keystroke
                (XT/286, PS/2, AT with "Enhanced" keyboard)
entry   AH      11h
return  ZF      0       (clear) if key pressed
                        AH      scan code
                        AL      ASCII character if applicable
                1       if buffer is empty
note 1) Keystroke is not removed from buffer.  The same char and scan
        code will be returned by the next call to Int 16h/fn 10h.
     2) Use this function for the enhanced keyboard instead of int
        16h/fn 00h.  It allows applications to test for the additional
        F11, F12, and cursor control keys.


Function 12h    Extended Get Shift Status  (F11, F12 Enhanced keyboard)
entry   AH      12h
return  AX      status word
                AL bit  0       right Shift key depressed
                        1       left Shift key depressed
                        2       Control key depressed
                        3       Alt key depressed
                        4       ScrollLock state active
                        5       NumLock state active
                        6       CapsLock state active
                        7       insert state is active
                AH bit  0       left Control key pressed
                        1       left Alt key depressed
                        2       right Control key pressed
                        3       right Alt key depressed
                        4       Scroll Lock key depressed
                        5       NumLock key depressed
                        6       CapsLock key depressed
                        7       SysReq key depressed
note    Use this function for the enhanced keyboard instead of int
        16h/fn 02h.


Function  4fh   Gerkey - German keyboard remapper from OVI-SYSTEM
entry   AH      4Fh     Gerkey function
        AL      56h     installation check
return  AX      0FFFFh  installed, otherwise not present
        BH      major version
        BL      minor version


Function  70h, 71h, 72h  Internal Functions    (SEAware's FAKEY.COM)
note    FAKEY.COM is a TSR keyboard utility distributed to registered
        users of SEAware products.


Function  75h   Set Tick Count for Scanning       (pcAnywhere 2.00)
entry   AH      75h
        AL      tick count
return  none
note 1) Sets count of 55ms timer ticks between checks for new screen
        changes.
     2) pcAnywhere is a program that allows operation of a remote
        machine over a serial link.


Function  76h   Set Error Checking Mode           (pcAnywhere 2.00)
entry   AH      76h
        AL      error checking type
                00h     none
                01h     fast
                02h     slow
return  none


Function  77h   reserved                          (pcAnywhere 2.00)
pcAnywhere API - reserved


Function  78h   Log Off                           (pcAnywhere 2.00)
entry   AL      00h     wait for another call
                01h     exit but remain TSR
                02h     automatic mode - watches DTR
                0FFh    leave in current operating mode  (ver. 2.1)
return  none


Function  79h   Installation Check                (pcAnywhere 2.00)
entry   AH      79h
        AL      00h     installation check
return  AX      0FFFFh  resident and active
                0FFFEh  resident but not active
                0FFFDh  resident TSR
                0FFFCh  automatic mode
                any other value - not resident


Function  7Ah   Cancel pcAnywhere Session         (pcAnywhere 2.00)
entry   AH      7Ah
return  none
note    Leaves pcAnywhere resident but unable to answer another call.


Function  7Bh   Enable/Disable Operation          (pcAnywhere 2.00)
entry   AH      7Bh
        AL      state
                00h     disabled
                01h     enabled
return  none
note    Remote screen is automatically refreshed when session is enabled.


Function  7Ch   Get Port Configuration            (pcAnywhere 2.00)
entry   AH      7Ch
return  AH      port number in binary (0-15)
        AL      baud rate
                00h     50
                01h     75
                02h     110
                03h     134.5
                04h     150
                05h     300
                06h     600
                07h     1200
                08h     1800
                09h     2000
                0Ah     2400
                0Bh     4800
                0Ch     7200
                0Dh     9600
                0Fh     19,200


Function  7Dh   Get/Set Terminal Parameters       (pcAnywhere 2.00)
entry   AH      7Dh
        AL      00h     set parameters
                01h     get parameters
                02h     get configuration header and terminal
                        parameters
        CX:DS   address of Terminal Parameter Block
return  AL      00h     nothing
                01h     current Terminal Parameter Block in CX:DS
                02h     configuration header and Terminal Parameter
                        Block in CX:DS
note    Terminal Parameter Block format:   (1152 bytes) (decimal)
        384 bytes  CRT Control Information
                bytes   function
                1-8     cursor up
               9-16     cursor down
              17-24     cursor left
              25-32     cursor right
              33-40     cursor home
              41-48     clear screen
              49-56     clear to end of line
              57-64     clear to end of page
              65-72     insert line
              73-80     delete line
              81-88     insert character
              89-96     delete character
             97-104     cursor position lead in
            105-112     between row and column
            113-120     after cursor position
            121-128     CRT initialization
        256 bytes  Character Translation Table
                translates ASCII characters from host.  Normally
                changes IBM graphics characters to other displayable
                symbols
        512 bytes  keyboard sequences
            641-644     cursor up
            645-648     cursor down
            649-652     cursor left
            653-656     cursor right
            657-660     home
            661-664     end
            665-668     PgUp
            669-672     PgDn
            673-676     insert
            677-680     delete
            681-684     control-home
            685-688     control-end
            689-692     control-PgUp
            693-696     control-PgDn
            697-700     escape
            701-740     F1...F10
            741-780     sF1...sF10
            781-820     ^F1...^F10
            821-860     aF1...aF10
            861-964     alt A-Z
           965-1004     alt 0-9
          1005-1008     alt =
          1009-1012     alt -
          1013-1016     print screen
          1017-1020     ctrl-left arrow
          1021-1024     ctrl-right arrow
          1025-1120     reserved
          1121-1124     begin conv. mode
          1125-1128     remote printing off
          1129-1132     remote printing on
          1133-1136     backspace
          1137-1140     refresh screen
          1141-1144     send next code
          1145-1148     display top 24 lines
          1149-1152     display bottom 24 lines


Function  7Eh   Serial I/O Through pcAnywhere Port   (pcAnywhere 2.00)
entry   AH      7Eh
        AL      I/O function
                01h     get port input status
                02h     get port input character
                03h     output character
                04h     hang up phone
        CX      ASCII character to output (fn 03h)
return  (if AL=01h)
        AX      00h     no character ready
                01h     character is available
        (if AL=02h)
        AL      ASCII code received


Function  7Fh   Set Keyboard/Screen Mode            (pcAnywhere 2.00)
entry   AH      7Fh
        AL      parameters
                00h     enable remote keyboard only  |
                01h     enable host keyboard only    |  keyboard group
                02h     enable both keyboards        |

                08h     display top 24 lines         |  screen group
                09h     display bottom 24 lines      |

                10h     Hayes modem                  |
                11h     other modems                 |  modem group
                12h     direct connect               |


Function 0A5h   Central Point Software PC-Tools PC-CACHE 6.0 and later
entry   AH      0A5h    installation check
        AL      0FFh
        CX      1111h   magic number
return  CH      00h     installed
note    DOS Disk Reset call will also flush the cache from mid
        version 6 on.

Function 0AFh   Central Point Software PC-Tools PC-CACHE 5.x
entry   AH      0AFh    flush cache
        AL      0FFh
        CX      0FFFFh  magic number
return  unknown
note    This is safe, even if PC Cache in not installed.


Function 0EDh   Borland Turbo Lightning API  (partial)
entry   AH      0EDh
        BH      0EDh
        BL      function
                00h     installation check
                02h     pointer to Lightning internal data structure
                        low byte
                03h     pointer to Lightning internal data structure
                        high byte
                04h     load auxiliary dictionary
                06h     autoproof mode
                0Fh     get number of substitutions (segment)
        DS:DI   pointer to string to be processed
return  AX      error code (unknown)
note    I've made several attempts to get a copy of the Turbo
        Lightning API, which was originally supposed to be available
        for developers in 1985.  In 1988 Borland sent me a letter
        saying they were still working on it.  In late 1989 the Borland
        rep on BIX told me basically that there were no plans for
        releasing the API any more.  The information here was dredged
        from Chris Dunford's LSPELL.PAS interface into Lighting.


Function 0F0h   Set CPU speed                            (Compaq 386)
entry   AH      0F0h    set speed
        AL      speed
                00h     equivalent to 6 mHz 80286 (COMMON)
                01h     equivalent to 8 mHz 80286 (FAST)
                02h     full 16 mHz (HIGH)
                03h     toggles between 8 MHz-equivalent and speed
                        set by system board switch (AUTO or HIGH)
                04h-07h unknown
                08h     full 16 MHz except 8 MHz-equivalent during
                        floppy disk access
                09h     specify speed directly
                        CX      speed value, 1 (slowest) to 50 (full),
                                3 ~=8088
return  none?
note 1) Used by Compaq DOS MODE command.


Function 0F1h   Read Current CPU Speed                    (Compaq 386)
entry   AH      0F1h
return  AL      speed code (see function 0F0h above)
                if AL=09h, CX=speed code


Function 0F2h   Determine Attached Keyboard Type          (Compaq 386)
entry   AH      0F2h
return  AL      type
                00h     if 11-bit AT keyboard is in use
                01h     if 9-bit PC keyboard is in use


Function 0FFh   PC-Tools API
entry   AH      0FFh
        AL      0A5h    detect PC-Cache disk cache (ver 5.0 & later)
                CH      11h
                CL      11h
return  CH      00h     cache is present
note    PC-Tools is a Swiss-army-knife software package with an
        editor, DOS shell, cache, disk optimizer, and several other
        functions from Central Point Software.


Function 0FFh   PC-Tools API
entry   AH      0AFh
        AL      0AFh    flush PC-Cache disk cache (from mid-version-6)
                CH      0FFh
                CL      0FFh
return  none
note    PC-Tools is a Swiss-army-knife software package with an
        editor, DOS shell, cache, disk optimizer, and several other
        functions from Central Point Software.


Function 0FFh   2-The-Max VGA-16 Board
entry   AH      0FFh    query zoom interrupt
return  AL      zoom interrupt number
        AL+1    old BIOS keyboard handler interrupt number
        BX      hot key


Function 0FFh   Programmer Interface to Carbon Copy Plus (5.0)
entry   AH      0FFh
        AL      00h     check connection between CC and CCHELP
return  BL      00h     Carbon Copy not connected to CCHELP
                01h     Carbon Copy is connected to CCHELP

entry   AL      01h     disconnects and resets the line if the Host
                        or CC side is connected to CCHELP

entry   AL      02h     return a pointer to the last phone number
                        dialed by CC
return  ES:DI           dword pointer to ASCIIZ phone number string



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 17h  Printer                                        3**10 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:005Ch)       Access the parallel printer(s)
                AH is changed.  All other registers left alone.

                Printer ports vary widely in compatibility, since the
                original IBM MDA's parallel port did not match its own
                spec.  Many parallel ports do not use IRQ7 at all.

                The parallel port on a monochrome adapter is at 3BCh.
                The port on a parallel printer adapter is at 378h or
                278h.  At boot time, the BIOS looks at them in the
                order 3BCh, 378h, 278h, and assigns the first port it
                finds to LPT1, the second to LPT2, etc.  If you have a
                monochrome adapter, LPT1 is probably 3BCh; otherwise,
                it is probably 378h.


Function  00h   Print Character/send AL to printer DX (0, 1, or 2)
entry   AH      00h
        AL      ASCII character code
        DX      printer to be used
                00h     PRN or LPT1
                01h     LPT2
                02h     LPT3
return  AH      status byte
           bits 0       time out
                1       unused
                2       unused
                3       I/O error
                4       printer selected
                5       out of paper
                6       acknowledge
                7       not busy


Function 01h    Initialize Printer
                Set init line low, send 0Ch to printer DX
entry   AH      01h
        DX      printer port to be initialized (0,1,2)
return  status as below


Function  02h   Printer Status
                Read status of printer DX into AH
entry   AH      02h
        DX      printer port to be used (0,1,2)
return  AH      status byte
           bits 7       0       busy/paused: the printer cannot
                                immediately take more data because it
                                is in the middle of accepting a
                                character, printing a line, is
                                offline, or it is in error status.
                        1       ready
                6   ACKnowledge line toggled: reflects the state of
                    the ACK line on the printer port at the moment the
                    status was read.  ACK is a strobe: it goes low for
                    a very short time (12 microseconds on an Epson)
                    when the printer is ready for another character.
                    As far as printer status is concerned, this is
                    useless; it's only useful for something like an
                    interrupt-driven interface.  Most of the time,
                    you'll see ACK high (bit 6 on), but occasionally,
                    if you check status just after sending a character,
                    you might see it low.  ACK is low when the printer
                    is powered off.
                5   out-of-paper line toggled
                4   printer selected: printer is selected, ready, 
                    or, online.  There is usually a button on the
                    printer to control this.
                3   I/O error: offline, out of paper or other error
                    condition such as out of ribbon.
                2   unused
                1   unused
                0   timeout error: printer failed to send ACK and
                    drop busy after being sent a character.
note 1) You can expect to see these states in a properly functioning
        printer:
        Normal                Offline                Power off
        ======                =======                =========
        not busy/paused       busy/paused            busy/paused
        not out of paper      not out of paper       not out of paper
        selected/online       not selected/online    not selected/online
        not I/O error         I/O error (usually)    I/O error
        not timeout error     not timeout error      not timeout error
     2) Not all printers return the status codes properly.  That's OK,
        not all clone BIOSes do it right either.  If your program
        depends on the return codes, you might want to make the code
        easily patched or configured for nonstandard hardware.


Function   03h  Versa-Spool print spooler
entry   AH      03h     Versa-Spool
        AL      00h     Return Signature
                01h     Toggle Pause
                02h     Clear Buffer
                03h     Request Pause Condition
                04h     Request Free Buffer Space
                05h     Request Total Buffer Size
                06h     Redirect Output to LPT1
                07h     Redirect Output to LPT2
                08h     Redirect Output to LPT3
                09h     Request Output Device
                0Ah     Request Output Speed
                0Bh     Request Device Spooled Status

return  (AH=00h)        AX      1234h   if Versa-Spool is installed
                                        undefined if not installed
        (AH=01h)        AX      0001h   if paused
                                0000h   if resumed
        (AH=02h)        AX      0302h   not cleared
                                0000h   cleared
        (AH=03h)        AX      0001h   if paused
                                0000h   if resumed
        (AH=04h)        AX      remaining buffer space (in Kbytes)
        (AH=05h)        AX      total buffer space (in Kbytes)
        (AH=06h)        AX      nothing
        (AH=07h)        AX      nothing
        (AH=08h)        AX      nothing
        (AH=09h)        AX      printer output (0..2)
        (AH=0Ah)        AX      output speed in CPS
        (AH=0Bh)        AX      0001h   is spooled
                                0000h   otherwise


Function  03h   Print String                             (PC-MOS/386)
        Print an entire string with one interrupt call
entry   AH      03h
        CX      number of characters in string
        DX      printer port number
        DS:SI   pointer to string
return  AH      status code (same as PC BIOS)
        CX      number of characters printed
note 1) Any redirection set up with the MOS ROUTE command or
        SPOOL.COM will be in effect.
     2) Some serial terminals so not provide printer status feedback.


Function  0C0h  PC Magazine PCSPOOL - get printer status
entry   AH      0C0h
        DX      printer port to be used (0,1,2)
return  ES:BX   address of printer control block
note    PC Magazine, January 15, 1991. (Vol 10, Number 1)


Function  0C1h  PC Magazine PCSPOOL - add pause to spool queue
entry   AH      0C1h
        DX      printer port to be used (0,1,2)
        DS:SI   pointer to ASCIIZ string to display
return  AH      printer status


Function  0C2h  PC Magazine PCSPOOL - flush queue record
entry   AH      0C2h
        DX      printer port to be used (0,1,2)
return  AH      printer status


Function  0C3h  PC Magazine PCSPOOL - cancel printer queue
entry   AH      0C3h
        DX      printer port to be used (0,1,2)
return  AH      printer status


Function  0C4h  PC Magazine PCSPOOL - determine of spooler is active
entry   AH      0C4h
return  DI      0B0BFh  if PCSPOOL is loaded
        SI      segment of the PSP of the active PCSPOOL


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 18h  ROM BASIC                                       3**11 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0060h)       Execute ROM BASIC at address 0F600h:0000h
entry   no parameters used
return  jumps into ROM BASIC on IBM systems
note 1) Often reboots a compatible.
     2) Used by Turbo C 1.5. 2.0 and later do not use it.
     3) On IBM systems, this interrupt is called if disk boot failure
        occurs.
     4) Video interrupt on DEC Rainbow.
     5) Digital Research's ROM-based implementation of DR-DOS uses int
        18h as the initial entry vector into the operating system code.
        Note that some clone BIOSes may not properly implement int 18h
        in the ROM and use of DR-DOS ROMs may not always work.
     6) Maxon 286/HD laptop: called by BIOS power management routines
        to communicate with applications.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 19h  Bootstrap Loader / Extended Memory VDISK ID     3**12 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0064h)
entry   no parameters used
return  none
note 1) Reads track 0, sector 1 into address 0000h:7C00h, then
        transfers control to that address.  If no diskette drive is
        available, scans memory from C:000 to F:000 for a valid hard
        disk or other ROM. If none, transfers to ROM-BASIC via int 18h
        or displays loader error message.
     2) Causes reboot of disk system if invoked while running.
        (no memory test performed).
     3) If location 0000:0472h does not contain the value 1234h, a
        memory test (POST) will be performed before reading the boot
        sector.
     4) VDISK from DOS 3.0+ traps this vector to determine when the
        CPU has shifted from protected mode to real mode.  A detailed
        discussion can be found by Ray Duncan in PC Magazine, May 30,
        1989.
     5) Reportedly, some versions of DOS 2.x and all versions of DOS
        3.x+ intercept int 19h in order to restore some interrupt
        vectors DOS takes over, in order to put the machine back to a
        cleaner state for the reboot, since the POST will not be run on
        the int 19h.  These vectors are reported to be: 02h, 08h, 09h,
        0Ah, 0Bh, 0Ch, 0Dh, 0Eh, 70h, 72h, 73h, 74h, 75h, 76h, and 77h.
        After restoring these, it restores the original int 19h vector
        and calls int 19h.
     6) The system checks for installed ROMs by searching memory from
        0C000h to the beginning of the BIOS, in 2k chunks.  ROM memory
        is identified if it starts with the word 0AA55h.  It is
        followed a one byte field length of the ROM (divided by 512).
        If ROM is found, the BIOS will call the ROM at an offset of 3
        from the beginning.  This feature was not supported in the
        earliest PC machines.  The last task turns control over to the
        bootstrap loader (assuming the floppy controller is
        operational).
     7) 8255 port 60h bit 0 = 1 if booting from diskette.
     8) All IBM BIOSes and most clone BIOSes will try to boot from
        floppy A: if no other boot device is present.  Some machines
        (notably mil-spec Zeniths) have a jumper to prohibit booting
        from floppy at all, for "security reasons".  Many Tandy
        machines will try to boot from drive B: if the F2 key is held
        down during POST.  With a CompatiCard floppy controller you
        can boot off ANY drive.
     9) Phoenix BIOSes with password protection enabled use this call
        for the password routine.
    10) With early versions of DOS 5.0, int 19h fails with EMM386.EXE
        loaded and and DOS=HIGH in CONFIG.SYS


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Ah  Time of Day                                     3**13 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

(0:0068h)    1) Accesses the PC internal clock.
             2) This interrupt is not supported on some machines, such
                as the HP150 PC.
             3) Some "turbo" BIOSes run the clock slower than normal in
                order to throw off benchmark software, which usually
                uses int 1Ah for timekeeping.
             4) Counts occur at the rate of 1193180/65536 counts/sec
                (about 18.2 per second).

Function 00h    Read System Timer Tick Counter            (except PC)
entry   AH      00h
return  AL      00h     if clock was read or written (via AH=0,1)
                        within the current 24-hour period.
                <>0     midnight was passed since last read
        CX:DX   32-bit tick count (high 16 bits in CX)
note 1) The returned value is the cumulative number of clock ticks
        since midnight.  There are 18.2 clock ticks per second, or one
        every 54.92ms.  When the counter reaches 1,573,040, it is
        cleared to zero, and the rollover flag is set.
     2) The rollover flag is cleared by this function call, so the
        flag will only be returned nonzero once per day.
     3) Int 1Ah/fn 01h can be used to set the counter to an arbitrary
        32 bit value.
     4) This function does not return seconds/100 in DL. The best you
        can do is set it to zero (or any value <=99).  This means that
        your DOS clock could be up to 1 second off from the BIOS
        clock, however the effect is not cumulative.


Function 01h    Set Clock Tick Counter Value              (except PC)
entry   AH      01h
        CX:DX   32-bit high word/low word count of timer ticks
return  none
note 1) The clock ticks are incremented by timer interrupt at 18.2065
        times per second or 54.9254 milliseconds/count. Therefore:
                counts per second   18      (12h)
                counts per minute   1092    (444h)
                counts per hour     65543   (10011h)
                counts per day      1573040 (1800B0h)
     2) The counter is zeroed when system is rebooted.
     3) Stores a 32-bit value in the clock tick counter.
     4) The rollover flag is cleared by this call.


Function 02h    Read Real Time Clock Time
                (AT and after)
entry   AH      02h
return  CH      hours in BCD
        CL      minutes in BCD
        DH      seconds in BCD
        DL      00h     standard time
                01h     daylight savings time
        CF      0       if clock running
                1       if clock not operating
note 1) Reads the current time from the CMOS time/date chip.
     2) Also for Leading Edge Model M.
     3) According to Phoenix this call will fail if the BIOS is
        "updating" its clock value.  You should check the carry flag
        and retry if it is set following the call.


Function 03h    Set Real Time Clock Time
                (AT and after)
entry   AH      03h
        CH      hours in BCD
        CL      minutes in BCD
        DH      seconds in BCD
        DL      0 (clear) if standard time
                1 (set)   if daylight savings time option
return  none
note 1) Sets the time in the CMOS time/date chip.
     2) Also for Leading Edge Model M.


Function 04h    Read Real Time Clock Date
                (AT and after)
entry   AH      04h
return  CH      century in BCD (19 or 20)
        CL      year in BCD
        DH      month in BCD
        DL      day in BCD
        CF      0 (clear) if clock is running
                1 (set)   if clock is not operating
note 1) Reads the current date from the CMOS time/date chip.
     2) Also for Leading Edge Model M.


Function 05h    Set Real Time Clock Date
                (AT and after)
entry   AH      05h
        CH      century in BCD (19 or 20)
        CL      year in BCD
        DH      month in BCD
        DL      day in BCD
return  none
note 1) Sets the date in the CMOS time/date chip.
     2) Also for Leading Edge Model M with Leading Edge DOS 2.11.


Function 06h    Set Real Time Clock Alarm
                (AT and after)
entry   AH      06h
        CH      hours in BCD
        CL      minutes in BCD
        DH      seconds in BCD
return  CF      set if alarm already set or clock inoperable
note 1) Sets alarm in the CMOS date/time chip.  Int 4Ah occurs at the
        specified alarm time every 24hrs until reset with Int 1Ah
        function 07h.
     2) A side effect of this function is that the clock chip's
        interrupt level (IRQ8) is enabled.
     3) Only one alarm may be active at any given time.
     4) The program using this function must place the address of its
        interrupt handler for the alarm in the vector for Int 4Ah.


Function 07h    Reset Real Time Clock Alarm
                (AT and after)
entry   AH      07h
return  none
note 1) Cancels any pending alarm request on the CMOS date/time chip.
     2) This function does not disable the clock chip's interrupt
        level (IRQ8).


Function 08h    Set Real Time Clock Activated Power On Mode
                (Convertible)
entry   AH      08h
        CH      hours in BCD
        CL      minutes in BCD
        DH      seconds in BCD


Function 09h    Read Real Time Clock Alarm Time and Status
                (Convertible and PS/2 Model 30)
entry   AH      09h
return  CH      hours in BCD
        CL      minutes in BCD
        DH      seconds in BCD
        DL      alarm status:
                00h     if alarm not enabled
                01h     if alarm enabled but will not power up system
                02h     if alarm will power up system


Function 0Ah    Read System-Timer Day Counter
                (PS/2)
entry   AH      0Ah
return  CF      set on error
        CX      count of days since Jan 1,1980
note    Returns the contents of the system's day counter.


Function 0Bh    Set System-Timer Day Counter
                (PS/2)
entry   AH      0Bh
        CX      count of days since Jan 1,1980
return  CF      set on error
note    Stores an arbitrary value in the system's day counter.


Function 80h    Set Up Sound Multiplexor
                (PCjr) (Tandy 1000?)
entry   AH      80h
        AL      sound source
                00h     source is 8253 timer chip, channel 2
                01h     source is cassette input
                02h     source is I/O channel "audio in" line
                03h     source is TI sound generator chip
return  none
note    Sets up the source for tones that will appear on the PCjr's
        Audio Out bus line or RF modulator.


Function 81h    Get Sound status                    (Tandy 1000RL)
        parameters unknown


Function 82h    Input Sound (from the microphone)   (Tandy 1000RL)
        parameters unknown


Function 83h    Output Sound (to the speaker)       (Tandy 1000RL)
        parameters unknown


Function 84h    Stop Sound input and output          (Tandy 1000RL)
        parameters unknown


Function 1Ah    Read Time and Date                      (AT&T 6300)
entry   AH      0FEh
return  BX      days count (1=Jan 1, 1984)
        CH      hours
        CL      minutes
        DH      seconds
        DL      hundredths
note    Day count in BX is unique to AT&T/Olivetti computers.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Bh  Control-Break                                   3**14 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:006Ch)       This interrupt is called when the keyboard handler
                detects Ctrl and Break pressed at the same time.  DOS
                normally points this interrupt at its own Ctrl-Break
                handler.

note 1) If the break occurred while processing an interrupt, one or
        more end of interrupt commands must be send to the 8259
        Programmable Interrupt Controller.
     2) All I/O devices should be reset in case an operation was
        underway at the time.
     3) It is normally pointed to an IRET during system initialization
        so that it does nothing, but some programs change it to return
        a Ctrl-C scan code and thus invoke int 23h.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Ch  Timer Tick                                      3**15 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0070h)
note 1) Taken 18.2065 times per second by the int 08h interrupt.
     2) Normally vectors to dummy IRET unless PRINT.COM has been
        installed.
     3) If an application moves the interrupt pointer, it is the
        responsibility of that application to save and restore all
        registers that may be modified.
     4) returns values at absolute address 40:6x (BIOS Data Area);
        number of ticks since midnight
        40:6C   word    timer counter high word
        40:6E   word    timer counter low word
     5) Ventura Publisher 2.0 grabs this interrupt and does not pass
        subsequent vector reassignments along.  This causes problems
        with some TSRs and network software.
     6) When installing a user interrupt for int 1Ch, the external
        interrupts must be disabled before the vector is altered.  If a
        timer interrupt occurs between the setting of the offset and
        segment, an incorrect address will result.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Dh  Vector of Video Initialization Parameters       3**16 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0074h)       This doubleword address points to 3 sets of 16 bytes
                containing data to initialize for video modes for video
                modes 0 & 1 (40 column), 2 & 3 (80 column), and 4, 5 &
                6 (graphics) on the Motorola 6845 CRT controller chip.
 6845 registers:
        R0      horizontal total          (horizontal sync in characters)
        R1      horizontal displayed                (characters per line)
        R2      horizontal sync position     (move display left or right)
        R3      sync width   (vertical and horizontal pulse: 4-bits each)
        R4      vertical total                    (total character lines)
        R5      vertical adjust          (adjust for 50 or 60 Hz refresh)
        R6      vertical displayed             (lines of chars displayed)
        R7      vertical sync position         (lines shifted up or down)
        R8      interlace (bits 4 and 5) and skew (bits 6 and 7)
        R9      max scan line addr         (scan lines per character row)
        R10     cursor start               (starting scan line of cursor)
        R11     cursor stop                  (ending scan line of cursor)
        R12     video memory start address high byte             (6 bits)
        R13     video memory start address low byte              (8 bits)
        R14     cursor address high byte                         (6 bits)
        R15     cursor address low byte                          (8 bits)

 6845 Video Init Tables:
        table for modes 0 and 1   \
        table for modes 2 and 3    \ each table is 16 bytes long and
        table for modes 4,5, and 6 / contains values for 6845 registers
        table for mode 7          /
      4 words   size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
      8 bytes   number of columns in each mode
      8 bytes   video controller mode byte for each mode
note 1) There are four separate tables, and all four must be
        initialized if all  video modes will be used.
     2) The power-on initialization code of the computer points this
        vector to the ROM BIOS video routines.
     3) IBM recommends that if this table needs to be modified, it
        should be copied into RAM and only the necessary changes made.




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Eh  Vector of Diskette Controller Parameters        3**17 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0078h)       Dword address points to data base table that is used by
                BIOS.  Default location is at 0F000:0EFC7h.  11-byte
                table format:
          bytes:
                00h     4-bit step rate, 4-bit head unload time
                01h     7-bit head load time, 1-bit DMA flag
                02h     54.9254 ms ticks - delay til motor off (36-38
                        typical)
                03h     sector size:
                        00h     128 bytes
                        01h     256 bytes
                        02h     512 bytes
                        03h     1024 bytes
                04h     last sector on track            (8 or 9 typical)
                05h     inter-sector gap on read/write      (42 typical)
                06h     data length for DMA transfers     (0FFh typical)
                07h     gap length between sectors for format   (80 typ)
                08h     sector fill byte for format       (0F6h typical)
                09h     head settle time (in milliseconds)
                                                      (15 to 25 typical)
                        DOS 1.0   0
                        DOS 1.10  0
                        DOS 2.10  15
                        DOS 3.1   1
                0Ah     motor start time (in 1/8 sec intervals)
                        (2-4 typical)
                        DOS 2.10  2
note 1) This vector is pointed to the ROM BIOS diskette tables on
        system initialization
     2) IBM recommends that if this table needs to be modified, it
        should be copied into RAM and only the necessary changes made.
     3) Some versions of DOS 3.2 may contain a bug.  DOS 3.2 assumes
        that the dword at 0070:0F37 contains the address of the
        diskette parameter block and changes values in that block.  The
        location does contain a copy of the value at 0:78 (int 1Eh,
        DISK_POINTER) if DOS is booted from diskette, but when booted
        from the hard disk, the location contains 0:0.  This leads to
        strange things, especially when running under a debugger since
        DOS overwrites parts of the interrupt vectors for interrupts 1
        to 3.  The solution to the problem is to either upgrade to DOS
        3.3 or to copy the disk parameter vector to 70:0F37 before
        running or at the start of your program.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Fh  Ptr to Graphic Char Extensions (Graphics Set 2) 3**18 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:007Ch)       This is the pointer to data used by the ROM video
                routines to display characters above ASCII 127 while in
                CGA medium and high res graphics modes.

note 1) Doubleword address points to 1K table composed of 28 8-byte
        character definition bit-patterns.  First byte of each entry is
        top row, last byte is bottom row.
     2) The first 128 character patterns are located in system ROM.
     3) This vector is set to 000:0 at system initialization.
     4) Used by DOS' external GRAFTABL command.




   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                       C H A P T E R    F O U R


                   DOS INTERRUPTS AND FUNCTION CALLS


                            C O N T E N T S

General Programming Guidelines .................................. 4**1
DOS Registers ................................................... 4**2
DOS Stacks ...................................................... 4**3
DOS Interrupts .................................................. 4**4
Interrupt 20h (Terminate) ....................................... 4**5
DOS Services (quick list) ....................................... 4**6
Calling the DOS Services ........................................ 4**7
Version Specific Information .................................... 4**8
Compatibility Problems With DOS 4.0+ ............................ 4**9
PCjr Cartridge Support .......................................... 4**10
eDOS 4.0 ........................................................ 4**11
DOS Services in Detail .......................................... 4**12


General Programming Guidelines .................................. 4**1

  Microsoft recommends avoiding the "old style" DOS 1.0 (01h-0Ch and
26h) system calls wherever possible.  Programmers are urged to use the
"new style" (DOS 2.0+) handle calls instead.

  Do not use "undocumented" functions unless they are critical to your
application and no other reasonable workaround can be found.  Remember
that your programs may have to run under various versions of DOS, DOS
clones such as Digital's DR-DOS, the OS/2 Compatibility Box, or Unix
DOS Emulation Window.  Such environments or OS simulations do not
always implement the undocumented calls.

  DOS 2.x and 3.x lack many of the enhancements found in later
versions.  Your application should check the minimum required DOS
version when specific features are required.  Do not test for a higher
version than necessary or you will cause problems for machines running
older versions of DOS, such as business machines which are seldom
upgraded, laptops with DOS in ROM, etc.

  Direct disk access via hardware or the BIOS should be avoided
unless your program will only be run on specific hardware or under
certain circumstances.  Some versions of DOS 2.x treat their disks in
a manner much like 3.x.  Some vendors added multiple DOS partitions or
oversize drive support prior to the "official" 3.3 release.  Not all
these systems work in the same way!  New-type SCSI or ESDI hard disk
controllers do not always emulate all the standard BIOS calls.


DOS Registers ................................................... 4**2

 DOS uses the following registers, pointers, and flags when it executes
interrupts and function calls:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³GENERAL REGISTERS ³register³               definition                ³
³                  ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                  ³   AX   ³  accumulator                   (16 bit) ³
³                  ³   AH   ³  accumulator high-order byte   ( 8 bit) ³
³                  ³   AL   ³  accumulator low order byte    ( 8 bit) ³
³                  ³   BX   ³  base                          (16 bit) ³
³                  ³   BH   ³  base high-order byte          ( 8 bit) ³
³                  ³   BL   ³  base low-order byte           ( 8 bit) ³
³                  ³   CX   ³  count                         (16 bit) ³
³                  ³   CH   ³  count high order byte         ( 8 bit) ³
³                  ³   CL   ³  count low order byte          ( 8 bit) ³
³                  ³   DX   ³  data                          (16 bit) ³
³                  ³   DH   ³  date high order byte          ( 8 bit) ³
³                  ³   DL   ³  data low order byte           ( 8 bit) ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³SEGMENT REGISTERS ³register³               definition                ³
³                  ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                  ³   CS   ³  code  segment (16 bit)                 ³
³                  ³   DS   ³  data  segment (16 bit)                 ³
³                  ³   SS   ³  stack segment (16 bit)                 ³
³                  ³   ES   ³  extra segment (16 bit)                 ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³INDEX REGISTERS   ³register³               definition                ³
³                  ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                  ³   DI   ³  destination index (16 bit)             ³
³                  ³   SI   ³  source      index (16 bit)             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³POINTERS          ³register³               definition                ³
³                  ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                  ³   SP   ³  stack       pointer (16 bit)           ³
³                  ³   BP   ³  base        pointer (16 bit)           ³
³                  ³   IP   ³  instruction pointer (16 bit)           ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FLAGS               AF, CF, DF, IF, OF, PF, SF, TF, ZF               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

  These registers, pointers, and flags all work on the "lowest common
denominator" 8088-8086 CPU.  DOS makes no attempt to use any of the
special or enhanced instructions available on the later CPUs which will
execute 8088 code, such as the 80186, 80286, 80386, or NEC V20, V30,
V40, or V50.

  User registers except AX are preserved unless information is passed
back to the register as indicated in specific function calls.

  For PC-MOS/386 on a 386 CPU, the task switching logic saves the
upper half of the 32-bit registers and the complete FS and GS
registers.

  The Intel 8088 processors supplied for the early IBM PCs were
defective and did not handle the stack register properly on an INT
instruction.  DOS 2.1 added extra logic around interrupt calls for
stack handling; this is the major difference between 2.0 and 2.1.


DOS Stacks ...................................................... 4**3

  When DOS takes control after a function call, it switches to an
internal stack.  Registers which are not used to return information
(other than AX) are preserved.  The calling program's stack must be
large enough to accomodate the interrupt system - at least 128 bytes
in addition to other interrupts.

 DOS actually maintains three stacks -

stack 1: 384 bytes (in DOS 3.1)
         for functions 00h and for 0Dh and up, and for ints 25h and
         26h.

stack 2: 384 bytes (in DOS 3.1)
         for function calls 01h through 0Ch.

stack 3: 48 bytes (in DOS 3.1)
         for functions 0Dh and above.  This stack is the initial stack
         used by the int 21h handler before it decides which of the
         other two to use.  It is also used by function 59h (get
         extended error), and 01h to 0Ch if they are called during an
         int 24h (critical error) handler.  Functions 33h (get/set
         break flag), 50h (set process ID), 51h (get process ID) and
         62h (get PSP address) do not use any DOS stack under DOS 3.x
         (under 2.x, 50h and 51h use stack number 2).

  IBM and Microsoft made a change back in DOS 3.0 or 3.1 to reduce the
size of DOS.  They reduced the space allocated for scratch areas when
interrupts are being processed.  The default seems to vary with the
DOS version and the machine, but 8 stack frames seems to be common.
That means that if you get more than 8 interrupts at the same time,
clock, disk, printer spooler, keyboard, com port, etc., the system will
crash.  It usually seems to happen on a network.

  DOS 3.2 does some different stack switching than previous versions.
The interrupts which are switched are 02h, 08h, 09h, 0Ah, 0Bh, 0Ch,
0Dh, 0Eh, 70h, 72h, 73h, 74h, 75h, 76h, and 77h.  DOS 3.2 has a
special check in the initialization code for a PCjr and don't enable
stack switching on that machine.  DOS 3.3 was changed so that no stack
switching occurs on PC, PC-XT, or the PC Portable, and defaults to 9
stacks of 128 bytes in an AT.

  Additional stacks can be allocated when DOS loads by using the
STACKS= command in CONFIG.SYS.  These stacks are in addition to the
3 internal DOS stacks.  STACKS=16,256 means allow 16 interrupts to
interrupt each other and allow 256 bytes for each for scratch area.


DOS Interrupts .................................................. 4**4

  Microsoft recommends that a program wishing to examine or set the
contents of any interrupt vector use the DOS function calls 35h and
25h provided for those purposes and avoid referencing the interrupt
vector locations directly.

  DOS reserves interrupt numbers 20h to 3Fh for its own use.  This
means absolute memory locations 80h to 0FFh are reserved by DOS.



Interrupt 20h - Terminate Current Program ....................... 4**5

(0:0080h)
  Issue int 20h to exit from a program.  This vector transfers to the
logic in DOS to restore the terminate address, the Ctrl-Break address,
and the critical error exit address to the values they had on entry to
the program.  All the file buffers are flushed and all handles are
closed.  You should close all files changed in length (see function
calls 10h and 3Eh) before issuing this interrupt.  If the changed file
is not closed, its length, time, and date are not recorded correctly
in the directory.

  This call is intended for use with .COM programs only.

  For a program to pass a completion code or an error code when
terminating, it must use either function call 4Ch (Terminate a
Process) or 31h (Terminate Process and Stay Resident).  These two
methods are preferred over using int 20h and the codes returned by
them can be interrogated in batch processing.

Important: Before you issue an interrupt 20h, your program must
           ensure that the CS register contains the segment of its
           Program Segment Prefix.

Interrupt 20h   DOS - Terminate Program
entry   no parameters
return  The following vectors are restored from the Program Segment
        Prefix:
        PSP offset  interrupt  description
            0Ah        22h     Program Terminate
            0Eh        23h     Control-C
            12h        24h     Critical Error
note 1) IBM and Microsoft recommend using int 21h Fn 4Ch.  Using int
        20h is officially frowned upon since the introduction of DOS
        2.0.
     2) In DOS 3.2 at least, int 20h merely calls int 21h, fn 00h.
     3) Supported by PC-MOS/386.



DOS Services (quick list) ....................................... 4**6

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 21h  Function Call Request                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0084h)
  DOS provides a wide variety of function calls for character device 
I/O, file management, memory management, date and time functions,
execution of other programs, and more.  They are grouped as follows: 

          call              description
        00h           program terminate
        01h-0Ch       character device I/O, CP/M compatibility format
        0Dh-24h       file management,      CP/M compatibility format
        25h-26h       nondevice functions,  CP/M compatibility format
        27h-29h       file management,      CP/M compatibility format
        2Ah-2Eh       nondevice functions,  CP/M compatibility format
        2Fh-38h       extended functions
        39h-3Bh       directory group
        3Ch-46h       extended file management
        47h           directory group
        48h-4Bh       extended memory management
        54h-57h       extended functions
        5Eh-5Fh       networking
        60h-62h       extended functions
        63h-66h       enhanced foreign language support


List of DOS services:   * = undocumented
        00h     terminate program
        01h     get keyboard input
        02h     display character to STDIO
        03h     get character from STDAUX
        04h     output character to STDAUX
        05h     output character to STDPRN
        06h     direct console I/O - keyboard to screen
        07h     get char from std I/O without echo
        08h     get char from std I/O without echo, checks for ^C
        09h     display a string to STDOUT
        0Ah     buffered keyboard input
        0Bh     check STDIN status
        0Ch     clear keyboard buffer and invoke keyboard function
    o   0Dh     flush all disk buffers
    o   0Eh     select disk
        0Fh     open file with File Control Block
        10h     close file opened with File Control Block
        11h     search for first matching file entry
        12h     search for next matching file entry
        13h     delete file specified by File Control Block
        14h     sequential read from file specified by File Control
                Block
        15h     sequential write to file specified by File Control
                Block
        16h     find or create firectory entry for file
        17h     rename file specified by file control block
        18h*    unknown
    o   19h     return current disk drive
    o   1Ah     set disk transfer area (DTA)
        1Bh     get current disk drive FAT
        1Ch     get disk FAT for any drive
        1Dh*    unknown
        1Eh*    unknown
        1Fh     read DOS disk block, default drive
        20h*    unknown
        21h     random read from file specified by FCB
        22h     random write to file specified by FCB
        23h     return number of records in file specified by FCB
        24h     set relative file record size field for file specified
                by FCB
    o   25h     set interrupt vector
        26h     create new Program Segment Prefix (PSP)
        27h     random file block read from file specified by FCB
        28h     random file block write to file specified by FCB
        29h     parse the command line for file name
    o   2Ah     get the system date
    o   2Bh     set the system date
    o   2Ch     get the system time
    o   2Dh     set the system time
    o   2Eh     set/clear disk write VERIFY
    o   2Fh     get the Disk Transfer Address (DTA)
    o   30h     get DOS version number
        31h     TSR, files opened remain open
        32h     read DOS Disk Block
    o   33h     get or set Ctrl-Break
        34h     INDOS  Critical Section Flag
    o   35h     get segment and offset address for an interrupt
    o   36h     get free disk space
        37h*    get/set option marking character (SWITCHAR)
    o   38h     return country-dependent information
    o   39h     create subdirectory
    o   3Ah     remove subdirectory
    o   3Bh     change current directory
    o   3Ch     create and return file handle
    o   3Dh     open file and return file handle
    o   3Eh     close file referenced by file handle
    o   3Fh     read from file referenced by file handle
    o   40h     write to file referenced by file handle
    o   41h     delete file
    o   42h     move file pointer (move read-write pointer for file)
    o   43h     set/return file attributes
    o   44h     device IOCTL (I/O control) info
    o   45h     duplicate file handle
    o   46h     force a duplicate file handle
    o   47h     get current directory
    o   48h     allocate memory
    o   49h     release allocated memory
    o   4Ah     modify allocated memory
    o   4Bh     load or execute a program
    o   4Ch     terminate prog and return to DOS
    o   4Dh     get return code of subprocess created by 4Bh
    o   4Eh     find first matching file
    o   4Fh     find next matching file
        50h*    set new current Program Segment Prefix (PSP)
        51h*    puts current PSP into BX
        52h*    pointer to the DOS list of lists
        53h*    translates BPB (Bios Parameter Block, see below)
    o   54h     get disk verification status (VERIFY)
        55h*    create PSP: similar to function 26h
    o   56h     rename a file
    o   57h     get/set file date and time
        58h     get/set allocation strategy             (DOS 3.x)
    o   59h     get extended error information
    o   5Ah     create a unique filename
    o   5Bh     create a DOS file
    o   5Ch     lock/unlock file contents
        5Dh     DOS internal functions
        5Eh*    network printer
        5Fh*    network redirection
        60h*    parse pathname (TRUENAME)
        61h*    unknown
        62h     get program segment prefix (PSP)
        63h*    get lead byte table                     (DOS 2.25)
        64h*    unknown
        65h     get extended country information        (DOS 3.3)
        66h     get/set global code page table          (DOS 3.3)
        67h     set handle count                        (DOS 3.3)
        68h     commit file                             (DOS 3.3)
        69h     disk serial number                      (DOS 4.0)
        6Ah     unknown
        6Bh     unknown
        6Ch     extended open/create                    (DOS 4.0)

  Items marked with 'o' are explicitly supported in the OS/2 1.x DOS
Compatibility Box, according to Microsoft.  Most everything is 
supported in the OS/2 2.0 Virtual DOS Machine, according to IBM.


Calling the DOS Services ........................................ 4**7

  The DOS services are invoked by placing the number of the desired
function in register AH, subfunction in AL, setting the other
registers to any specific requirements of the function, and invoking
int 21h.

  When the interrupt is called, all register and flag values are 
pushed into the stack.  Int 21h contains a pointer into an absolute 
address in the IBMDOS.COM file.  This address is the main loop for the 
DOS command handler.  The handler pops the register values, compares 
them to its list of functions, and executes the function if valid.  
When the function is complete, it may pass values back to the command 
handler. The handler will push the values into the stack and then 
return control to the calling program. 

  Most functions will return an error code; some return more
information.  Details are contained in the listings for the individual
functions.  Extended error return codes for most functions may be
obtained by calling function 59h.

  Register settings listed are the ones used by DOS.  Some functions
will return with garbage values in unused registers.  Do not test for
values in unspecified registers; your program may exhibit odd behavior.

  DS:DX pointers are the data segment register (DS) indexed to the DH
and DL registers (DX).  DX always contains the offset address, DS
contains the segment address.

  The File Control Block services (FCB services) were part of DOS 1.0.
Since the release of DOS 2.0, Microsoft has recommended that these
services not be used.  A set of considerably more enhanced services
(handle services) were introduced with DOS 2.0.  The handle services
provide support for wildcards and subdirectories, and enhanced error
detection via function 59h.  The FCB calls  also do not support the
sharing modes or file locking functions of the handle calls, making
them unsafe for use with networks or multitaskers.

  The data for the following calls was compiled from various Intel,
Microsoft, IBM, and other publications.  There are many subtle
differences between MSDOS and PCDOS and between the individual
versions.  Differences between the versions are noted as they occur.

  There are various ways of calling the DOS functions.  For all
methods, the function number is loaded into register AH, subfunctions
and/or parameters are loaded into AL or other registers, and call int
21h by one of the following methods:

 A) call interrupt 21h directly  (the recommended procedure)
 B) perform a long call to offset 50h in the program's PSP.
     1) This method will not work under DOS 1.x.
     2) Though recommended by Microsoft for DOS 2.0, this method takes
        more time and is no longer recommended.
 C) place the function number in CL and perform an intrasegment call
    to location 05h in the current code segment.  This location
    contains a long call to the DOS function dispatcher.
     1) IBM recommends this method be used only when using existing
        programs written for different calling conventions.  (such as
        converting CP/M programs).  This method should be avoided
        unless you have some specific use for it.
     2) AX is always destroyed by this method.
     3) This method is valid only for functions 00h-24h.
 D) PC-MOS/386' virtualization scheme results in 200-400+ clocks per
    interrupt when run on an 80286 machine since it has to flip in and
    out of protected mode at CPU ring 0.  TSL recommends the following
    procedure for apps that must run quickly on 286 machines:
       1) PUSHF
       2) CLI
       3) CALL DWORD PTR[vector-contents]
    This avoids flipping in and out of protected mode and the attendant
    overhead.  However, TSL specifies this technique should not be used
    with native-mode MOS applications.


  There are also various ways of exiting from a program. (assuming it
is not intended to be a TSR).  All methods except call 4Ch must ensure
that the segment register contains the segment address of the PSP.

 A) Interrupt 21h, function 4Ch (Terminate with Result Code). This is
    the "official" recommended method of returning to DOS.
 B) Interrupt 21h, function 00h (Exit Program).  This is the early
    style int 21h function call.  It simply calls int 20h.
 C) Interrupt 20h (Exit).
 D) A JMP instruction to offset 00h (int 20h vector) in the Program
    Segment Prefix.  This is just a roundabout method to call int 20h.
    This method was set up in DOS 1.0 for ease of conversion for CP/M
    programs.  It is no longer recommended for use.
 E) A JMP instruction to offset 05h (int 21 vector) in the Program
    Segment Prefix, with AH set to 00h or 4Ch.  This is another CP/M
    type function.



Version Specific Information .................................... 4**8

* Function Calls:

        DOS 2.x  supports function calls 00h to 57h.
                
        DOS 2.25 is the only version to support function 63h
                 (foreign keyboard)

        DOS 3.x  has more sophisticated error handling and detection
                 function calls available than 2.x.

        DOS 3.0  supports function calls 00h to 5Ch and 62h, including
                 new and changed function calls for version 3.0:
                   3Dh  Open File
                   59h  Get Extended Error
                   5Ah  Create Temporary File
                   5Bh  Create New File
                   5Ch  Lock/Unlock File Access
                   62h  Get Program Segment Prefix Address

        DOS 3.1  supports function calls 00h to 62h, including the
                 new  and changed function calls for DOS 3.1:
                   5E00h  Get Machine Name
                   5E02h  Set Printer Setup
                   5E03h  Get Printer Setup
                   5F02h  Get Redirection List Entry
                   5F03h  Redirect Device
                   5F04h  Cancel Redirection

        DOS 3.2  supports the following new functions:
                   44h    extended IOCTL functions

        DOS 3.3  supports the following new functions:
                   44h    extended IOCTL functions
                   65h    get extended country information (DOS 3.3)
                   66h    get/set global code page table (DOS 3.3)
                   67h    set handle count (DOS 3.3)
                   68h    commit file (DOS 3.3)

        DOS 4.0  supports the following new functions:
                   44h    extended IOCTL functions
                   69h    disk serial number
                   6Ch    extended open/create

        DOS 5.0  supports the following new int 21h functions:
                   30h     sub 00h Get OEM ID number
                           sub 01h Get version flag
                   33h     sub 06h Return "real" DOS version number
                   44h     sub 0Dh/68h, Sense Media Type
                           sub 10h Query IOCTL handle
                           sub 11h Query IOCTL device
                   4Bh     sub 01h load but don't execute
                                   (formerly undocumented)
                           sub 05h  Enter EXEC State
                   51h     Get Program Segment Prefix
                                   (formerly undocumented)
                   58h     sub 02h Get UMB Link Status
                           sub 03h Set UMB Link Status
                   65h     Get Extended Country Information
                           sub 05h  Get filename character table
                           sub 20h  Convert character
                           sub 21h  Convert string
                           sub 22h  Convert ASCIIZ string

                ...and the following other functions:
                   2Fh     sub 1680h MS-DOS Idle Call
                   Task Switcher API

        DOS 6.0  supports the following new int 21h functions:
                   44h     sub 04h adds DoubleSpace flush


PCjr Cartridge Support .......................................... 4**9

==========================
ibm.dos/secrets.2 #1337, from jswitzer, 525 chars, Sat Jul 29 08:48:15 1989
This is a comment to message 1334.
--------------------------
The PCJr ROM cartridges have a command table that lists the name of
each supported command and its vector in the ROM.  It does the ROM
match first before the internal command match, actually, so it will
execute what it finds there.  Now that I think about it, this means that
you could burn your own ROMs in the proper format and get your own
commands. Neat, I guess.

As to it being in command.com, my DOS 3.3 version has some of the code
about 1A4C.  Do a search with debug for "55 AA" and you'll find the
main routine.

Read:comment
Comment to message number 1337. Enter text. End with '.<CR>'
> 55 AA, that's right. That's the ID for a valid ROM. I'll fire up
> symdeb and poke through COMMAND if I can find my little white cane...


==========================
ibm.dos/secrets.2 #1776, from jswitzer, 319 chars, Tue Sep 19 01:33:09 1989
This is a comment to message 1773.
--------------------------
Actually, you can NOP all of the PCJr code without problems -- AST and
Toshiba both have COMMAND.COM without it, and no major problems.  The
interesting thing is that PC-DOS 4.0x still has it, and they explicity
say that DOS 4 is NOT supported on the PCJr (*they* meaning IBM, of
course).

What can you figure, huh?

Read:comment
Comment to message number 1776. Enter text. End with '.<CR>'
> I sold my PCjr this morning (I swear to Baud!) and therefore can't make
>a test to see what would happen with 4.0 on the Jr. If IBM still sells
>the PC/JX in Japan that might be the reason for continuing cartridge
>support, since the machine is PCjr-based (well, about the way a PS/2 is
>PC-based).
> I used to run Toshiba DOS 2.11V on the Jr since it was provably faster
>on screen updates and disk access than IBM 2.1 (with a Jr, it doesn't take
>much to make a noticable difference). The only cartridges I had were
>ColorPaint and BASIC, and I can't remember if I used 2.11 with them or
>not.
>
==========================
ibm.dos/secrets.2 #1777, from jswitzer, 251 chars, Tue Sep 19 01:34:24 1989
--------------------------
The PCJr code in COMMAND.COM is ONLY executed on the PCJr and the PCJr
doesn't support normal BIOS expansion ROMs, only the expansion cartridges.

So, no conflict.  If you patch out the check for the PCJr machine ID,
though, good luck!
        John Switzer
Read:comment
Comment to message number 1777. Enter text. End with '.<CR>'
> Ummm..... lemme go back and look at the listing again. The way it looked
>the first time, it seemed like ALL commands went through the loop.


Compatibility Problems With DOS 4.0 ............................. 4**10

  Compatibility problems with DOS 4.00 lie mainly in int 2Ah and int 
2Fh.  While 2Ah was always reserved, some network software uses this 
interrupt.  IBM and Microsoft documentation prior to 4.0 strongly 
implies that int 2Fh functions not already used by PRINT.COM were open 
for general use.  DOS 4.00 grabs a number of these functions. The 
difference in disk handling when >32mb partitions are used causes 
problems with some older software. 

  Most DOS 4.00 external programs (ASSIGN, SUBST, etc) check for files 
being printed - including LABEL.  This is part of the enhanced network 
support.  Almost all DOS 4.00 externals make checks for NETBIOS too. 

  DOS 5.0 ditched most of this peculiar stuff, making for a much more 
stable product.



eDOS 4.0 ........................................................ 4**11

  Microsoft had announced their intent to build a multitasking, 
multiuser version of MSDOS as early as 1982.   As mentioned in Chapter 
1, the DOS 4.0 issued to selected OEMS in England and Europe in 
'86/'87 is not the same code that was released here as DOS 4.0 in 
1988.  Microsoft shipped betas of "DOS 4.0" in the US during the same 
time period, but the product was never release in the US.  The 
European DOS 4.0 (eDOS?) is a multitasking DOS written by Microsoft, 
while the US DOS 4.0 is a single tasking DOS written by IBM.  eDOS 4.0 
was released in Europe after 3.1, but before 3.2. 

(abstracted from a pre-release document):

  `Microsoft Multitasking MS-DOS Product Specification'  dated April
28, 1986

  MS-DOS 4.0 is a multitasking operating system, developed from and 
compatible with MS-DOS 3.1.  It supports true multitasking which gives 
the user the illusion of and benefits from many independent computers.  
Further, MS-DOS 4.0 allows most existing MS-DOS 2.x and 3.x 
applications to run without change in the MS-DOS 4.0 multitasking 
environment. 

(end of abstract).

  Gordon Letwin of Microsoft had this to say about eDOS:

(excerpted from "Turning Off The Car To Change Gears" Microsoft Systems
 Journal, volume 2, number 2. May 1987)

  "DOS 4 was the first product to result from Microsoft's multitasking 
DOS effort.  We began it even before IBM introduced the PC AT.  It was 
an ambitious project that was originally to include a protected mode 
with mode switching capabilities so it could run on the 8086 or the 
286. 
  A general-purpose multitasking system needs to run in both modes: 
the unprotected 8086 mode so that we can run existing DOS 
applications, and the protected 286 mode so that we can multitask 
arbitrary, unrelated applications. But the architecture of the 286 
caused some delays.  Although we knew the project would be difficult, 
it was only after we'd gotten deeply into it that we realized just how 
difficult it would be. 
  As a result, DOS 4 became too complicated for our schedules.  
Because of the pressure of customer demand as well as that of previous 
commitments, we broke the project into two parts.  DOS 4 runs only in 
real mode and provides multitasking only for specialized applications.  
DOS 5, which has now been released as OS/2, includes the protected 
mode and other features.  DOS 4 was delivered in the last half of 1986 
and is being sold in special application environments, primarily in 
Europe.  It is a specialized product that can share the market with 
OS/2, because it runs on 8086 hardware, while OS/2 requires a 286.  
The move from DOS 4 to OS/2 was a gradual evolutionary process." 

(end of excerpt)

  eDOS 4.0 consisted of one main program (DOS2/3 compatible) and 
several multitasking (background) programs that had to be written 
specially.  The whole lot was constrained to fit in the single 640k 
memory map. 

int 21h functions:   (some of these appeared in later versions of DOS)

AEXEC       Identical to EXEC sub 4.
CREATMEM    creates a named area of memory which may be accessed by
            other processes.  (shared memory \SHAREMEM\...)
CRITENTER, CRITLEAVE (semaphore routines)
CRITERR     (This is the one that should have been in DOS 3)
            Enables hard error processing or automatically fails hard
            errors.
CWAIT       Waits for return code from asynchronous process.  Returns
            when any child process terminates.  Children may also be
            started as orphans in which case you cannot WAIT for them.
EXEC 4Bh    (sub function 4) - Start async process.
FREEZE      Stops a specified process running.
GETEXTENDEDERROR - As for DOS3 except it checks version number to
            specify the level of error handling - you may ask for a
            pointer to the hard error information packet for the latest
            hard error.
GETMEM      obtains access to a shared memory area previously created.
GETPID      Returns process ID and parents process ID.
GET/SET MEMORY PARTITION SIZE
            foreground memory is used for ordinary apps.  Background
            memory is used for DOS 4 apps that don't use the screen (or
            only use it through popup functions).  Background apps can
            also use foreground memory but not vice versa.
KILL        Terminates a process.
PBLOCK      Block a process until matching PRUN is given.  A timeout
            is also specified.  A memory location is passed which must
            be matched in the PRUN.  (semaphore)
PIPE        Create a pipe.  Access it through READ/WRITE/CLOSE (but not
            LSEEK).
PRUN        Release a blocked process.  (semaphore)
RELEASEMEM  Release access to shared memory.  If the reference count
            hits zero then the memory is freed.
RESUME      Thaws a frozen process.
SEND SIGNAL
            Signals were:
                  SIGINTR, SIGTERM, SIGPIPE, SIGUSER1, SIGUSER2.
                  Control C, End of program, Broken pipe, user def,
                  user def.
            Actions were:
                  Terminate process on receipt, ignore, accept,
                  sender gets error or acknowledge received signal.
           The last one of these returns to the sender immediately -
           it is intended for use when processing the signal will take
           a long time.
SETFILETABLE (86h)   Install a new file handle table. (more than 20
           files, as in DOS 3.3+?)
SETPRI      Sets process priority (for this process or entire subtree).
SET SIGNAL HANDLER
SLEEP       Suspends the current process for given number of
            milliseconds.  MSC 4.0 had a demo which called 'DOS_sleep'
            int 21h/fn 89h - does not appear to be implemented in
            known DOS versions.
WAIT        As for DOS 3.

int 2Fh functions:

CHECKPU    check for popup package installation
POSTPU     open/close a popup screen
SAVEPU     save popup screen
RESTOREPU  restore popup screen

Other useful features:

   eDOS 4.0 programs used the Windows .EXE format
   programs may share code segments
   improved device drivers
       the serial port had a full set of IOCTL calls (used through
          a new generic IOCTL call).
       device drivers could be multi-tasking.  They had appropriate
          support routines to queue multiple requests (just like OS/2
          later provided)
   interrupt driven serial ports
   sorted disk buffers before writing


The following were listed as possible future enhancements:

   File system protection and        (not yet available from MS,
     permissions                      though DRI has it)

   High performance file system      (HPFS was delivered in OS/2 1.2)

   Installable file systems          (IFS hook is present in US DOS 
                                      4.0, deleted in DOS 5 according
                                      to Gordon Letwin of Microsoft)

   Symbolic links                    (they don't have these on OS/2
                                      even now do they?)

   Undelete                          (added with DOS 5.0)

   Long names, lowercase names,      (OS/2 HPFS, NT NTFS)
   access/creation date/time, name
   of app creating file, revision
   number etc.


  According to bits of information picked up from BIX, Wang tested an 
alpha version of eDOS 4.0 for use on a laptop project sometime in 1985 
but gave up because the OS was unable to cope with "ill behaved" 
programs in a reasonable fashion.  I talked with one person who had 
beta-tested it for MS, who commented "the only thing it would run was 
COMMAND.COM."  Microsoft has evidently either squashed eDOS completely 
or (likely) incorporated it into OS/2.  I've been unable to determine 
if the French post office still uses eDOS, and to the best I can find 
out Apricot Computer never did much with it. 

  DOSREF user John Dallman contributed the following:  (July 1992)

  "You put a few notes in DOSREF about the multi-tasking MS-DOS 4.0 
that was released in Europe during 1986/87.  Notably, you wondered if 
it ever reached any customers.  I'm sorry to tell you that the answer 
is yes - briefly.  It was withdrawn owing to serious reliability 
problems: Apricot and ICL sold it in the UK, and I've had email from 
someone who bought a retail copy in Hong Kong." 

  Ray Duncan had this to say about eDOS' metamorphosis: (PC Magazine, 
October 16, 1990 excerpted from Power Programming, page 464) 

  "OS/2 as it exists today is a vastly different system than the 
protected-mode successor to DOS first envisioned by Microsoft in 1984 
and 1985.  The earliest version, internally known as DOS 5.0 or 
286DOS, was small and relatively fast - it could even be booted from a 
floppy disk on a 1mb 80286 machine.  The 286DOS application program 
interface (API), which was a proper superset of the DOS Int 21h, 
Microsoft Mouse Int 33h, and ROM BIOS video Int 10h and keyboard Int 
16h interfaces, was small enough to be easily understood and allowed 
the straightforward porting of any DOS application.  286DOS was not 
burdened with a built-in graphical user interface; the original plan 
was to make a protected-mode version of Microsoft Windows available as 
a separate product that the user could run on top of 286DOS as an 
option. 
 But somewhere along the torturous path from the original, 
experimental implementations of 286DOS to the retail product now known 
as OS/2, things went badly awry..." 

  Microsoft Press' "MSDOS Encyclopedia" shows a reproduction of a late 
DOS 1.25 OEM brochure.  Microsoft was touting future enhancements to 
1.25 including Xenix-compatible pipes, process forks, and 
multitasking, as well as "graphics and cursor positioning, kanji 
support, multi-user and hard disk support, and networking."  Microsoft 
certainly thought big, but, alas, the forks, multitasking, and 
multiuser support never came about, at least in US versions of DOS.  
Oddly, the flyer claims that... 

 "MS-DOS has no practical limit on disk size.  MS-DOS uses 4-byte 
XENIX OS compatible pointers for file and disk capacity up to 4 
gigabytes." 

  Umm... yeah.  One sort of gets the idea nobody at Microsoft had a 
hard disk larger than 32 megabytes... 

 For the record they actually delivered:
                                
Xenix-compatible pipes             DOS 2.0  ("|" operator)
process forks, and multitasking   eDOS 4.0  (not delivered in the US)
multi-user                         never delivered
graphics and cursor positioning    DOS 2.0  (ANSI.SYS, more than likely)
kanji support                      DOS 2.01, 2.25 (double-byte char set)
hard disk support                  DOS 2.0  (subdirectories)
networking                         DOS 3.1  (file locking, MS Networks)

  Early Microsoft ads pumped DOS' Xenix-like features and promised 
Xenix functionality in future releases. 

  We'll probably never know what the real story was behind eDOS - DOS 
4 - DOS 5 - 286DOS - OS/2.  Despite Gordon Letwin's acid comments 
about problems with the 80286 processor, I doubt the '286 was the 
barrier between users and a multitasking MSDOS.  I also doubt there 
was any shortage of programming talent at Microsoft - Digital 
Research's Concurrent DOS and Software Link's PC-MOS were developed 
without undue trouble. 

  Though it's highly unlikely anyone would ever need programming 
information for eDOS, I find the entire subject fascinating.  IBM had 
not only promised the product, they ran ads for it in 1984-85. Who 
axed the project?  Why?  We'll likely never find out. 



DOS Services in Detail .......................................... 4**12


INT 21H   DOS services
          Function (hex)

* Indicates Functions not documented in the IBM DOS Technical
Reference.

  Note some functions have been documented in other Microsoft or
licensed OEM documentation.


Function  00h   Terminate Program
      Ends program, updates, FAT, flushes buffers, restores registers
entry   AH      00h
        CS      segment address of PSP
return  none
note 1) Program must place the segment address of the PSP control
        block in CS before calling this function.
     2) The terminate, ctrl-break,and critical error exit addresses
        (0Ah, 0Eh, 12h) are restored to the values they had on entry
        to the terminating program, from the values saved in the
        program segment prefix at locations PSP:000Ah, PSP:000Eh, and
        PSP:0012h.
     3) All file buffers are flushed and the handles opened by the
        process are closed.
     4) Any files that have changed in length and are not closed are
        not recorded properly in the directory.
     5) Control transfers to the terminate address.
     6) This call performs exactly the same function as int 20h.
     7) All memory used by the program is returned to DOS.  DOS just
        goes up the chain of memory blocks and marks any that are
        owned by the PSP which is terminating as free.
     8) TOS: $00 TERM.  Returns system control to the program from
        which it started.  If EXECed from a program, returns to that
        program.  If started from DeskTop, returns to DeskTop.  This
        is important for chaining program segments.
     9) Files opened with FCBs are not automatically closed.
    10) Supported in PC-MOS/386 compatibility mode, but not available
        for native MOS 386-mode applications.


Function  01h     Get Keyboard Input
        Waits for char at STDIN (if necessary), echoes to STDOUT
entry   AH      01h
return  AL      ASCII character from STDIN (8 bits)
note 1) Checks char for Ctrl-C, if char is Ctrl-C, executes int 23h.
     2) For function call 06h, extended ASCII codes require two
        function calls.  The first call returns 00h as an indicator
        that the next call will be an extended ASCII code.
     3) Input and output are redirectable.  If redirected, there is
        no way to detect EOF.
     4) TOS: $1 CONIN.  Char returns in D0. ASCII code of char in
        high byte, keyboard scan code in low byte.  Will return
        scancode on keys which have no ASCII value.


Function  02h   Display Output
      Outputs char in DL to STDOUT
entry   AH      02h
        DL      8 bit data (usually ASCII character)
return  none
note 1) If char is 08 (backspace) the cursor is moved 1 char to the
        left (nondestructive backspace).
     2) If Ctrl-C is detected after input, int 23h is executed.
     3) Input and output are redirectable.  If redirected, there is no
        way to detect disk full.
     4) TOS: $2 CONOUT.  Char must be placed on the stack as the first
        word.  The ASCII value of the char goes in the low byte and
        the high byte is zero.  Chars are output to DEVICE #2, normal
        console output.  Control characters and escape sequences are
        interpreted normally.
     5) Under DOS 1.x, 02h sends a character to the active display.
        Under DOS 2.x and later, the char goes to STDOUT.


Function  03h   Auxiliary Input
      Get (or wait until) character from STDAUX
entry   AH      03h
return  AL      ASCII char from auxiliary device
note 1) AUX, COM1, COM2 is unbuffered and not interrupt driven.
     2) This function call does not return status or error codes.
        For greater control it is recommended that you use the ROM BIOS
        routines (int 14h) or write an AUX device driver and use IOCTL.
     3) At startup, PC-DOS initializes the first auxiliary port (COM1)
        to 2400 baud, no parity, one stop bit, and an 8-bit word.
        Versions of MSDOS may differ.
     4) If Ctrl-C is has been entered from STDIN, int 23h is executed.
     5) TOS: $03 AUXILIARY INPUT.  Function returns when the character
        has been received.  Char is returned in the low byte of D0.
     6) Under DOS 1.x, the character is read from COM1.  Under DOS
        2.x and later, it is read from STDAUX.


Function  04h   Auxiliary Output
      Write character to STDAUX
entry   AH      04h
        DL      ASCII char to send to AUX
return  none
note 1) This function call does not return status or error codes.
        For greater control it is recommended that you use the ROM
        BIOS routine (int 14h) or write an AUX device driver and use
        IOCTL.
     2) If Ctrl-C is has been entered from STDIN, int 23h is executed.
     3) Default is COM1 unless redirected by DOS.
     4) If the device is busy, this function will wait until it is
        ready.
     5) TOS: $04 AUXILIARY OUTPUT.  High byte should be zero, low byte
        is ASCII code.
     6) Under DOS 1.x, the character is sent to COM1.  Under DOS 2.x
        and later, it goes to STDAUX.


Function  05h   Printer Output
      Write character to STDPRN
entry   AL      05h
        DL      ASCII code for character to send
return  none
note 1) If Ctrl-C is has been entered from STDIN, int 23h is executed.
     2) Default is PRN or LPT1 unless redirected with the MODE command.
     3) If the printer is busy, this function will wait until it is
        ready.
     5) TOS: $05 PRINTER OUTPUT.  High byte of D0 is zero, low byte is
        character.  Returns -1 if character is sent successfully.
        Times out after 30 seconds and resets D0 to zero.
     6) Under DOS 1.x, this function writes to LPT1.  Under DOS 2.x
        and higher it writes to STDPRN.


Function  06h   Direct Console I/O
      Get character from STDIN; echo character to STDOUT
entry   AH      06h
        DL      0FFh for console input, or 00h-0FEh for console output
return  ZF      set     no character available
                clear   character recieved
        AL      ASCII code for character
note 1) Extended ASCII codes require two function calls.  The first
        call returns 00h to indicate the next call will return an
        extended code.
     2) If DL is not 0FFh, DL is assumed to have a valid character
        that is output to STDOUT.
     3) This function does not check for Ctrl-C or Ctrl-PrtSc.
     4) Does not echo input to screen.
     5) If I/O is redirected, EOF or disk full cannot be detected.
     6) TOS: $06 RAWCONIO.  Get character from keyboard by calling
        with $FF in D0.  ASCII and scan codes are returned as per
        CONIN.  If a value other than $FF is used, it is printed to
        STDOUT at the current cursor position.  This call interprets
        all control chars and escape sequences.
     7) Under DOS 1.x, this call handles the keyboard and display
        directly.  Under DOS 2.x and later, calls are routed to the
        STDOUT driver.


Function  07h   Direct Console Input Without Echo
      Get or wait for char at STDIN, returns char in AL
      (does not check BREAK)
entry   AH      07h
return  AL      ASCII character from standard input device
note 1) Extended ASCII codes require two function calls.  The first
        call returns 00h to indicate the next call will return an
        extended code.
     2) No checking for Ctrl-C or Ctrl-PrtSc is done.
     3) Input is redirectable.
     4) TOS: $07 DIRECT CONIN WITHOUT ECHO.  Same as function 01h
        only does not echo character to screen.
     5) Under DOS 1.x the keyboard is read directly.  Under DOS 2.x
        and later the STDIN is polled.


Function  08h   Console Input Without Echo
       Get or Wait for char at STDIN, return char in AL
       (checks BREAK)
entry   AH      08h
return  AL      char from standard input device
note 1) Char is checked for ctrl-C. If ctrl-C is detected, executes
        int 23h.
     2) For function call 08h, extended ASCII characters require two
        function calls.  The first call returns 00h to signify an
        extended ASCII code.  The next call returns the actual code.
     3) Input is redirectable.  If redirected, there is no way to
        check EOF.
     4) TOS: $08 CONIN WITHOUT ECHO.  Same as previous call. (no
        checking for control characters).
     5) Under DOS 1.x the keyboard is read directly.  Under DOS 2.x
        and later the STDIN is polled.


Function  09h   Print String
      Outputs Characters in the Print String to the STDOUT
entry   AH      09h
        DS:DX   pointer to the Character String to be displayed
return  none
note 1) The character string in memory must be terminated by a $
        character. (ASCII 24h)
     2) The $ is not displayed but remains in AL forever unless popped.
     3) Output to STDOUT is the same as function call 02h.
     4) TOS: $09 PRINT LINE.  The address of the ASCIIZ string is
        placed on the stack as a parameter and is printed at the
        current cursor position.  There is no limit to the size of the
        string.  D0 contains the number of characters to be printed.
        Control and escape codes are evaluated.
     5) Under DOS 1.x, this function writes to the screen.  Under DOS
        2.x and higher it writes to STDOUT.


Function  0Ah   Buffered Keyboard Input
      Reads characters from STDIN and places them in the buffer
      beginning at the third byte.
entry   AH      0Ah
        DS:DX   pointer to an input buffer
return  none
note 1) Min buffer size = 1, max = 255.
     2) Char is checked for ctrl-C. If ctrl-C is detected, executes
        int 23h.
     3) Format of buffer DX:
        byte       contents
         1      Maximum number of chars the buffer will take,
                including CR.  Reading STDIN and filling the buffer
                continues until a carriage return (<Enter> or 0Dh) is
                read.  If the buffer fills to one less than the maximum
                number the buffer can hold, each additional number read
                is ignored and ASCII 7 (BEL) is output to the display
                until a carriage return is read. (you must set this
                value)
         2      Actual number of characters received, excluding the
                carriage return, which is always the last character.
                (the function sets this value)
         3-n    Characters received are placed into the buffer
                starting here.  Buffer must be at least as long as the 
                number in byte 1.
         n+1    Carriage return character (0Dh).
     4) Input is redirectable.  If redirected, there is no way to
        check EOF.
     5) The string may be edited with the standard DOS editing
        commands as it is being entered.
     6) Extended ASCII characters are stored as 2 bytes, the first
        byte being zero.
     7) TOS: $0A READLINE.  Fetches CR-terminated line from CONIN.
        The address of the buffer is passed as a parameter.  Byte 1
        is the maximum length of the line, byte 2 is the number of
        characters entered, byte 3 is the first character.  Escape
        codes are not interpreted, but the normal editing control
        characters are.
     8) Under DOS 1.x the keyboard is read directly.  Under DOS 2.x
        and later the STDIN is polled.


Function  0Bh   Check Standard Input (STDIN) status
      Checks for character available at STDIN
entry   AH      0Bh
return  AL      00h     if no character is available from STDIN
                0FFh    if a character is available from STDIN
note 1) Checks for Ctrl-C. If Ctrl-C is detected, int 23h is executed.
     2) Input can be redirected.
     3) Checks for character only, it is not read into the application.
     4) IBM reports that this call does not work properly under the
        DOSSHELL program in DOS 4.00 and 4.01.  DOSSHELL will return
        all zeroes.  This function works correctly from the command
        line or application.
     5) TOS: $0B CONSTAT.  Checks 64-byte OS input buffer.
     6) Under DOS 1.x, the type-ahead buffer is checked.  Under DOS
        2.x and later, the type-ahead buffer is checked unless STDIN
        has been redirected.


Function  0Ch   Clear Keyboard Buffer & Invoke a Keyboard Function
      Dumps buffer, executes function in AL                  (FCB)
entry   AH      0Ch
        AL      function number (must be 01h, 06h, 07h, 08h, or 0Ah)
                note: the DOS 5.0 TR specifies 0Ah as reserved and
                       "must not be used"
return  AL      00h     buffer was flushed, no other processing
                        performed
                other   any other value has no meaning
note 1) Forces system to wait until a character is typed.
     2) Flushes all typeahead input, then executes function specified
        by AL (by moving it to AH and repeating the int 21 call).
     3) If AL contains a value not in the list above, (such as 00h)
        the input buffer is flushed and no other action is taken.  Note
        that this is the STDIN buffer, not the actual keyboard buffer.
        The keyboard buffer will not be flushed if input is redirected.
     4) Under DOS 1.x, the type-ahead buffer is emptied before the
        function in AL is performed.


Function  0Dh   Disk Reset
      Flushes all currently open file buffers to disk
entry   AH      0Dh
return          none
note 1) Does not close files.  Does not update directory entries;
        files changed in size but not closed are not properly
        recorded in the directory.
     2) Sets DTA address to DS:0080h
     3) Should be used before a disk change, Ctrl-C handlers, and to
        flush the buffers to disk.
     4) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     5) IBM TopView saves DTA information during task switches.


Function  0Eh   Select Disk
      Sets the drive specified in DL (if valid) as the default drive
entry   AL      0Eh
        DL      new default drive number (0=A:,1=B:,2=C:,etc.)
return  AL      number of physical drives found unless LASTDRIVE= is
                included in CONFIG.SYS and specifies a higher number
                than that of the last physical drive.
note 1) For DOS 1.x and 2.x, the minimum value for AL is 2.
     2) For DOS 3.x and 4.x, the minimum value for AL is 5.
     3) The drive number returned is not necessarily a valid drive.
     4) For DOS 1.x: 16 logical drives are available, A-P. (0-0Fh) 
        For DOS 2.x: 63 logical drives are available. (Letters are only
                     used for the first 26 drives.  If more than 26
                     logical drives are used, further drive letters
                     will be other ASCII characters, such as {, ],
                     etc. (0-3Fh)
        For DOS 3.x, +: 26 logical drives are available, A-Z. (0-19h)
     5) TOS: $0E SETDRV.  A 16-bit parameter with drivespec is passed
        to TOS.  On exit, D0 contains the number of the drive active
        before the call. (not the total number of drives)
     6) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     7) For DOS 3.3, LASTDRIVE= is not needed when accessing
        additional hard disk partitions past E:.  I haven't done any
        further checking, but it seems that LASTDRIVE= may be fairly
        useless to most programs.
     6) IBM TopView saves DTA information during task switches.


Function  0Fh   Open Disk File                                  (FCB)
      Searches current directory for specified filename and places
      relevantinformation into the File Control Block.
entry   AH      0Fh
        DS:DX   pointer to an unopened FCB
return  AL      00h     if file found
                0FFh    if file not not found
note 1) If the drive code was 0 (default drive) it is changed to the
        actual drive used (1=A:,2=B:,3=C:, etc).  This allows changing
        the default drive without interfering with subsequent
        operations on this file.
     2) The current block field (FCB bytes C-D, offset 0Ch) is set to
        zero.
     3) The size of the record to be worked with (FCB bytes E-F, offset
        0Eh) is set to the system default of 80h.  The size of the file
        (offset 10h) and the date (offset 14h) are set from information
        obtained in the root directory.  You can change the default
        value for the record size (FCB bytes E-F) or set the random
        record size and/or current record field.  Perform these actions
        after the open but before any disk operations.
     4) With DOS 3.x the file is opened in compatibility mode.
        (network)
     5) Microsoft recommends handle function call 3Dh be used instead.
     6) This call is also used by the APPEND command in DOS 3.2 and 
        higher.
     7) Before performing a sequential disk operation on the file, you
        must set the Current Record field (offset 20h).  Before
        performing a random disk operation on the file, you must set
        the Relative Record field (offset 21h).  If the default record
        size of 128 bytes is incorrect, set it to the correct value.


Function  10h  Close File                                     (FCB)
     Closes a File After a File Write
entry   AH      10h
        DS:DX   pointer to an opened FCB
return  AL      00h     if the file is found and closed
                0FFh    if the file is not found in the current
                        directory
note 1) This function call must be done on open files that are no
        longer needed, and after file writes to insure all directory
        information is updated.
     2) If the file is not found in its correct position in the current
        directory, it is assumed that the diskette was changed and AL
        returns 0FFh.  This error return is reportedly not completely
        reliable with DOS version 2.x.
     3) If found, the directory is updated to reflect the status in the
        FCB, the buffers to that file are flushed, and AL returns 00h.
     4) There is a subtle but dangerous quirk to this function.  If a
        Close request is issued using a File Control Block that has
        not been previously activated by a successful Open command, the
        file's length will be truncated to zero and the clusters
        previously assigned to the file are left floating. (lost 
        clusters)
     5) This function works for files in the current directory only.
     6) For DOS 3.1 and later, files opened with this call are set to
        compatibility mode and the access code is set to read/write.
     7) For DOS 3.0 and later, int 21h fn 59h (Get Extended Error
        Information) may be used to determine errors.


Function  11h   Search For First Matching Entry                  (FCB)
      Searches current disk & directory for first matching filename
entry   AH      11h
        DS:DX   pointer to address of FCB
return  AL      00h     successful match
                0FFh    no matching filename found
note 1) The FCB may contain the wildcard character ? under DOS 2.x,
        and ? or * under 3.x and later.
     2) The original FCB at DS:DX contains information to continue the
        search with function 12h, and should not be modified.
     3) If a matching filename is found, AL returns 00h and the
        locations at the Disk Transfer Address are set as follows:
        a) If the FCB provided for searching was an extended FCB, then
           the first byte at the disk transfer address is set to 0FFh
           followed by 5 bytes of zeroes, then the attribute byte from
           the search FCB, then the drive number used (1=A, 2=B, etc)
           then the 32 bytes of the directory entry.  Thus, the disk
           transfer address contains a valid unopened FCB with the same
           search attributes as the search FCB.
        b) If the FCB provided for searching was a standard FCB, then
           the first byte is set to the drive number used (1=A, 2=b,
           etc), and the next 32 bytes contain the matching directory
           entry.  Thus, the disk transfer address contains a valid
           unopened normal FCB.
     4) If an extended FCB is used, the following search pattern is
        used:
        a) If the FCB attribute byte is zero, only normal file entries
           are found.  Entries for volume label, subdirectories, hidden
           or system files, are not returned.
        b) If the attribute byte is set for hidden or system files, or
           subdirectory entries, it is to be considered as an inclusive
           search.  All normal file entries plus all entries matching
           the specified attributes are returned.  To look at all
           directory entries except the volume label, the attribute byte
           may be set to hidden + system + directory (all 3 bits on).
        c) If the attribute field is set for the volume label, it is
           considered an exclusive search, and ONLY the volume label
           entry is returned.
     5) This call is also used by the APPEND command in DOS 3.2+


Function  12h   Search For Next Entry Using FCB                 (FCB)
      Search for next matching filename
entry   AH      12h
        DS:DX   pointer to the unopened FCB specified from the previous
                Search
                First (11h) or Search Next (12h)
return  AL      00h     if matching filename found
                0FFh    if matching filename was not found
note 1) After a matching filename has been found using function call
        11h, function 12h may be called to find the next match to an
        ambiguous request.  For DOS 2.x, ?'s are allowed in the
        filename.  For DOS 3.x and 4.x, global (*) filename characters
        are allowed.
     2) The DTA contains info from the previous Search First or Search
        Next.
     3) Do not perform any disk operations with this FCB between a
        previous function 11h or 12h call and this one.  "Undocumented"
        fields in the FCB are used to keep information necessary for
        continuing the search, and some disk operations may overwrite
        these areas.
     4) If the file is found, an FCB is created at the DTA address and
        set up to open or delete it.


Function  13h   Delete File Via FCB                              (FCB)
      Deletes file specified in FCB from current directory
entry   AH      13h
        DS:DX   pointer to address of FCB
return  AL      00h     file deleted
                0FFh    if file not found or was read-only
note 1) All matching current directory entries are deleted. The global
        filename character "?" is allowed in the filename.
     2) Will not delete files with read-only attribute set.
     3) Close open files before deleting them.
     4) For DOS 3.1+, requires network Create rights to the sub-
        directory.
     5) This call supports wildcards and is very fast.  The "new"
        handle call 41h is supposed to replace this one since it knows
        about subdirectories.  Unfortunately, fn 41h doesn't know about
        wildcards.


Function  14h   Sequential Disk File Read                         (FCB)
      Reads record sequentially from disk via FCB
entry   AH  14h
        DS:DX   pointer to an opened FCB
return  AL      00h     successful read
                01h     end of file (no data read)
                02h     Data Transfer Area too small for record size
                        specified or segment overflow
                03h     partial record read, EOF found
note 1) The record size is set to the value at offset 0Eh in the FCB.
     2) The record pointed to by the Current Block (offset 0Ch) and the
        Current Record (offset 20h) fields is loaded at the DTA, then
        the Current Block and Current Record fields are incremented.
     3) The record is read into memory at the current DTA address as
        specified by the most recent call to function 1Ah.  If the size
        of the record and location of the DTA are such that a segment
        overflow or wraparound would occur, the error return is set to
        AL=02h.
     4) If a partial record is read at the end of the file, it is passed
        to the requested size with zeroes and the error return is set to
        AL=03h.
     5) For DOS 3.1+ networks, requires Read rights to the subdirectory.


Function  15h   Sequential Disk Write                              (FCB)
      Writes record specified by FCB sequentially to disk
entry   AH      15h
        DS:DX   pointer to address of FCB
return  AL      00h     successful write
                01h     diskette full, write canceled
                02h     disk transfer area (DTA) too small or segment
                        wrap
note 1) The data to write is obtained from the disk transfer area.
     2) The record size is set to the value at offset 0Eh in the FCB.
     3) This service cannot write to files set as read-only.
     4) The record pointed to by the Current Block (offset 0Ch) and the
        Current Record (offset 20h) fields is loaded at the DTA, then
        the Current Block and Current Record fields are incremented.
     5) If the record size is less than a sector, the data in the DTA
        is written to a buffer; the buffer is written to disk when it
        contains a full sector of data, the file is closed, or a Reset
        Disk (function 0Dh) is issued.
     6) The record is written to disk at the current DTA address as
        specified by the most recent call to function 1Ah.  If the size
        of the record and location of the DTA are such that a segment
        overflow or wraparound would occur, the error return is set to
        AL=02h.
     5) For DOS 3.1+ networks, requires Write rights to the subdirectory.


Function  16h   Create A Disk File                                (FCB)
      Search and open or create directory entry for file
entry   AH      16h
        DS:DX   pointer to an FCB
return  AL      00h     successful creation
                0FFh    no room in directory
note 1) If a matching directory entry is found, the file is truncated
        to zero bytes.
     2) If there is no matching filename, a filename is created.
     3) This function calls function 0Fh (Open File) after creating or
        truncating a file.
     4) A hidden file can be created by using an extended FCB with the
        attribute byte (offset FCB-1) set to 2.
     5) The corresponding handle call is 3Ch.
     6) For DOS 3.1+ networks, requires  Create rights to the sub-
        directory.
     7) For DOS 3.0 and later, int 21h function 59h (Get Extended Error
        Information) may be used to determine errors.
     8) Pathnames and wildcards are not supported.


Function  17h   Rename File Specified by File Control Block       (FCB)
      Renames file in current directory
entry   AH      17h
        DS:DX   pointer to an FCB (see note 4)
return  AL      00h     successfully renamed
                0FFh    file not found or filename already exists
note 1) This service cannot rename read-only files.
     2) The "?" wildcard may be used.
     3) If the "?" wildcard is used in the second filename, the
        corresponding letters in the filename of the directory entry are
        not changed.
     4) A special modified FCB is used. It must have a drive number,
        filename, and extension in the usual position, and a second
        filename starting 6 bytes after the first, at offset 11h.  This
        is normally a "reserved" area.
        Modified FCB format:
        bytes           contents
        00h       drive number
        01h-08h   old filename (blank padded if required)
        09h-0Bh   old file extension (blank padded if reqired)
        0Ch-10h   zeroed out
        11h-18h   new filename (blank padded if required)
        19h-1Bh   new file extension (blank padded if required)
        1Ch-24h   zeroed out
     5) The two filenames cannot have the same name.
     6) FCB contains new name starting at byte 17h.
     7) Under DOS 2.0+, subdirectories may be renamed with this call.


Function  18h  Unknown - reportedly not used
entry   AH      18h
return  AL      00h


Function  19h   Get Current Disk Drive
      Return designation of current default disk drive
entry   AH      19h
return  AL      current default drive (0=A, 1=B,etc.)
note 1) Some other DOS functions use 0 for default, 1=A, 2=B, etc.
     2) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     3) TOS: $19 CURRENT DISK. D0 returns number of drive (0=A:)


Function  1Ah   Set Disk Transfer Area Address (DTA)
      Sets DTA address to the address specified in DS:DX.
      Required for functions 4Eh and 4Fh.
entry   AH      1Ah
        DS:DX   pointer to DTA buffer
return  none
note 1) The default DTA is 128 bytes at offset 80h in the PSP.  You may
        set up your own DTA with any size and location.  The DTA should
        be large enough to handle the largest record you intend to write.
     2) Registers are unchanged.
     3) No error codes are returned.
     4) Disk transfers cannot wrap around from the end of the segment
        to the beginning or overflow into another segment.
     5) DOS uses the DTA for file I/O. (see Chapter 6)
     6) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     7) TOS: $1A SET DISK TRANSFER ADDRESS. Sets up a 44-byte buffer for
        disk operations.
     8) PC-MOS/386: not supported for native 386 mode MOS applications.


Function  1Bh   Get Current Drive File Allocation Table Information
      Returns information from the FAT on the current drive
entry   AH      1Bh
return  AL      number of sectors per allocation unit (cluster)
        CX      number of bytes per sector
        DS:BX   address of the current drive's media descriptor byte
        DX      number of allocation units (clusters) for default drive
note 1) Save DS before calling this function.
     2) This call returned a pointer to the FAT in DOS 1.x.  Beginning
        with DOS 2.00, it returns a pointer only to the table's ID byte.
     3) IBM recommends programmers avoid this call and use int 25h
        instead.
     4) Offset DS:[BX-1] is the dirty byte for the table: 00=clean,
        01=dirty.
     5) DOS 2.x+ and above do not keep the FAT in RAM.  Do not use this
        call to access the FAT.  Function 36 is preferred.
     6) If unsuccessful, AL returns with 0FFh.


Function  1Ch   Get File Allocation Table Information for Drive
      Returns information on specified drive
entry   AH      1Ch
        DL      drive number (1=A, 2=B, 3=C, etc)
return  AL      number of sectors per allocation unit (cluster)
                0FFh    invalid drive specification
        DS:BX   address of media descriptor byte for drive in DL
        CX      sector size in bytes
        DX      number of allocation units (clusters)
note 1) Set DL = 0 for default.
     2) Save DS before calling this function.
     3) Format of media-descriptor byte:
        bits:   0       0   (clear)   not double sided
                        1   (set)     double sided
                1       0   (clear)   not 8 sector
                        1   (set)     8 sector
                2       0   (clear)   nonremovable device
                        1   (set)     removable device
                3-7     always set (1)
     4) This call returned a pointer to the FAT in DOS 1.x.  Beginning
        with DOS 2.00, it returns a pointer only to the table's ID byte.
     5) IBM recommends programmers avoid this call and use int 25h
        instead.
     6) This function reads the BPB only and is very fast.
     7) If unsuccessful, AL returns with 0FFh.
     8) PC-MOS/386: native mode should use DS:EBX instead of DS:BX.


Function  1Dh   Not Documented by Microsoft
 *    Unknown - reportedly not used
entry   AH      1Dh
return  AL      00h


Function  1Eh   Not Documented by Microsoft
 *    Unknown - reportedly not used
entry   AH      1Eh
return  AL      00h
note    Apparently does nothing.


Function  1Fh   Get Default Drive Parameter Block
    Same as function call 32h (below), except that the table is
    accessed from the default drive
entry   AH      1Fh
        other registers unknown
return  AL      00h     no error
                0FFh    error
        DS:BX   pointer to DOS Disk Parameter Block for default drive.
note    For DOS 2, 3, 4.x, this just invokes function 32h (Read DOS
        Disk Block) with DL=0.


Function  20h  Unknown
 *   Internal - does nothing?
entry   AH      20h
return  AL      00h


Function  21h  Random Read from File Specified by File Control Block (FCB)
     Reads one record as specified in the FCB into the current DTA.
entry   AH      21h
        DS:DX   address of the opened FCB
return  AL      00h     successful read operation
                01h     end of file (EOF), no data read
                02h     DTA too small for the record size specified
                03h     end of file (EOF), partial data read
note 1) The current block and current record fields are set to agree
        with the random record field.  Then the record addressed by
        these fields is read into memory at the current Disk Transfer
        Address.
     2) The current file pointers are NOT incremented this function.
     3) If the DTA is larger than the file, the file is padded to the
        requested length with zeroes.


Function  22h  Random Write to File Specified by FCB              (FCB)
     Writes one record as specified in the FCB to the current DTA
entry   AH      22h
        DS:DX   address of the opened FCB
return  AL      00h     successful write operation
                01h     disk full; no data written (write was canceled)
                02h     DTA too small for the record size specified
                        (write was canceled)
note 1) This service cannot write to read-only files.
     2) The record pointed to by the Current Block (offset 0Ch) and the
        Current Record (offset 20h) fields is loaded at the DTA, then
        the Current Block and Current Record fields are incremented.
     3) If the record size is less than a sector, the data in the DTA is
        written to a buffer; the buffer is written to disk when it
        contains a full sector of data, the file is closed, or a Reset
        Disk (function 0Dh) is issued.
     4) The current file pointers are NOT incremented this function.
     5) The record is written to disk at the current DTA address as
        specified by the most recent call to function 1Ah.  If the size
        of the record and location of the DTA are such that a segment
        overflow or wraparound would occur, the error return is set to
        AL=02h.
     6) Under networks running DOS 3.1 or later, the user must have
        Write access rights to the subdirectory.


Function  23h  Get File Size                                       (FCB)
     Searches current subdir for matching file, returns size in FCB
entry   AH      23h
        DS:DX   address of an unopened FCB
return  AL      00h file found
                0FFh file not found
note 1) Record size field (offset 0Eh) must be set before invoking this
        function.
     2) The disk directory is searched for the matching entry.  If a
        matching entry is found, the random record field is set to the
        number of records in the file.  If the value of the Record Size
        field is not an even divisor of the file size, the value set in
        the relative record field is rounded up.  This gives a returned
        value larger than the actual file size.
     3) This call is used by the APPEND command in DOS 3.2+.
     4) Record numbers start with zero.


Function  24h  Set Relative Record Field                           (FCB)
     Set random record field specified by an FCB
entry   AH      24h
        DS:DX   address of an opened FCB
return  Random Record Field of FCB is set to be same as Current Block
        and Current Record.
note 1) You must invoke this function before performing random file
        access.
     2) The relative record field of FCB (offset 21h) is set to be same
        as the Current Block (offset 0Ch) and Current Record (offset
        20h).
     3) No error codes are returned.
     4) The FCB must already be opened.


Function  25h  Set Interrupt Vector
entry   AH      25h
        AL      interrupt number to reassign the handler to
        DS:DX   address of new interrupt vector
return  none
note 1) Registers are unchanged.
     2) No error codes are returned.
     3) The interrupt vector table for the interrupt number specified
        in AL is set to the address contained in DS:DX.  Use function
        35h (Get Vector) to get the contents of the interrupt vector
        and save it for later use.
     4) When you use function 25 to set an interrupt vector, DOS 3.2
        doesn't point the actual interrupt vector to what you requested.
        Instead, it sets the interrupt vector to point to a routine
        inside DOS, which does this:
                1. Save old stack pointer
                2. Switch to new stack pointer allocated from DOS's
                   stack pool
                3. Call your routine
                4. Restore old stack pointer
        The purpose for this was to avoid possible stack overflows when
        there are a large number of active interrupts.  IBM was
        concerned (this was an IBM change, not Microsoft) that on a
        Token Ring network there would be a lot of interrupts going on,
        and applications that hadn't allocated very much stack space
        would get clobbered.
     5) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     6) This call is used to access the Phar Lap DOS extender's
        protected mode functions.  The Phar Lap function number is
        placed in AL.


Function  26h  Create New Program Segment Prefix (PSP)
     This service copies the current program-segment prefix to a new
     memory location for the creation of a new program or overlay.
     Once the new PSP is in place, a DOS program can read a DOS .COM
     or overlay file into the memory location immediately following
     the new PSP and pass control to it.
entry   AH      26h
        DX      segment number for the new PSP
return  Current PSP is copied to specified segment
note 1) Microsoft recommends you use the newer DOS service 4Bh (EXEC)
        instead.
     2) The entire 100h area at location 0 in the current PSP is copied
        into location 0 of the new PSP.  The memory size information at
        location 6 in the new segment is updated and the current
        termination, ctrl-break, and critical error addresses from the
        interrupt vector table entries for ints 22h, 23h, and 24 are
        saved in the new program segment starting at 0Ah.  They are
        restored from this area when the program terminates.
     3) The PSP structure is found in Chapter 6.


Function  27h  Random Block Read From File Specified by FCB
     Similar to 21h (Random Read) except allows multiple files to be
     read.
entry   AH      27h
        CX      number of records to be read
        DS:DX   address of an opened FCB
return  AL      00h     successful read
                01h     end of file, no data read
                02h     DTA too small for record size specified
                        (read canceled)
                03h     end of file
        CX      actual number of records read (includes partial if
                AL=03h)
note 1) The record size is specified in the FCB.  The service updates
        the Current Block (offset 0Ch) and Current Record (offset 20h)
        fields to the next record not read.
     2) If CX contained 0 on entry, this is a NOP.
     3) If the DTA is larger than the file, the file is padded to the
        requested length with zeroes.
     4) This function assumes that the FCB record size field (0Eh) is
        correctly set.  If not set by the user, the default is 128
        bytes.
     5) The record is written to disk at the current DTA address as
        specified by the most recent call to function 1Ah.  If the size
        of the record and location of the DTA are such that a segment
        overflow or wraparound would occur, the error return is set to
        AL=02h.
     6) Under networks running DOS 3.1 or later, the user must have
        Read access rights to the subdirectory.


Function  28h  Random Block Write to File Specified in FCB
     Similar to 27h (Random Write)     
entry   AH      28h
        CX      number of records to write
        DS:DX   address of an opened FCB
return  AL      00h     successful write
                01h     disk full, no data written
                02h     DTA too small for record size specified
                        (write canceled)
        CX      number of records written
note 1) The record size is specified in the FCB.
     2) This service allocates disk clusters as required.
     3) This function assumes that the FCB Record Size field (offset
        0Eh) is correctly set.  If not set by the user, the default is
        128 bytes.
     4) The record size is specified in the FCB.  The service updates
        the Current Block (offset 0Ch) and Current Record (offset 20h)
        fields to the next record not read.
     5) The record is written to disk at the current DTA address as
        specified by the most recent call to function 1Ah.  If the size
        of the record and location of the DTA are such that a segment
        overflow or wraparound would occur, the error return is set to
        AL=02h.
     6) If called with CX=0, no records are written, but the FCB's File
        Size entry (offset 1Ch) is set to the size specified by the
        FCB's Relative Record field (offset 21h).
     7) Under networks running DOS 3.1 or later, the user must have
        Write access rights to the subdirectory.


Function  29h  Parse the Command Line for Filename
     Parses a text string into the fields of a File Control Block
entry   AH      29h
        AL      bit mask to control parsing
            bit 0    0     parsing stops if file seperator found
                     1     causes service to scan past leading chars
                           such as blanks.  Otherwise assumes the
                           filename begins in the first byte
                1    0     drive number in FCB set to default (0) if 
                           the string contains no drive number
                     1     drive number in FCB not changed
                2    0     filename in FCB set to 8 blanks if no
                           filename in string
                     1     filename in FCB not changed if string does
                           not contain a filename
                3    0     extension in FCB set to 3 blanks if no
                           extension in string
                     1     extension left unchanged
                4-7  must be zero
        DS:SI   pointer to string to parse
        ES:DI   pointer to memory buffer to fill with unopened FCB
return  AL      00h     no wildcards in name or extension
                01h     wildcards appeared in name or extension
                0FFh    invalid drive specifier
        DS:SI   pointer to the first byte after the parsed string
        ES:DI   pointer to a buffer filled with the unopened FCB
note 1) If the * wildcard characters are found in the command line, this
        service will replace all subsequent chars in the FCB with
        question marks.
     2) This service uses the characters as filename separators
        DOS 1       : ; . , + / [ ] = " TAB SPACE
        DOS 2,3,4   : ; . , + = TAB SPACE
     3) This service uses the characters
        : ; . , + < > | / \ [ ] = " TAB SPACE
        or any control characters as valid filename separators.
     4) A filename cannot contain a filename terminator.  If one is
        encountered, all processing stops.  The handle functions will
        allow use of some of these characters.
     5) If no valid filename was found on the command line, ES:DI +1
        points to a blank (ASCII 32).
     6) This call will not handle pathnames.
     7) Parsing is in the form D:FILENAME.EXT.  If one is found, a
        corresponding unopened FCB is built at ES:DI.


Function  2Ah  Get Date
     Returns day of the week, year, month, and date
entry   AH      2Ah
return  CX      year    (1980-2099)
        DH      month   (1-12)
        DL      day     (1-31)
        AL      weekday 00h     Sunday
                        01h     Monday
                        02h     Tuesday
                        03h     Wednesday
                        04h     Thursday
                        05h     Friday
                        06h     Saturday
note 1) Date is adjusted automatically if clock rolls over to the next
        day, and takes leap years and number of days in each month into
        account.
     2) Although DOS cannot set an invalid date, it can read one, such
        as 91/32/80, etc.
     3) DESQview's DOS subfunctions also accept CX = 4445h and DX =
        5351h, i.e. 'DESQ' as valid.
     4) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     5) DOS will accept CH=0 (midnight) as a valid time.  Through DOS
        3.31, if a file's time is set to within 2 seconds of midnight
        the time will not be displayed by the DIR command.  For DOS
        4.0+ and DR-DOS the creation time will always be displayed.
     6) TOS: $2A GET DATE.


Function  2Bh  Set Date
     set current system date
entry   AH      2Bh
        CX      year    (1980-2099)
        DH      month   (1-12)
        DL      day     (1-31)
return  AL      00h     no error (valid date)
                0FFh    invalid date specified
note 1) On entry, CX:DX must have a valid date in the same format as
        returned by function call 2Ah.
     2) DOS 3.3+ also sets CMOS clock.
     3) Under the DESQview system shell, this is the DV_GET_VERSION
        check:
        entry   AH      2Bh
                AL      01h     DESQ call
                CX      4445h   'DE'               (invalid date used
                DX      5351h   'SQ'                for DesQview ID)
        return  AH      major version
                AL      minor version
                AX      0FFh    DESQ not installed (DOS error code)
     4) For DESQview 2.00+, installation check
        entry   AH      2Bh
                AL      subfunction (DV v2.00+)
                        01h     Get Version
        return  BX      version (BH = major, BL = minor)
        note    Early copies of v2.00 return 0002h.
                        02h     Get Shadow Buffer Info, and Start
                                Shadowing
        return  BH      rows in shadow buffer
                BL      columns in shadow buffer
                DX      segment of shadow buffer
                        04h     Get Shadow Buffer Info
        return  BH      rows in shadow buffer
                BL      columns in shadow buffer
                DX      segment of shadow buffer
                        05h     Stop Shadowing
                CX      4445h ('DE')
                DX      5351h ('SQ')
        return  AL      0FFh    if DESQview not installed
        note    In DESQview v1.x, there were no subfunctions; this
                call only identified whether or not DESQview was loaded.
     5) PC-Tools PC-Cache 5.1 (Multisoft cache) installation check.
        entry   CX      4358h ('CX')
        return  AL      00h     installed
                                CX      6378h
                        0FFh    not installed
     6) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     7) TOS: GET DATE.


Function  2Ch  Get Time
     Get current system time from CLOCK$ driver
entry   AH      2Ch
return  CH      hours   (0-23)
        CL      minutes (0-59)
        DH      seconds (0-59)
        DL      hundredths of a second (0-99)
note 1) Time is updated every 5/100 second.
     2) The date and time are in binary format.
     3) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     4) TOS: GET TIME.


Function  2Dh  Set Time
     Sets current system time
entry   AH      2Dh
        CH      hours   (0-23)
        CL      minutes (0-59)
        DH      seconds (0-59)
        DL      hundredths of seconds (0-99)
return  AL      00h     if no error
                0FFh    if bad value sent to routine
note 1) DOS 3.3+ also sets CMOS clock.
     2) CX and DX must contain a valid time in binary.
     3) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     4) TOS: SET TIME.


Function  2Eh  Set/Reset Verify Switch
     Set verify flag
entry   AH      2Eh
        AL      00      to turn verify off (default)
                01      to turn verify on
        DL      00h     (DOS 1.x and 2.x only, according to Microsoft's
                         MS-DOS Encyclopedia.  My IBM 2.0 and Intel 2.0
                         manuals don't show DL being used)
return  none
note 1) This is the call invoked by the DOS VERIFY command.
     2) The setting of the Verify switch can be obtained by calling
        function 54h.
     3) This call is not supported on network drives.
     4) DOS checks this flag each time it accesses a disk or block
        device.
     5) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.


Function  2Fh  Get Disk Transfer Address (DTA)
     Returns current DTA used by all DOS read/write operations
entry   AH      2Fh
return  ES:BX   address of DTA
note 1) The DTA is set by function call 1Ah
     2) Default DTA address is a 128 byte buffer at offset 80h in that
        program's Program Segment Prefix.
     3) See Chapter 6 for a description of the DTA.
     4) This call is explicitly supported in the OS/2 1.x
        Compatibility Box.
     5) TOS: GET DTA. Returns segment address of current DTA in D0.


Function  30h  Get DOS Version Number
     Return DOS version and/or user number
entry   AH      30h
 (5.0+) AL      00h     Get OEM ID number
                01h     Get version flag
return  AH      minor version number  (i.e., DOS 2.10 returns AX = 0A02h)
                                      (AH undefined for DOS 1.x)
        AL      major version number  (0 for DOS 1.x, 02h for 2.x, 05h
                                       for 5.x)

(DOS 2.0 through 4.01)
        BH      OEM ID number
                00h     IBM DOS
                16h     DEC DOS
                0FFh    MS-DOS (generic) (Also Toshiba DOS 5.0)

(DOS 5.0+ called with AL=00h)
        BH      OEM ID number
                (see above)

(DOS 5.0+ called with AL=01h)
        BH      version flag
                08h     DOS 5.0 or higher running out of ROM
                        (all other bits are reserved and set to zero)

        BL:CX   24-bit user serial number (optional, OEM dependent.
                If not used this field returns zeroes)
note 1) If AL returns a major version number of zero, the DOS version
        is below 1.28 for MSDOS and below 2.00 for PCDOS.
     2) IBM PC-DOS always returns 0000h in BX and CX, as does DR-DOS.
     3) Due to OS/2 returning version numbers over 10 and the fact
        that some European versions of DOS carried higher version
        numbers than IBM's DOS, utilities which check for a DOS version
        should not abort if a higher version than required is found
        unless some specific problems are known.
     4) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     5) TOS: $30 GET VERSION NUMBER.  Returns GEMDOS version number
        in D0.
     6) Under PC-MOS/386, if AX=BX=CX=DX, the PC-MOS/386 version number
        is returned.  If all registers to not hold the same value, an
        MSDOS equivalent version number is returned.  The PC-MOS/386
        version number is always different from the MSDOS version number.
     7) DOS version equivalents:
        3.20    PC-MOS/386 v3.0
        3.31    Digital Research DR-DOS 3.40, 3.41, 5.0, 6.0
        10      OS/2 v1.0 Compatibility Box  (major version number)
     8) DOS 5.0 adds the AL parameter to the command, but the ID number 
        returned in BL has been available since MSDOS 2.0, as
        documented by Intel's DOS 2.0 Technical Reference.
     9) DOS 5.0's SETVER command can modify the value returned in AX.
        You must use int 21h/3306h to obtain the true version number.
    10) OS/2 1.0's Compatibility Box returns version 10.  OS/2 1.1
        returns version 10.1, etc.  OS/2 2.0 returns version 20.
    11) If running in a Microsoft Windows 3.0 or later DOS box, the
        string "windir" will be in the DOS environment.  Note
        lowercase!
    12) It may sometimes be necessary to identify DOS-compatible
        operating systems or replacement command interpreters.  This
        doesn't appear to be a simple task.

        COMMAND.COM replacements:
        1) 4DOS can be identified with int 2Fh, fn 44DDh.
        2) Command Plus   (unknown)
        3) FlexShell      (unknown)

        DOS replacements:
        1) DR-DOS 3.4x has no easy way to be identified, which is a
           pity.  Though it has some MS4.0-like characteristics, it
           reports 3.31 with the DOS call, though VER will return
           whatever the DRDOS revision is.
           To identify DRDOS I've noted the following:
              The string "OS=" appears in the default 
                      environment (unless the user nulls it out)
              The OS= string is generated by COMMAND.COM and does not
                      appear when the user is running 4DOS as a command
                      interpreter.
              The internal DOS version call will report 3.31, but the
                      string returned by VER is at minimum 3.4.
             For DRDOS 3.x:
               SHARE and FASTOPEN are always loaded.
             For DRDOS 5 and 6:
               SHARE and FASTOPEN are NOT always loaded.
           The DR-DOS Programmer's Reference doesn't show a call to
                      identify DR-DOS specifically.
        2) PC-MOS/386: unknown. Fail an API call?
        3) Concurrent DOS: unknown. Fail an API call?
        4) DR Multiuser DOS inserts the string: OS=DRMDOS into the
                      environment.  Since DRMDOS doesn't allow
                      replacement of the command interpreter via the
                      SHELL= statement, OS= will be there unless nulled
                      by the user.

Function  31h  Terminate Process and Stay Resident      (KEEP)
entry   AH      31h
        AL      exit code
        DX      program memory requirement in 16 byte paragraphs
return  AX      return code (retrieveable by function 4Dh)
note 1) Files opened by the application are not closed when this call
        is made.
     2) Memory can be used more efficiently if the block containing the
        copy of the DOS environment is deallocated before terminating.
        This can be done by loading ES with the segment contained in 2Ch
        of the PSP and issuing function call 49h (Free Allocated Memory).
     3) Unlike int 27h, more than 64k may be made resident with this
        call.
     4) TOS: $31 KEEP PROCESS.
     5) Programs larger than 64k may be made resident with this call.
     6) For PC-MOS/386, tasks made resident with this call are subject
        to being swapped out of memory by the kernel for room to process
        other applications.  If your code needs to poll the keyboard or
        a port, you need to use a device driver instead.  PC-MOS does
        not swap device drivers.


Function  32h  Read DOS Disk Parameter Block
     Retrieve the pointer to the drive parameter block for a drive
entry   AH      32h
        DL      drive (0=default, 1=A:, etc.).
return  AL      0FFh    if drive is not valid or other error
                00h     if drive is valid and:
        DS:BX   pointer to DOS Drive Parameter Table. Format of block:
              ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³ Bytes  ³ Type ³                     Value
              ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³ 00h    ³ byte ³ Drive: 0=A:, 1=B:, etc.
              ³ 01h    ³ byte ³ Unit within device driver (0, 1, 2, etc.)
              ³ 02h-03h³ word ³ Bytes per sector
              ³ 04h    ³ byte ³ Sectors per cluster - 1
              ³ 05h    ³ byte ³ Sectors per cluster as powers of 2
              ³ 06h-07h³ word ³ First sector containing FAT
              ³ 08h    ³ byte ³ Number of copies of the FAT
              ³ 09h-0Ah³ word ³ Number of root directory entries
              ³ 0Bh-0Ch³ word ³ First sector of first cluster
              ³ 0Dh-0Eh³ word ³ Number of clusters on drive + 1
              ÃÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³ DOS 2.x only  ³
              ÃÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³ 0Fh    ³ byte ³ Number of sectors for one copy of the FAT
              ³ 10h-11h³ word ³ Number of first sector of root directory
              ³ 12h-15h³ dword³ Address of device driver header for this
              ³        ³      ³ drive (beginning of device driver)
              ³ 16h    ³ byte ³ Media Descriptor Byte for this drive
              ³ 17h    ³ byte ³ 0FFh indicates block must be rebuilt
              ³ 18h-1Bh³ dword³ address of next DOS Disk Block (0FFFFh
              ³        ³      ³ means last in chain)
              ³ 1Ch    ³ word ³ starting cluster of current dir (0 = root)
              ³ 1Eh    ³64byts³ ASCIIZ current directory path string
              ÃÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³    DOS 3.x    ³
              ÃÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³ 0Fh    ³ byte ³ number of sectors in one FAT copy
              ³ 10h    ³ word ³ first sector of root directory
              ³ 12h    ³dword ³ address of device driver for this drive
              ³ 16h    ³ byte ³ media descriptor byte for medium
              ³ 17h    ³ byte ³ 0FFh = block must be rebuilt, 00h
              ³        ³      ³ indicates block accessed
              ³ 18h    ³dword ³ address of next device block, offset
              ³        ³      ³ = 0FFFFh indicates last
              ³ 1Ch    ³ word ³ cluster at which to start search for free
              ³        ³      ³ space when writing
              ³ 1Eh    ³ word ³ number of free clusters on drive, 0FFFFh
              ³        ³      ³ unknown?
              ÃÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³  DOS 4.0, 5.0 ³  (from MS 5.0 TR)
              ÃÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ³ 0Fh    ³ word ³ number of sectors in one FAT copy
              ³ 11h    ³ word ³ first sector of containing directory
              ³ 13h    ³dword ³ address of device driver for this drive
              ³ 17h    ³ byte ³ media descriptor byte for drive
              ³ 18h    ³ byte ³ 0FFh = block must be rebuilt, 00h
              ³        ³      ³ indicates block accessed
              ³ 19h    ³dword ³ address of next device block, offset
              ³        ³      ³  = 0FFFFh indicates last
              ³ 1Dh    ³ word ³ last allocated cluster
              ³ 1Fh    ³ word ³ number of free clusters on drive
              ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
note 1) Use [BX+0Dh] to find no. of clusters (>1000h, 16-bit FAT; if
        not, 12-bit (exact dividing line is probably a little below
        1000h to allow for bad sectors, EOF markers, etc.)
     2) Short article by C.Petzold, PC Magazine  Vol.5, no.8.
     3) Some information from the article "Finding Disk Parameters" in
        the May 1986 issue of PC Tech Journal.
     4) This call is mostly supported in OS/2 1.0's DOS Compatibility
        Box.  The dword at 12h will not return the address of the next
        device driver when in the Compatibility Box.
     5) Used by CHKDSK.


Function  33h  Control-Break Check
     Get or set control-break checking at CON
entry   AH      33h
        AL      00h     see if ^C checking is active
                01h     to set break checking
                        DL      00h     to disable break checking
                                01h     to enable break checking
                02h     internal, called by PRINT.COM (DOS 3.1)
                03h     unknown
                04h     unknown - DOS 4.0's CPSW command in CONFIG.SYS
                        calls this function
                05h     (DOS 4.0+) get boot drive
                06h     (DOS 5.0+) return "real" DOS version number
                        instead of number returned by SETVER/int 21h
                        fn 30h.
return  (if AL=00h)  break setting
        DL      00h     if break=off
                01h     if break=on

        (if AL=05h)  boot drive
        DL      01h     A:
                02h     B:  (etc.)

        (if AL=06h)  real DOS version
        BH      major version (05h=DOS5)
        BL      minor version (00h=.00)
        DH      0Bh     DOS is in ROM
                10h     DOS is in HMA
        DL      DOS subversion number (0-7, VER/R reports as A-G)
 
        (all)
        AL      0FFh    error
note 1) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     2) When ^C checking is on, DOS checks for ^C after each DOS call.
        When off, DOS only checks after each DOS character I/O function
        from 01h to 0Ch.


Function  34h  Return INDOS Flag
     Returns ES:BX pointing to Critical Section Flag, byte indicating
     whether it is safe to interrupt DOS.
entry   AH      34h
return  ES:BX   points to 1-byte DOS "critical section flag"
note 1) If this byte is 0, it is safe to interrupt DOS.
     2) Supported OS/2 1.x Compatibility Box.
     3) For PC-MOS/386, this flag indicates whether MOS is using its
        stack or a task's stack.  If the flag is 0 it is safe to
        interrupt MOS.


Function  35h  Get Interrupt Vector
     Get interrupt vector
entry   AH      35h
        AL      interrupt number (hexadecimal)
return  ES:BX   address of interrupt vector
note 1) Use function call 25h to set the interrupt vectors.
     2) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.


Function  36h  Get Disk Free Space
     get information on specified drive
entry   AH      36h
        DL      drive number (0=default, 1=A:, 2=B:, etc)
return  AX      number of sectors per cluster
                0FFFFh means drive specified in DL is invalid
        BX      number of available clusters
        CX      bytes per sector
        DX      clusters per drive
note 1) Multiply AX * CX * BX for free space on disk.
     2) Multiply AX * CX * DX for total disk space.
     3) Function 36h returns an incorrect value after an ASSIGN command.
        Prior to ASSIGN, the DX register contains 0943h on return, which
        is the free space in clusters on the HC diskette. After ASSIGN,
        even with no parameters, 0901h is returned in the DX register;
        this is an incorrect value.  Similar results occur with DD
        diskettes on a PC-XT or a PC-AT.  This occurs only when the disk
        is not the default drive.  Results are as expected when the
        drive is the default drive.  Therefore, the circumvention is to
        make the desired drive the default drive prior to issuing this
        function call.
     4) This function supercedes functions 1Bh and 1Ch.
     5) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     6) TOS: $36 GET DISK FREE SPACE.


Function  37h  SWITCHAR / AVAILDEV
 *   Get/set option marking character (is usually "/"), and device type
entry   AH      37h
        AL      00h     read switch character (returns current character
                        in DL)
                01h     set character in DL as new switch character
    (DOS 2.x)   02h     read device availability (as set by function
                        AL=3) into DL.  A 0 means devices that devices
                        must be accessed in file I/O calls by /dev/device.
                        A non-zero value means that devices are
                        accessible at every level of the directory tree
                        (e.g., PRN is the printer and not a file PRN).
                        AL=2 to return flag in DL, AL=3 to set from DL
                        (0 = set, 1 = not set).
    (DOS 2.x)   03h     get device availability, where:
                        DL      00h     /dev/ must precede device names
                                01h     /dev/ need not precede device
                                        names
return  DL      switch character (if AL=0 or 1)
                device availability flag (if AL=2 or 3)
        AL      0FFh    the value in AL was not in the range 0-3
note 1) Functions 2 & 3 appear not to be implemented for DOS 3.x.
     2) It is documented on page 4.324 of the MS-DOS (version 2)
        Programmer's Utility Pack (Microsoft - published by Zenith).
     3) Works on all versions of IBM PC-DOS from 2.0 through 3.3.1.
     4) The SWITCHAR is the character used for "switches" in DOS command
        arguments (defaults to '/', as in "DIR/P"). '-' is popular to
        make a system look more like UNIX; if the SWITCHAR is anything
        other than '/', then '/' may be used instead of '\' for
        pathnames.
     5) Ignored by XCOPY, PKARC, LIST, used by PKZIP, LHARC.
     6) SWITCHAR may not be set to any character used in a filename.
        Legal filename characters vary in DOS 1.x through 6.x.
     7) In DOS 3.x you can still read the "AVAILDEV" byte with
        subfunction 02h but it always returns 0FFh even if you try to
        change it to 0 with subfunction 03h.
     8) AVAILDEV=0 means that devices must be referenced in an
        imaginary subdirectory "\dev" (similar to UNIX's /dev/*); a
        filename "PRN.DAT" can be created on disk and manipulated like
        any other.  If AVAILDEV != 0 then device names are recognized
        anywhere (this is the default): "PRN.DAT" is synonymous with
        "PRN:".
     9) These functions reportedly are not supported in the same
        fashion in various implementations of DOS.
    10) Used in DOS 3.3 by CHKDSK, BASIC, and DEBUG.
    11) SWITCHAR is not supported in the OS/2 1.x Compatibility Box.
    12) Not supported by the aftermarket 4DOS command interpreter in
        versions prior to 3.0.
    13) The MSDOS Encyclopedia reports: "XENIX used a forward slash as
        a separator, but versions 1.x of MS-DOS, borrowing from the
        tradition of DEC operating systems, already used the forward
        slash for switches on the command line, so Microsoft, at IBM's
        request, decided to use the backslash as the separator instead."
    14) SWITCHAR is not supported in MS-DOS 5.0.


Function  38h   Return Country-Dependent Information
                (PCDOS 2.0, 2.1, MSDOS 2.00 only)
entry   AH      38h
        AL      function code  (must be 0 in DOS 2.x)
        DS:DX   pointer to 32 byte memory buffer for returned information
return  CF      set on error
                AX      error code (02h)
        BX      country code
        DS:DX   pointer to buffer filled with country information:
          bytes 00h,01h date/time format
                        0000h   USA standard       H:M:S   M-D-Y
                        0001h   European standard  H:M:S   D/M/Y
                        0002h   Japanese standard  H:M:S   D:M:Y
                02h     ASCIIZ string currency symbol
                03h     byte of zeroes
                04h     ASCIIZ string thousands separator
                05h     byte of zeroes
                06h     ASCIIZ string decimal separator
                07h     byte of zeroes
       24 bytes 08h-1Fh reserved


Function  38h   Get Country-Dependent Information
                (PCDOS 3.x+, MSDOS 2.01+)
entry   AH      38h
        AL      function code
                00h     to get current country information
                01h-0FEh country code to get information for, for
                        countries with codes less than 255
                0FFh    to get country information for countries with
                        a code greater than 255
                        BX      16 bit country code if AL=0FFh
        DS:DX   pointer to the memory buffer where the data will be
                returned
        DX      0FFFFh if setting country code rather than getting info
return  CF      0 (clear) function completed
                1 (set) error
                        AX   error code
                             02h     invalid country code (no table
                                     for it)
        (if DX <> 0FFFFh)
        BX      country code (usually international telephone code)
        DS:DX   pointer to country data buffer
          bytes 0,1     date/time format
                        0       USA standard       H:M:S   M/D/Y
                        1       European standard  H:M:S   D/M/Y
                        2       Japanese standard  H:M:S   D:M:Y
          bytes 02h-06h ASCIIZ currency symbol
          byte  07h     ASCIIZ thousands separator
          byte  08h     byte of zeroes
          byte  09h     ASCIIZ decimal separator
          byte  0Ah     byte of zeroes
          byte  0Bh     ASCIIZ date separator
          byte  0Ch     byte of zeroes
          byte  0Dh     ASCIIZ time separator
          byte  0Eh     byte of zeroes
          byte  0Fh     currency format byte
                     bit 0      0  if currency symbol precedes the value
                                1  if currency symbol is after the value
                         1      0  no spaces between value and currency
                                   symbol
                                1  one space between value and currency
                                   symbol
                         2      1  if currency symbol replaces decimal
                                   point
                         3-7    not defined by Microsoft
          byte  10h     number of significant decimal digits in currency
                        (number of places to right of decimal point)
          byte  11h     time format byte
                    bit 0       0       12 hour clock
                                1       24 hour clock
                        1-7     unknown, probably not used
          bytes 12h-15h address of case map routine (FAR CALL, AL=char
                                                     to map)
                        entry   AL  ASCII code of character to be
                                    converted to uppercase
                        return  AL  ASCII code of the uppercase input
                                    character
          byte  16h     data-list separator character
          byte  17h     zeroes
          bytes 18h-21h 5 words reserved
note 1) When an alternate keyboard handler is invoked, the keyboard
        routine is loaded into user memory starting at the lowest
        portion of available user memory.  The BIOS interrupt vector
        that services the keyboard is redirected to the memory area
        where the new routine resides.  Each new routine takes up about
        1.6K of memory and has lookup tables that return values unique
        to each language.  (KEYBxx in the DOS book)
          Once the keyboard interrupt vector is changed by the DOS
        keyboard routine, the new routine services all calls unless the
        system is returned to the US format by the ctrl-alt-F1 keystroke
        combination.  This does not change the interrupt vector back to
        the BIOS location; it merely passes the table lookup to the ROM
        locations.
     2) Ctrl-Alt-F1 will only change systems with US ROMS to the US
        layout.  Some systems are delivered with non-US keyboard
        handler routines in ROM.  (Amstrad machines)
     3) Case mapping call: the segment/offset of a FAR procedure that
        performs country-specific lower-to-upper case mapping on ASCII
        characters 80h to 0FFh.  It is called with the character to be
        mapped in AL.  If there is an uppercase code for the letter, it
        is returned in AL, if there is no code or the function was
        called with a value of less than 80h AL is returned unchanged.
     4) This call is fully implemented in MS-DOS version 2.01 and
        higher.  It is in version 2.00 but not fully implemented
        (according to Microsoft).
     5) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     6) For PC-MOS/386 native mode apps, use DS:EDX instead of DS:DX.


Function  38h   Set Country Dependent Information
entry   AH      38h
        AL      code    country code to set information for, for
                        countries with codes less than 255
                0FFh    to set country information for countries with
                        a code greater than 255
        BX      16 bit country code if AL=0FFh
        DX      0FFFFh
return  CF      clear   successful
                set     if error
                        AX      error code (02h)
note 1) Some country codes are:
        061     Australia       ("International English" in DOS 5.0)
        032     Belgium
        055     Brazil          (DOS 5.0)
        002     French-Canadian
        042     Czechoslovakia  (DOS 5.0)
        045     Denmark
        358     Finland
        033     France
        049     Germany  
        036     Hungary         (DOS 5.0)
        972     Israel
        039     Italy
        081     Japan
        758     Middle East
        031     Netherlands
        047     Norway
        048     Poland          (DOS 5.0)
        351     Portugal
        003     Latin America
        034     Spain
        046     Sweden
        041     Switzerland
        088     Taiwan          (MS 4.0+, but not DRDOS 5 or 6)
        044     U.K.
        001     USA
        038     Yugoslavia      (DOS 5.0)
     2) The country code is the same as the 3-digit international
        telephone code for that country.
     3) The documentation for COUNTRY= will tell you which codes are
        valid for your particular DOS version.  Different OEM
        implementations of the same DOS version may not support the
        same countries.
     4) TSL offers support for developing special country code drivers
        for PC-MOS/386.  Version 4.10 comes with:
        061     Australia
        032     Belgium
        002     French-Canadian
        045     Denmark
        358     Finland
        033     France
        049     Germany  
        972     Israel
        039     Italy
        758     Middle East
        031     Netherlands
        047     Norway
        351     Portugal
        034     Spain
        046     Sweden
        041     Switzerland
        044     U.K.
        001     USA
     5) For PC-MOS/386 native mode apps, use DS:EDX instead of DS:DX.


Function  39h   Create Subdirectory                     (MKDIR)
                Makes a subdirectory along the indicated path
entry   AH      39h
        DS:DX   address of ASCIIZ directory pathname string
return  flag CF 0       successful
                1       error
                        AX      error code if any  (03h, 05h)
                                        (DOS 5.0)  (02h, 03h, 05h)
note 1) The ASCIIZ string contains the drive and subdirectory.
     2) Drive may be any valid drive (not necessarily current drive).
     3) The pathname cannot exceed 64 characters.  (same with
        PC-MOS/386)
     4) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     5) The characters [, ] , =, and " may not be used in subdirectory
        names.
     6) TOS: $39 MKDIR.
     7) For DOS 3.1+ networks, the user must have Create access to the
        subdirectory.
     8) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  3Ah   Remove Subdirectory                     (RMDIR)
entry   AH      3Ah
        DS:DX   address of ASCIIZ pathname string
return  CF      clear     successful
                set       AX      error code if any  (03h, 05h, 10h)
note 1) The ASCIIZ string contains the drive and subdirectory.
     2) Drive may be any valid drive (not necessarily current drive).
     3) The pathname cannot exceed 64 characters.
     4) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     5) TOS: $3A RMDIR.
     7) For DOS 3.1+ networks, the user must have Delete access to the
        subdirectory.
     8) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  3Bh   Change Current Directory                (CHDIR)
entry   AH      3Bh
        DS:DX   address of ASCIIZ string
return  flag CF 0       successful
                1       error
        AX      error code if any (03h)
note 1) The pathname cannot exceed 64 characters including separators.
     2) The ASCIIZ string may contain drive and subdirectory.
     3) Drive may be any valid drive (not necessarily current drive).
        This call will not change the current logged drive.
     4) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     5) TOS: $3B CHDIR.
     6) The pathspec may not contain wildcards.
     7) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  3Ch   Create A File                           (CREAT)
                Create a file with handle
entry   AH      3Ch
        CX      byte, attributes for file
                00h     normal read/write
                01h     read only
                02h     hidden
                04h     system
                08h     volume label
                20h     archive bit
        DS:DX   address of ASCIIZ filename string
return  CF      0       successful creation
                1       error
        AX      16 bit file handle
                or error code  (03h, 04h, 05h)
note 1) The ASCIIZ string may contain drive and subdirectory.
     2) Drive may be any valid drive (not necessarily current drive).
     3) If the volume label or subdirectory bits are set in CX, they are
        ignored.
     4) The file is opened in read/write mode
     5) If the file does not exist, it is created. If one of the same
        name exists, it is truncated to a length of 0.
     6) Good practice is to attempt to open a file with fn 3Dh and jump
        to an error routine if successful, create file if 3Dh fails.
        That way an existing file will not be truncated and overwritten.
     7) If the application will run only on DOS 3.x or higher, fn 5Bh
        should be used as it automatically creates the file if it does
        not exist, preventing problems with networks or multitaskers.
     8) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     9) TOS: $3C CREAT.
    10) For DOS 3.1+ networks, the user must have Create access to the
        subdirectory.
    11) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  3Dh   Open A File
                Open disk file with handle
entry   AH      3Dh
        AL      access code byte
(DOS 2.x)  bits 0-2     file attribute
                        000     read only
                        001     write only
                        010     read/write (default)
                3-7     reserved, should be set to zero
(DOS 3.x)  bits 0-2     file attribute
                        000     read only
                        001     write only
                        010     read/write (default)
                3       reserved, should be set to zero
                4-6     sharing mode (network)
                        000     compatibility mode       (default)
                        001     read/write access denied (exclusive)
                        010     write access denied
                        011     read access denied
                        100     full access permitted
                7       inheritance flag
                        0       file inherited by child process
                        1       file private to child process
        DS:DX   address of ASCIIZ drive/path/filename string
return  CF set on error
                AX      error code - MS-DOS (01h, 02h, 03h, 04h, 05h,
                                            0Ch)
                                   - DR-DOS (02h, 04h, 05h, 0Ch) and
                                            MS-DOS 5.0
        AX      16 bit DOS file handle
note 1) Opens any normal, system, or hidden file.
     2) Files that end in a colon are not opened.
     3) The read/write pointer is set at the first byte of the file and
        the record size of the file is 1 byte (the read/write pointer
        can be changed through function call 42h).  The returned file
        handle must be used for all subsequent input and output to the
        file.
     4) If the file handle was inherited from a parent process or was
        duplicated by DUP or FORCEDUP, all sharing and access
        restrictions are also inherited.
     5) A file sharing error (error 01h) causes an int 24h to execute
        with an error code of 02h.
     6) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     7) TOS: $3D OPEN.
     8) If any process opens a file that denies a level of access, all
        subsequent requests to open the file at that level of access
        will fail.
     9) Any attempt to open a file with a sharing mode that is already
        breached by an existing process will always fail.
    10) Used by APPEND in DOS 3.2,+.
    11) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  3Eh   Close A File Handle
                Close a file and release handle for reuse
entry   AH      3Eh
        BX      file handle (generated by 3Dh)
return  flag CF clear   successful close
                set     error
        AX      error code if error (06h)
note 1) When executed, the file is closed, the directory is updated,
        and all buffers for that file are flushed.  If the file was
        changed, the time and date stamps are changed to reflect the
        current time.
     2) If called with the handle 00000h, it will close STDIN (normally
        the keyboard).
     3) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     4) TOS: $3E CLOSE.
     5) In most versions of DOS only 15 file handles are available for
        user processes.  It is good practice to close a file handle
        when you are not using it.
     6) For DOS 3.1+ networks, all file locks must be removed before
        the file is closed.  Closing a file with active locks is
        unpredictable.
     7) Although closing a file invalidates the corresponding handle,
        DOS may reuse the handle to identify a file that is subsequently
        opened or created.  You can use int 21h/440Ah (Is File or Device
        Remote) to tell if a given handle is valid.
     

Function  3Fh   Read From A File Or Device
                Read from file with handle
entry   AH      3Fh
        BX      file handle
        CX      number of bytes to read
        DS:DX   address of buffer
return  flag CF clear   successful read
                set     error
        AX      00h     pointer was already at end of file
                     or number of bytes read
                     or error code (05h, 06h)
note 1) This function attempts to transfer the number of bytes specified
        in CX to a buffer location.  It is not guaranteed that all bytes
        will be read.
     2) If performed from STDIN (file handle 0000), the input can be
        redirected.
     3) If used to read the keyboard, it will only read to the first CR.
     4) The file pointer is incremented to the last byte read.
     5) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     6) TOS: $3F READ.
     7) If AX < CX a partial record was read.
     8) For DOS 3.1+ networks, the user must have Read access to the
        subdirectory.
    11) For PC-MOS/386 native mode, use DS:EDX and ECX instead of DS:DX
        and CX.


Function  40h   Write To A File Or Device
                Write to file with handle
entry   AH      40h
        BX      file handle
        CX      number of bytes to write
        DS:DX   address of buffer
return  CF      clear   successful write
                set     error
        AX      number of bytes written
                or error code  (05h, 06h)
note 1) This call attempts to transfer the number of bytes indicated
        in CX from a buffer to a file.  If CX and AX do not match after
        the write, an error has taken place; however no error code will
        be returned for this problem.  This is usually caused by a full
        disk.
     2) If the write is performed to STDOUT (handle 0001), it may be
        redirected.
     3) To truncate the file at the current position of the file
        pointer, set the number of bytes in CX to zero before calling
        int 21h.  The pointer can be moved to any desired position with
        function 42h.
     4) This function will not write to a file or device marked
        read-only.
     5) May also be used to display strings to CON instead of fn 09h.
        This function will write CX bytes and stop; fn 09h will
        continue to write until a '$' character is found.
     6) This is the call that DOS actually uses to write to the screen
        in DOS 2.x and above.
     7) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     8) TOS: $40 WRITE.
     9) For PC-MOS/386 native mode, use DS:EDX and ECX instead of DS:DX
        and CX.


Function  41h   Delete A File From A Specified Subdirectory  (UNLINK)
entry   AH      41h
        DS:DX   pointer to ASCIIZ filespec to delete
return  CF      clear   successful
                set     error
                AX      error code if any  (02h, 05h)
note 1) This function will not work on a file marked read-only.
     2) Wildcards are not accepted.
     3) For deleting multiple files, function 13h is faster.
     4) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     5) TOS: $41 UNLINK.
     6) For DOS 3.1+ networks, the user must have Delete access to the
        subdirectory.
     7) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  42h   Move a File Read/Write Pointer               (LSEEK)
entry   AH      42h
        AL      method code byte
                00h     offset from beginning of file
                01h     offset from present location
                02h     offset from end of file
        BX      file handle
        CX:DX   offset into file (high/low word) in bytes
return  AX:DX   new file pointer (segment/offset)
        CF      set     error
                        AX      error code (01h, 06h)
                clear   successful move
note 1) If pointer is at end of file, reflects file size in bytes.
     2) The value in DX:AX is the absolute 32 bit byte offset from the
        beginning of the file.
     3) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     4) TOS: $42 LSEEK.
     5) File most be open.
     6) For PC-MOS/386 native mode, use ECX instead of CX.


Function   43h  Get/Set file attributes                 (CHMOD)
entry   AH      43h
        AL      00h     get file attributes
                01h     set file attributes
                CX      file attributes to set
                    bit 0       read only
                        1       hidden file
                        2       system file
                        3       volume label
                        4       subdirectory
                        5       written since backup (archive bit)
                        6,7     not used
                        8       shareable (Novell NetWare)
                        9-F     not used
        DS:DX   segment/offset pointer to full ASCIIZ file name
return  CF      set if error
                AX      error code - MSDOS (01h, 02h, 03h, 05h)
                                     DRDOS (02h, 03h, 05h)
        CX      file attributes on get
                attributes:
                00h     normal
                01h     read only
                02h     hidden
                04h     system
                08h     volume label
                10h     file is subdirectory
                20h     archive
note 1) This call will not change the volume label or directory bits.
     2) Any combination of file attributes may be used.
     3) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     4) TOS: $43 CHANGE MODE (CHMOD).
     5) For DOS 3.1+ networks, the user must have Create access to the
        subdirectory.
     6) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  44h   I/O Control for Devices                 (IOCTL)
        provided with full version of DOSREF


Function  45h   Duplicate a File Handle                 (DUP)
entry   AH      45h
        BX      file handle to duplicate
return  CF      clear   AX      duplicate handle
                set     AX      error code  (04h, 06h)
note 1) If you move the pointer of one handle with 3Fh (Read), 40h
        (Write), or 42h (Move Pointer) the pointer of the other will
        also be moved.
     2) The handle in BX must be open.
     3) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     4) TOS: $45 DUP.
     5) This call can be used to update the directory entry of a file
        without the overhead of opening and closing it.  For example,
        this call followed by fn 3Eh (Close File) with the duplicate
        file handle will cause DOS to flush its buffers and update the
        directory entry while the original file remains open in read/
        write mode.


Function  46h   Force Duplicate of a Handle          (FORCEDUP or CDUP)
                Forces handle in CX to refer to the same file at the
                same position as BX
entry   AH      46h
        BX      existing open file handle to duplicate
        CX      new file handle
return  CF      clear   both handles now refer to existing file
                set     error
                AX      error code (04h, 06h)
note 1) If CX was an open file, it is closed first.
     2) If you move the pointer of one handle with 3Fh (Read), 40h
        (Write), or 42h (Move Pointer) the pointer of the other will
        also be moved.
     3) The handle in BX must be open.
     4) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     5) TOS $46 FORCE.
     6) This call may be used for redirecting input and output.


Function  47h   Get Current Directory
                Places full pathname of current directory/drive into
                a buffer
entry   AH      47h
        DL      drive (0=default, 1=A:, etc.)
        DS:SI   segment/offset pointer to 64-byte buffer area
return  CF      clear   DS:DI   pointer to ASCIIZ pathname of the current
                                directory
                set     AX      error code (0Fh)
note 1) String does not begin with a drive identifier or a backslash.
     2) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     3) TOS: $47 GETDIR.
     4) For PC-MOS/386 native mode, use DS:ESI instead of DS:SI.


Function  48h   Allocate Memory                         (MALLOC)
                Allocates the requested number of 16-byte paragraphs
                of memory
entry   AH      48h
        BX      number of 16-byte paragraphs desired
return  CF      clear   AX      segment address of allocated space
                        BX      maximum number paragraphs available
                set     AX      error code (07h, 08h)
note 1) BX indicates maximum memory available only if allocation fails.
     2) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     3) TOS: $48 MALLOC.
     4) Native-mode PC-MOS/386 applications allocate memory via MOS'
        interrupt 0D4h API function 11h.
     5) When in TopView this call is checked to ensure none of the
        addresses are outside the application's memory partition.


Function  49h   Free Allocated Memory
                Frees specified memory blocks
entry   AH      49h
        ES      segment address of area to be freed
return  CF      clear   successful
                set     AX      error code (07h, 09h)
note 1) This call is only valid when freeing memory obtained by
        function 48h.
     2) A program should not try to release memory not belonging to it.
     3) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     4) TOS: $49 MFREE.
     5) Native-mode PC-MOS/386 applications allocate memory via MOS'
        interrupt 0D4h API function 12h.
     6) When in TopView this call is checked to ensure none of the
        addresses are outside the application's memory partition.


Function  4Ah   Modify Allocated Memory Blocks          (SETBLOCK)
                Expand or shrink memory for a program
entry   AH      4Ah
        BX      new size in 16 byte paragraphs
        ES      segment address of block to change
return  CF      clear   nothing
                set     AX      error code (07h, 08h, 09h)
                    or  BX      maximum number of paragraphs available
note 1) Max number paragraphs available is returned only if the call
        fails.
     2) Memory can be expanded only if there is memory available.
     3) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
     4) TOS: $4A SETBLOCK.
     5) Native-mode PC-MOS/386 applications allocate memory via MOS'
        interrupt 0D4h API function 12h.
     6) When in TopView this call is checked to ensure none of the
        addresses are outside the application's memory partition.


Function  4Bh   Load or Execute a Program                  (EXEC)
entry   AH      4Bh
        AL      00h     load and execute program.  A PSP is built for
                        the program the ctrl-break and terminate
                        addresses are set to the new PSP.
  (DOS 5.0)    *01h     load but don't execute (internal, DOS 3.x &
                        DESQview)    (see note 1)
               *02h     load but do not execute (internal,
                        DOS 2.x only)
                03h     load overlay (do not create PSP, do not begin
                        execution)
               *04h     start async process (Euro-DOS 4.0 only)
                        (see note 12)
  (DOS 5.0)     05h     EnterExecState API (see note 17)
        DS:DX   segment/offset pointer to the ASCIIZ string with the
                drive, path, and filename to be loaded
        ES:BX   segment/offset pointer to a parameter block for the load
               (AL=00h) word    segment address of environment string
                                to be passed (0=use current)
                       dword    pointer to the command line to be
                                placed at PSP+80h
                       dword    pointer to default FCB to be passed at
                                PSP+5Ch
                       dword    pointer to default FCB to be passed at
                                PSP+6Ch
              (*AL=01h) word    segment of environment (0 = use current)
                       dword    pointer to command line
                       dword    pointer to FCB 1
                       dword    pointer to FCB 2
         (DOS 3.x+)    dword    will hold SS:SP on return
         (DOS 3.x+)    dword    will hold program entry point (CS:IP) on
                                return
              (*AL=02h) word    segment of environment (0 = use current)
                       dword    pointer to command line
                       dword    pointer to FCB 1
                       dword    pointer to FCB 2
               (AL=03h) word    segment address where file will be
                                loaded
                        word    relocation factor to be applied to the
                                image
return  CF      set     error
                        AX      error code (01h - 05h, 08h, 0Ah, 0Bh)
        CF      clear   if successful
                for fn 00h, process ID set to new program's PSP; get
                        with function 62h
                for fn 01h and DOS 3.x+ or DESQview, process ID set
                        to new program's PSP; get with function 62h
                for fn 01h and DOS 2.x, new program's initial stack
                        and entry point returned in registers
                for fn 02h, new program's initial stack and entry point
                        are returned in the registers
note 1) If you make this call with AL=1 the program will be loaded as
        if you made the call with AL=0 except that the program will not
        be executed.  Additionally, with AL=1 the stack segment and
        pointer along with the program's CS:IP entry point are returned
        to the program which made the 4B01h call.  These values are put
        in the four words at ES:BX+0Eh.  On entry to the call ES:BX
        points to the environment address, the command line and the
        two default FCBs.  This form of EXEC is used by DEBUG.COM.
     2) Application programs may invoke a secondary copy of the command
        processor (normally COMMAND.COM) by using the EXEC function.
        Your program may pass a DOS command as a parameter that the
        secondary command processor will execute as though it had been
        entered from the standard input device.
        The procedure is:
         A. Assure that adequate free memory (17k for 2.x and 3.0, 23k
            for 3.1) exists to contain the second copy of the command
            processor and the command it is to execute.  This is
            accomplished by executing function call 4Ah to shrink memory
            allocated to that of your current requirements.  Next,
            execute function call 48h with BX=0FFFFh.  This returns the
            amount of memory available.
        B. Build a parameter string for the secondary command processor
           in the form:
                         1 byte   length of parameter string
                        xx bytes  parameter string
                         1 byte   0Dh (carriage return)
           For example, the assembly language statement below would
           build the string to cause execution of the command FOO.EXE:
                              DB 19,"/C C:FOO",13
        C. Use the EXEC function call (4Bh), function value 0 to cause
           execution of the secondary copy of the command processor.
           (The drive, directory, and name of the command processor can
           be obtained from the COMSPEC variable in the DOS environment
           passed to you at PSP+2Ch.)
        D. Remember to set offset 2 of the EXEC control block to point
           to the string built above.
     3) All open files of a process are duplicated in the newly created
        process after an EXEC, except for files originally opened with
        the inheritance bit set to 1.
     4) The environment is a copy of the original command processor's
        environment.  Changes to the EXECed environment are not passed
        back to the original.  The environment is followed by a copy of
        the DS:DX filename passed to the child process.  A zero value
        will cause the child process to inherit the environment of the
        calling process.  The segment address of the environment is
        placed at offset 2Ch of the PSP of the program being invoked.
     5) This function uses the same resident part of COMMAND.COM, but
        makes a duplicate of the transient part.
     6) How EXEC knows where to return to: Basically the vector for int
        22h holds the Terminate address for the current process.  When
        a process gets started, the previous contents of int 22h get
        tucked away in the PSP for that process, then int 22h gets
        modified.  So if Process A EXECs process B, while Process B is
        running, the vector for int 22h holds the address to return to
        in Process A, while the save location in Process B's PSP holds
        the address that process A will return to when *it* terminates.
        When Process B terminates by one of the usual legal means, the
        contents of int 22h are (surmising) shoved onto the stack, the
        old terminate vector contents are copied back to int 22h vector
        from Process B's PSP, then a RETF or equivalent is executed to
        return control to process A.
     7) To load an overlay file with 4B: first, don't de-allocate the
        memory that the overlay will load into.  With the other 4Bh
        functions, the opposite is true - you have to free the memory
        first, with function 4Ah.  Second, the "segment address where
        the file will be loaded" (first item in the parameter block for
        sub-function 03) should be a paragraph boundary within your
        currently-allocated memory.  Third, if the procedures within
        the overlay are FAR procs (while they execute, CS will be
        equal to the segment address of the overlay area), the
        relocation factor should be set to zero.  On the other hand,
        if the CS register will be different from the overlay area's
        segment address, the relocation factor should be set to
        represent the difference.  You determine where in memory the
        overlay file will load by using the segment address mentioned
        above.  Overlay files are .EXEs (containing header, relocation
        table, and memory image).
     8) When function 00h returns, all registers are changed,
        including the stack.  You must resore SS, SP, and any other
        required registers.
     9) PCDOS EXEC function 3 (overlay) lives in the transient piece
        of COMMAND.COM and gets loaded when needed, thus the
        requirement for enough free space to load the EXEC loader
        (about 1.5k).  Under MS-DOS the EXEC system call lives in
        the system space.
    10) If you try to overlay an .EXE file with the high/low switch set
        to load the in the upper end of memory nothing will happen.
        The high/low switch is only for process creation, not for
        overlays.
    11) DOS 2.x destroys all registers, including SS:SP.
    12) (AL=04h) This is DOS 4.0 as released in 1987 to various
        European OEMs.  It is not related to US DOS 4.0.
    13) This call is explicitly supported by the OS/2 1.x DOS
        Compatibility Box.
    14) TOS: $4B EXEC.
    15) New with DOS 5.0.  Sets up for EXEC, including setting the DOS
        version number returned by SETVER/int 21h,fn 30h.  If DOS is
        installed in the HMA this function turns off the A20 line,
        making the HMA inaccessible.  If your program needs the HMA
        you must turn it back on before EXECing.  DOS normally turns
        the A20 line back on when called for normal system functions.
        Your program must call EXEC immediately after this subfunction.
        You may not call any DOS, BIOS, or system interrupts between
        this subfunction and loading your program.
    15) When in TopView this call is checked to ensure none of the
        addresses are outside the application's memory partition.
    16) This call is documented in the MS 5.0 TR, and in the PC-MOS/386
        TR.
    17) Some applications use their own EXEC scheme instead of calling 
        this function.  Since DOS 5 enhanced the EXEC functions these
        programs might not work, so Microsoft added a new set of 
        functions called EnterExecState.  If a self-EXECing program
        calls EnterExecState before EXECing, DOS 5 will do various
        internal fixups to keep things happy.


Function  4Ch   Terminate a Process                          (EXIT)
                Quit with ERRORLEVEL exit code
entry   AH      4Ch
        AL      exit code in AL when called, if any, is passed to next
                process
return  none
note 1) Control passes to DOS or calling program.
     2) Return code from AL can be retrieved by ERRORLEVEL or function
        4Dh.
     3) All files opened by this process are closed, buffers are
        flushed, memory is released, any network file region locks are
        released, and the disk directory is updated.
     4) Restores: Terminate vector from PSP:000Ah
                  Ctrl-C vector from PSP:000Eh
                  Critical Error vector from PSP:0012h
     5) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     6) TOS: $4C TERM. Returns 2-byte errorlevel to calling program
     7) Under DOS 3.1+ networks, all file locks should be removed
        before terminating the program.


Function  4Dh   Get Return Code of a Subprocess              (WAIT)
                Get return from functions 31h and 4Dh  (ERRORLEVEL)
entry   AH      4Dh
return  AH      circumstance which caused termination
                00h     normal termination
                01h     control-break or control-C
                02h     critical device error
                03h     terminate and stay resident (function 31h)
        AL      exit code of subprogram (functions 31h or 4Ch)
note 1) The exit code is only returned once (the first time).
     2) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     3) Many programmers have wondered where DOS stores this
        information, so they might access it multiple times or set it
        directly.  This is a version-dependent area that changes with
        every release of DOS.


Function  4Eh   Find First Matching File                  (FIND FIRST)
entry   AH      4Eh
        CX      search attributes  (see function 43h)
        DS:DX   segment/offset pointer to ASCIIZ filename
                (with attributes)
return  CF      set     AX      error code (02h, 03h, 12h)
                clear   data block written at current DTA
                        format of block is:  (info from BIX)
  documented by Micro-  |00h     1 byte   attribute byte of search
  soft as "reserved for |01h     1 byte   drive letter for search
  DOS' use on subsquent |02h    11 bytes  the search name used
  Find Next calls"      |0Ch     2 bytes  word value of last entry
  function 4Fh          |0Fh     4 bytes  dword pointer to this DTA
                        |13h     2 bytes  word directory start

                        | PC-DOS 3.10 (from INTERRUP.ARC)
                        |00h     1 byte   drive letter
                        |01h-0Bh 11 bytes search template
                        |0Ch     1 byte   search attributes

                        | DOS 2.x (and DOS 3.x except 3.1?)
                                  (from INTERRUP.ARC)
                        |00h     1 byte   search attributes
                        |01h     1 byte   drive letter
                        |02h-0Ch 11 bytes search template
                        |0Dh-0Eh 2 bytes  entry count within directory
                        |0Fh-12h 4 bytes  reserved
                        |13h-14h 2 bytes  cluster number of parent
                                          directory

                         15h   1 byte   file attribute
                         16h   2 bytes  file time, bit mask:
                                        0-4     half-seconds
                                        5-10    minute
                                        11-15   hour
                         18h   2 bytes  file date, bit mask:
                                        0-4     day
                                        5-8     month
                                        9-15    years since 1980
                         1Ah   2 bytes  low word of file size
                         1Ch   2 bytes  high word of file size
                         1Eh  13 bytes  name and extension of file 
                                        found, plus 1 byte of 0s.  All
                                        blanks are removed from the name
                                        and extension, and if an
                                        extension is present it is
                                        preceded by a period.
note 1) This function does not support network operations.
     2) Wildcards are allowed in the filespec.
     3) If the attribute is zero, only ordinary files are found. If the
        volume label bit is set, only volume labels will be found.  Any
        other attribute will return that attribute and all normal files
        together.
     4) To look for everything except the volume label, set the hidden,
        system, and subdirectory bits all to 1.
     5) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     6) TOS: $4E SFIRST.
     7) There is a reported anomaly in MS-DOS 2.11.  Odd things happen
        when you give it "C:\" as a file name.  FindFirst reports it as
        a valid file and Open returns a handle.  If you read it twice
        DOS reports an FAT error and aborts.  You can demonstrate this
        by:
                FIND "whatever" c:\    [twice]
        Int 21h/AH=044 AL=0 returns the handle as a NUL device which
        makes a certain amount of sense since C:\ is a null terminated
        string.  The programming solution is to trap 'C:\' before it's
        used.
     8) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX. ES:EBX
        is a pointer to a 43-byte data area used instead of the DTA.
        Format:
                0-20    reserved for MOS
                21      attribute
                22-23   time of last update
                24-25   date of last update
                26-29   file size in bytes
                30-42   found filename, followed by 00h


Function  4Fh   Find Next Matching File                   (FIND NEXT)
                Find next ASCIIZ file
entry   AH      4Fh
return  CF      clear   data block written at current DTA
                set     AX      error code (02h, 12h)
note 1) If file found, DTA is formatted as in call 4Eh.
     2) Volume label searches using 4Eh/4Fh reportedly aren't 100%
        reliable under DOS 2.x.  The calls sometime report there's a
        volume label and point to a garbage DTA, and if the volume
        label is the only item they sometimes won't find it.  Most
        references recommend the use of the older FCB calls for dealing
        with the volume labels.
     3) This function does not support network operations.
     4) Use of this call assumes that the original filespec contained
        wildcards.
     5) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     6) TOS: $4F SNEXT.
     7) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX. ES:EBX
        is a pointer to a 43-byte data area used instead of the DTA.
        Format:
                0-20    reserved for MOS
                21      attribute
                22-23   time of last update
                24-25   date of last update
                26-29   file size in bytes
                30-42   found filename, followed by 00h


Function  50h   "Used Internally by DOS" - Set PSP or SetPID
 *              Set new Program Segment Prefix (current Process ID)
entry   AH      50h
        BX      segment address of new PSP
return  none - swaps PSPs regarded as current by DOS
note 1) By putting the PSP segment value into BX and issuing call 50h
        DOS stores that value into a variable and uses that value
        whenever a file call is made.
     2) Note that in the PSP (or PDB) is a table of 20 (decimal) open
        file handles.  The table starts at offset 18h into the PSP.  If
        there is an 0FFh in a byte then that handle is not in use.  A
        number in one of the bytes is an index into an internal FB
        table for that handle.  For instance the byte at offset 18h is
        for handle 0, at offset 19h handle 1, etc. up to 13h.  If the
        high bit is set then the file associated by the handle is not
        shared by child processes EXEC'd with call 4Bh.
     3) Function 50h is dangerous in background operations prior to DOS
        3.x as it uses the wrong stack for saving registers.  (same as
        functions 0..0Ch in DOS 2.x).  It doesn't use stack in 3.0+, 
        so it is safe to use in later versions of DOS.
     4) Under DOS 2.x, this function cannot be invoked inside an int
        28h handler without setting the Critical Error flag.
     5) Open file information, etc. is stored in the PSP DOS views as
        current.  If a program (eg. a resident program) creates a need
        for a second PSP, then the second PSP should be set as current
        to make sure DOS closes that as opposed to the first when the
        second application finishes.
     6) See PC Mag Vol.5, No 9, p.314 for discussion, also used in
        their BCOPY.ASM utility.
     7) Used by DOS 3.3 PRINT & DEBUG, DesQview 2.01, Windows 1.03,
        SYMDEB from MASM 4.0.
     8) This call is available in the OS/2 1.x DOS Compatibility Box.
     9) DOS stores the PID in one location, but the actual address is
        version dependent.  The strategy is to find the PID and thereby
        find its address.  If you have its address, you can swap PIDs
        from the TSR pop-up code by peeking and poking.  In the
        initialization code, use function  51hto get the PID.  You
        know that DOS lives between the interrupt vectors 0:0 - 0:100
        and that PID.  Other programs might be in there, but DOS is
        too.  Search that memory for a copy of the PID.  When you find
        one, use this function to set a phony PID.  If the location
        where you found the original PID changes to the phony PID,
        you have found the address of the PID.  Don't forget to reset
        the PID with SetPID after each test.  DOS 2.0 and 2.1 maintain
        the PID in two locations, not one.


Function  51h   Get Program Segment Prefix   (GetPID)
                Returns the PSP address of currently executing program
entry   AH      51h
return  BX      address of currently executing program (process ID)
note    format of PSP:
                offset  size           description
                00h   2 bytes   program exit point
                02h     word    memory size in paragraphs
                04h     byte    unused (0)
                05h   5 bytes   CP/M style entry point (far call to DOS)
                0Ah     word    terminate address (old int 22h)
                0Ch     word    terminate segment
                0Eh     word    break address (old int 23h)
                10h     word    break segment
                12h     word    error address (old int 24h)
                14h     word    error segment
                16h     word    parent PSP segment
                18h  20 bytes   DOS 2.0+ open files, 0FFh = unused
                2Ch     word    DOS 2.0+ environment segment
                2Eh    dword    far pointer to process's SS:SP
                32h     word    DOS 3.x+ max open files
                34h             DOS 3.x+ open file table address
                36h    dword    DOS 3.x+ open file table segment
                38h 24 bytes    unused by DOS versions before 3.3
                50h  3 bytes    DOS function dispatcher (FAR routine)
                53h  9 bytes    unused
                55h             FCB #1 extension
                5Ch 16 bytes    FCB #1, filled in from first command
                                line argument
                6Ch 20 bytes    FCB #2, filled in from second command
                                line argument
                80h128 bytes    command tail / default DTA buffer
note 1) Used in DOS 2.x, 3.x uses 62h.
     2) Function 51h is dangerous in background operations prior to DOS
        3.x as it uses the wrong stack for saving registers.  (same as
        functions 0..0Ch in DOS 2.x).  Doesn't use any DOS stacks in
        DOS 3.0+.
     3) 50h and 51h might be used if you have more than one process in
        a PC.  For instance if you have a resident program that needs
        to open a file you could first call 50h to get the current ID
        and then call 50h to set the ID to your PSP.
     4) Under DOS 2.x, this function cannot be invoked inside an int
        28h handler without setting the Critical Error flag.
     5) Formerly "undocumented", now described in MS 5.0 TR.
     6) This call is available in the OS/2 1.x DOS Compatibility Box.


FUNCTION 52h - see file 52h
        provided with full version of DOSREF


Function  53h   "Used Internally by DOS" - Translate BPB
 *              Translates BPB (BIOS Parameter Block, see below) into
                a DOS Disk Block (see function call 32h).
entry   AH      53h
        DS:SI   pointer to BPB (BIOS Parameter Block)
        ES:BP   pointer to buffer area for DOS Disk Block
                Layout of BPB:
                offset  size         description
                00h-01h word  bytes per sector, get from DDB bytes
                              02h-03h.
                02h     byte  sectors per cluster, get from (DDB byte
                              4) + 1
                03h-04h word  reserved sectors, get from DDB bytes
                              06h-07h
                05h     byte  number of FATs, get from DDB byte 08h
                06h-07h word  # of root dir entries, get from DDB bytes
                              09h-0Ah
   for DOS 3.x: 08h-09h word  total number of sectors, get from:
                              ((DDB bytes 0Dh-0Eh) - 1) * (sectors per
                              cluster (BPB byte 2)) + (DDB bytes 0Bh-0Ch)
   for DOS 4.x:               set to zero if partition is larger than
                              32Mb, set dword at 15h to actual number
                              of sectors
                0Ah     word  media descriptor byte, get from DDB byte
                              16h
                0Bh-0Ch word  number of sectors per FAT, get from DDB
                              byte 0Fh
   for DOS 3.x: 0Dh     word  number of sectors per track
                0Fh     word  number of heads
                11h    dword  number of hidden sectors
                15h 11 bytes  reserved
   for DOS 4.x: 15h    dword  total number of sectors if word at 08h
                              contains zero
return  unknown
note    This function is documented as 'SetDPB' in the Zenith MS-DOS
        3.05 TRM.


Function  54h   Get Verify Setting
                Get verify flag status
entry   AH      54h
return  AL      00h if flag off
                01h if flag on
note 1) Flag can be set with function 2Eh.
     2) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     3) The verify state is off by default.


Function  55h   "Used Internally by DOS" - Create "Child" PSP
 *              Create PSP: similar to function 26h (which creates a
                new Program Segment Prefix at segment in DX) except
                creates a "child" PSP rather than copying the existing
                one.
entry   AH      55h
        DX      segment number at which to create new PSP.
return  unknown
note 1) This call is similar to call 26h which creates a PSP except that
        unlike call 26h the segment address of the parent process is
        obtained from the current process ID rather than from the CS
        value on the stack (from the INT 21h call).  DX has the new PSP
        value and SI contains the value to be placed into PSP:2 (top of
        memory).
     2) Function 55 is merely a substitute for function 26h.  It will
        copy the current PSP to the segment address DX with the
        addition that SI is assumed to hold the new memory top segment.
        This means that function 26h sets SI to the segment found in the
        current PSP and then calls function 55h.


Function  56h   Rename a File
entry   AH      56h
        DS:DX   pointer to ASCIIZ old pathname
        ES:DI   pointer to ASCIIZ new pathname
return  CF      clear   successful rename
                set     AX      error code (02h, 03h, 05h, 11h)
note 1) Works with files in same logical drive only.
     2) Wildcard characters not allowed in filename.
     3) The name of a file is its full pathname.  The file's full
        pathname can be changed while leaving the actual FILENAME.EXT
        unchanged.  Changing the pathname allows the file to be
        "moved" from subdirectory to subdirectory on a logical drive
        without actually copying the file.
     4) DOS 3.x allows renaming of directories.
     5) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     6) TOS: $56 RENAME. Similar to MS-DOS 2.x.
     7) Under DOS 3.1+ networks, the user must have Read and Create
        access to the affected directories.
     8) For PC-MOS/386 native mode, use DS:EDX and ES:EDI instead of
        DS:DX and ES:DI.


Function  57h  Get/Set a File's Date and Time
               Read or modify time and date stamp on a file's directory
               entry
entry   AH      57h
        AL      function code
                00h     Get Date and Time
                01h     Set Date and Time
                        CX      time to be set
                        DX      date to be set
                02h     unknown (DOS 4.0+)
                03h     unknown
                04h     unknown (DOS 4.0+)
        BX      file handle
return  CF      clear   CX      time of last write (if AL = 0)
                        DX      date of last write (if AL = 0)
                set     AX      error code (01h, 06h)
note 1) Date/time formats are:
        CX bits 0Bh-0Fh hours (0-23)
                05h-0Ah minutes (0-59)
                00h-04h #2 sec. incr. (0-29)
        DX bits 09h-0Fh year (relative to 1980)
                05h-08h month (0-12)
                00h-04h day of the month (0-31)
     2) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     3) TOS: $57 GSDTOF.


Function  58h   Get/Set Allocation Strategy   (DOS 3.0+)
entry   AH      58h
        AL      00h     Get Current Strategy (see 01h)
                        Used to obtain the current allocation strategy.  
                        First Fit is the normal default.

                01h     Set New Current Strategy
                        BL      new strategy
                        00h     First Fit - chooses the lowest block in
                                memory which will fit (this is the
                                default). (use first memory block large
                                enough)
                        01h     Best Fit - chooses the smallest block
                                which will fill the request.
                        02h     Last Fit - chooses the highest block
                                which will fit.
        (DOS 5.0)       40h     FIRST_FIT_HIGHONLY - search upper memory
                                area for the lowest available block
        (DOS 5.0)       41h     BEST_FIT_HIGHONLY -  search upper memory
                                area for the smallest block that fits
                                the request
        (DOS 5.0)       42h     LAST_FIT_HIGHONLY -  search upper memory
                                area for the highest available block
        (DOS 5.0)       80h     FIRST_FIT_HIGH - search upper memory
                                area for the lowest available block.  If
                                no block found, load in conventional
                                memory
        (DOS 5.0)       81h     BEST_FIT_HIGH - seach the upper memory
                                area for the closest match to the
                                requested size.  If no match is found,
                                load in convenional memory.
        (DOS 5.0)       82h     LAST_FIT_HIGH - search the upper memory
                                area for the available block at the
                                highest address.  If no block is found,
                                load in conventional memory.
                02h     Get UMB Link State
                        Indicates if high DOS memory arenas are
                        currently part  of the conventional DOS memory
                        arena.
                03h     Set UMB Link State
                        BX      00h     Unlink High DOS memory blocks
                                01h     Link High DOS memory blocks
                        note:   Adds or removes high memory blocks from
                                the DOS arena.  Returns an error if no
                                high arenas exist.
return  CF      clear   successful
          (AL=00)       AX      strategy code (see 01h)  For DOS 5.0+,
          (AL=02)       AL      00h   if upper memory area is not linked
                                01h   if the upper memory area is linked
                set     error
                        AX      error code (01h)
          (AL=03)       AX      0001h   invalid function if DOS was 
                                        loaded without DOS=UMB
                                0007h   memory arena trashed
note 1) A program that changes the allocation strategy or the high DOS
        link state should ALWAYS restore it to its original condition
        before exiting, or subsequent programs may fail.
     2) The set subfunction accepts any value in BL; 2 or greater means
        last fit.  The get subfunction returns the last value set, so
        programs should check whether the value is greater than or equal
        to 2.
     3) For discussion of best fit vs. first fit allocation strategies,
        see Knuth, *Fundamental Algorithms.*  Very briefly, Knuth finds
        that first fit methods are far superior to best fit, which
        increases both allocation overhead and memory fragmentation.
        The "last" fit that DOS offers is nothing other than a first
        fit, starting the search at the other end of the chain (the
        algorithm still takes the first fitting block that is
        encountered in the search).
     4) For DOS 5+, the default scheme is "allocate high first".  This 
        is actually a variant of the previous first/best/last 
        allocation options.  When enabled, the high-first strategy
        causes DOS to begin its free block search at the first UMB. If
        DOS can't find enough memory in the UMB, it searches from the
        beginning of conventional memory.  As a result, high-first may
        result in a worse fit than best fit alone if there is a better
        fit low than high.


Function  59h   Get Extended Error Code (DOS 3.0+)
       The Get Extended Error function call (59h) is intended to provide
     a common set of error codes and to supply more extensive
     information about the error to the application.  The information
     returned from function call 59h, in addition to the error code,
     is the error class, the locus, and the recommended action.  The
     error class provides information about the error type (hardware,
     internal, system, etc.).  The locus provides information about
     the area involved in the failure (serial device, block device,
     network, or memory).  The recommended action provides a default
     action for programs that do not understand the specific error code.

       Newly written programs should use the extended error support
     both from interrupt 24h hard error handlers and after any int
     21h function calls.  FCB function calls report an error by
     returning 0FFh in AL.  Handle function calls report an error by
     setting the carry flag and returning the error code in AX.  Int
     21h handle function calls for DOS 2.x continue to return error
     codes 0-18.  Int 24h handle function calls continue to return
     error codes 0-12.  But the application can obtain any of the
     error codes used in the extended error codes table by issuing
     function call 59h.  Handle function calls for DOS 3.x can return
     any of the error codes.  However, it is recommended that the
     function call be followed by function call 59h to obtain the
     error class, the locus, and the recommended action.

       The Get Extended Error function (59h) can always be called,
     regardless of whether the previous DOS call was old style (error
     code in AL) or new style (carry bit).  It can also be used inside
     an int 24h handler.

       You can either check AL or the carry bit to see if there was no
     error, and call function 59h only if there was an error, or take
     the simple approach of always calling 59h and letting it tell you
     if there was an error or not.  When you call function 59h it will
     return with AX=0 if the previous DOS call was successful.

       Various versions of IBM's DOS, MSDOS, OEM customized versions
     of MSDOS, Digital's DRDOS, and other DOS emulating environments
     sometimes return different error codes for the same function.
     Be careful if you are testing for one specific error condition.

entry   AH      59h
        BX      version code (0000 for DOS 3.0 and 3.1)
return  AX      extended error code:
                01h     Invalid function number                     2.0+    
                02h     File not found                              2.0+    
                03h     Path not found                              2.0+    
                04h     Too many open files, no file handles left   2.0+    
                05h     Access denied                               2.0+    
                06h     Invalid handle                              2.0+    
                07h     Memory control blocks destroyed             2.0+    
                08h     Insufficient memory                         2.0+    
                09h     Invalid memory block address                2.0+    
                0Ah     Invalid environment                         2.0+    
                0Bh     Invalid format                              2.0+    
                0Ch     Invalid access code                         2.0+    
                0Dh     Invalid data                                2.0+    
                0Eh     Reserved                                    2.0+    
                0Fh     Invalid drive was specified                 2.0+    
                10h     Attempt to remove the current directory     2.0+    
                11h     Not same device                             2.0+    
                12h     No more files                               2.0+    
                13h     Tried to access write-protected diskette    2.0+    
                14h     Unknown unit                                2.0+    
                15h     Drive not ready                             2.0+    
                16h     Unknown command                             2.0+    
                17h     Bad CRC check                               2.0+    
                18h     Bad request structure length                2.0+    
                19h     Seek error                                  2.0+    
                1Ah     Unknown media type                          2.0+    
                1Bh     Sector not found                            2.0+    
                1Ch     Printer out of paper                        2.0+    
                1Dh     Write fault                                 2.0+    
                1Eh     Read fault                                  2.0+    
                1Fh     General failure                             2.0+    
                20h     Sharing violation                           3.0+    
                21h     Lock violation                              3.0+    
                22h     Invalid disk change                         3.0+    
                23h     FCB unavailable                             3.0+    
                24h     Sharing buffer overflow                     3.3+    
                25h     Bad code page                               4.0+    
                26h     Handle EOF                                  4.0+    
                27h     Handle disk full                            4.0+    
                28h     Reserved
                29h        "
                2Ah        "
                2Bh        "
                2Ch        "
                2Dh        "
                2Eh        "
                2Fh        "
                30h        "
                31h     Reserved
                32h     Network: request not supported              3.1+    
                33h     Network: remote computer not listening      3.1+    
                34h     Network: duplicate name on network          3.3+    
                35h     Network: name not found                     3.3+    
                36h     Network: busy                               3.3+    
                37h     Network: device no longer exists            3.3+    
                38h     Network: NETBIOS command limit exceeded     3.3+    
                39h     Network: adapter hardware error             3.3+    
                3Ah     Network: incorrect response from network    3.3+    
                3Bh     Network: unexpected network error           3.3+    
                3Ch     Network: incompatible remote adapter        3.3+    
                3Dh     Network: print queue full                   3.3+    
                3Eh     Network: not enough space for print file    3.3+    
                3Fh     Network: print file was deleted             3.3+    
                40h     Network: name was deleted                   3.3+    
                41h     Network: access denied                      3.3+    
                42h     Network: device type incorrect              3.3+    
                43h     Network: name not found                     3.3+    
                44h     Network: name limit exceeded                3.3+    
                45h     Network: NETBIOS session limit exceeded     3.3+    
                46h     Network: sharing temporarily paused         3.3+    
                47h     Network: request not accepted               3.3+    
                48h     Network: print or disk redirection paused   3.1+    
                49h     Reserved
                4Ah        "
                4Bh        "
                4Ch        "
                4Dh        "
                4Eh        "
                4Fh     Reserved
                50h     File exists                                 3.3+    
                51h     Reserved                                    3.3+    
                52h     Cannot make directory entry                 4.0+    
                53h     Fail on interrupt 24h                       3.3+    
                54h     Network: too many redirections              3.3+    
                55h     Network: duplicate redirection              3.3+    
                56h     Invalid password                            3.3+    
                57h     Invalid parameter                           3.3+    
                58h     Network: data fault (write error)           3.3+    
                59h     Reserved                                            
                5Ah     Comp not loaded                             5.0+    
        BH      class of error:                          (DOS 5.0 name)
                01h     Out of resource                 ERRCLASS_OUTRES
                        (not enough disk space, etc)
                02h     Temporary situation             ERRCLASS_TEMPSIT
                        (not an error, but a temporary situation that is
                         expected to end, such as a locked region in a
                         file)
                03h     Authorization                   ERRCLASS_AUTH
                        (denied access - sharing or network)
                04h     Internal                        ERRCLASS_INTRN
                        (DOS internal error)
                05h     Hardware failure                ERRCLASS_HRDFAIL
                        (bad floppy or HD controller, etc.)
                06h     System failure                  ERRCLASS_SYSFAIL
                        (error not due to executing program, such as
                         missing configuration or data files)
                07h     Application program error       ERRCLASS_APPERR
                        (executing program bombed)
                08h     Not found                       ERRCLASS_NOTFND
                        (file or device not found)
                09h     Bad format                      ERRCLASS_BADFMT
                        (file or item invalid format or type)
                0Ah     Locked                          ERRCLASS_LOCKED
                        (network or SHARE lock)
                0Bh     Media error                     ERRCLASS_MEDIA
                        (wrong volume ID, disk failure)
                0Ch     Already exists                  ERRCLASS_ALREADY
                        (file or device already exists)
                0Dh     Unknown                         ERRCLASS_UNK
                        (Smurfs infesting system board)
        BL      suggested action code:
                01h     Retry                           ERRACT_RETRY
                02h     Delayed retry                   ERRACT_DLYRET
                03h     Prompt user                     ERRACT_USER
                04h     Abort after cleanup             ERRACT_ABORT
                05h     Immediate abort                 ERRACT_PANIC
                06h     Ignore                          ERRACT_IGNORE
                07h     Retry after user intervention   ERRACT_INTRET
        CH      locus (where error occurred):
                01h     Unknown or not appropriate      ERRLOC_UNK
                02h     Block device                    ERRLOC_DISK
                03h     Network related                 ERRLOC_NET
                04h     Serial device                   ERRLOC_SERDEV
                05h     Memory related                  ERRLOC_MEM
note 1) Not all DOS functions use the carry flag to indicate an error.
        Carry should be tested only on those functions which are
        documented to use it.
     2) None of the DOS functions which existed before 2.0 use the
        carry indicator.  Many of them use register AL as an error
        indication instead, usually by putting 0FFh in AL on an error.
        Most, but not all, the "new" (2.x, 3.x) functions do use carry,
       and most, but not all, of the "old" (1.x) functions use AL.
     3) On return, CL, DI, DS, DX, ES, BP, and SI are destroyed - save
        before calling this function if required.
     4) DOS 2.x Error Codes:  If you are using function calls 38h-57h
        with DOS 2.x, to check if an error has occurred, check for the
        following error codes in the AX register:
        call| error code    call| error code     call| error code
        ----|-------------------|--------------------|----------------
        38h | 2             41h | 2,3,5          4Ah | 7,8,9
        39h | 3,5           42h | 1,6            4Bh | 1,2,3,5,8,10,11
        3Ah | 3,5,15        43h | 1,2,3,5        4Eh | 2,3,18
        3Bh | 3             44h | 1,3,5,6        4Fh | 18
        3Ch | 3,4,5         45h | 4,6            56h | 2,3,5,17
        3Dh | 2,3,4,5,12    46h | 4,6            57h | 1,6
        3Eh | 6             47h | 15
        3Fh | 5,6           48h | 7,8
        40h | 5,6           49h | 7,9
     5) Note that extended error codes 13h through 1Fh correspond to
        error codes 00h through 0Ch returned by int 24h.
     6) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.


Function  5Ah   Create Temporary File
                Create unique filename (for temporary use) (DOS 3.0+)
entry   AH      5Ah
        DS:DX   pointer to buffer containing an ASCIIZ directory
                pathname ending with a backslash (\).  The buffer must
                have at least 13 bytes free following the backslash,
                as the file name and extension will be written there.
        CX      file attribute (00h, 01h, 02h, 04h, 20h only)
return  CF      clear   AX      handle
                        DS:DX   new ASCIIZ pathname
                set     AX      error code (03h, 04h, 05h)
note 1) The file created is not truly "temporary".  It must be removed
        by the user.
     2) If the filename created already exists in the current
        directory, this function will call itself again with another
        unique filename until a truly unique filename is found.
     3) The temporary filename usually consists of mixed letters and
        numbers.  No file extension appears to be generated.
     4) DOS 3.0-4.01 used mixed letters and numbers.  MS DOS 5.0 appears
        to use letters only.  DR DOS 5.0 appears to use numbers only.
     5) Under DOS 3.1+ and NETBIOS compatible networks, DOS opens the 
        file in compatibility mode.
     6) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     7) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  5Bh   Create a New File   (DOS 3.0+)
entry   AH      5Bh
        DS:DX   segment/offset pointer to an ASCIIZ pathname
        CX      file attribute (00h, 01h, 02h, 04h, 20h only)
return  CF      clear   AX      file handle
                        DS:DX   new ASCIIZ pathname
                set     AX      error code (03h, 04h, 05h, 50h)
note 1) Unlike function 3Ch, function 5Bh will fail if the file already
        exists.  This is useful on networks, since another application
        might create a file of the same name with 3Ch first, causing
        the first 3Ch to fail.  Use of this call instead of 3Ch is good
        practice for code that will not need to run under DOS 2.x.
     2) Under DOS 3.1+ networks, DOS opens the file in read/write mode.
        This call will fail if the user does not have Create access.
     3) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     4) The MSDOS Encyclopedia suggests this call may be used to
        implement semaphores in LANs or multitasking environments.  A
        zero-byte marker file could be created to indicate semaphore set.
     5) For PC-MOS/386 native mode, use DS:EDX instead of DS:DX.


Function  5Ch   Lock/Unlock File Access   (DOS 3.0+)
entry   AH      5Ch
        AL      00h     to lock file region
                01h     to unlock file region
        BX      file handle
        CX:DX   4-byte starting offset from beginning of file of region
                to lock
        SI:DI   4-byte integer, high/low size of region to lock
                (in bytes)
return  CF      clear   successful
                set     AX      error code (01h, 06h, 21h, 24h)
note 1) Unlock all files before exiting or undefined results may occur.
        Programs using file locking should trap int 23h (Control-C
        Handler Address) and int 24h (Critical Error Handler Address)
        and unlock files before returning to the caller.
     2) Programs spawned with EXEC inherit all the parent's file
        handles but not the file locks.
     3) This call is explicitly supported in the OS/2 1.x DOS
        Compatibility Box.
     4) You may lock an entire file, any part of a file, or several
        parts of the same file.  For example, it would be more
        efficient to lock an area in a database containing a single
        record than to lock the entire file.  If two adjacent sections
        of a file are locked separately, they  must be unlocked
        separately - you cannot change the lock pointers and use a
        single unlock call.
     5) You should lock only as much of a file as you need and keep
        the lock only for as long as necessary.  Should a file need to
        be shared and updated often, continual locking and unlocking
        can slow file access detectably.
     6) This call returns error 01h if SHARE is not loaded.
     7) Locked files must be unlocked before the program terminates,
        or the result is undefined.
     8) A transaction-oriented algorithm for using locking is
        recommended.  In effect, assert lock, read data, change data,
        remove lock.  An application should release its lock when a
        transaction is complete.
     9) Locking past end-of-file does not cause an error.
    10) Locking a portion of a file with fn 5Ch denies all other
        processes both read and write access to the locked region.
    11) For PC-MOS/386 native mode, use ECX and EDX instead of CX:DX.


Function  5Dh   Multifunction, DOS  Internal - partial (DOS 3.x+)
entry   AH      5Dh
        AL      subfunction
                00h     Indirect Function Call
                        DS:DX   pointer to buffer containing register
                                values AX, BX, CX, DX, SI, DI, DS, ES
                                for a call to int 21h
                        return  as appropriate for function being called
                        note    Does not check AH.  Out of range values
                                will crash the system.
                01h     SYNC?  (DOS 3.1+)
                        parameters unknown
                        note 1) Does something to each disk file in the
                                system.  File Table which has been
                                written to.
                             2) If remote file, calls int 2Fh/fn1107h.
                             3) Seems to update the time stamp of all
                                open files which have been written to.
                02h     SHARE.EXE? (DOS 3.1+)
                        note    Error unless SHARE is loaded
                                (calls fn 52h+4Ah)
                03h     SHARE.EXE? (DOS 3.1+)
                        note    Error unless SHARE is loaded
                                (calls fn 52h+4Ah)
                04h     SHARE.EXE functions? (DOS 3.1+)
                        note    Error unless SHARE is loaded
                                (calls fn 52h+4Ah)
                05h     Network functions? (DOS 3.1+)
                        DS:DX   pointer to buffer (see AX=0Ah), only
                                fields at offset 12h, 14h used
                        note    Error unless SHARE is loaded
                                (calls fn 52h+5Ah)
                06h     Get Address of Critical Error Flag
                        DS:DX   pointer to buffer (see 0Ah), only
                                fields at offset 12h, 14h used
                        return  CX      unknown value
                                DX      unknown value
                                DS:SI   pointer to critical error flag
                        notes   This call does a lot of other work in
                                addition to returning the pointer.
                                Setting the CritErr flag allows use of
                                functions 50h/51h from int 28h under
                                DOS 2.x by forcing use of correct stack.
    (LANtastic) 07h     Return Redirected Printer mode
                        return  DL      00      output is combined
                                        01h     output is separated
                        note    The current printer mode (either
                                printer output combined or separated)
                                is returned.
    (LANtastic) 08h     Set Redirected Printer Mode
                        DL      00h     set redirected output to be
                                        combined
                                01h     set redirected output to be
                                        separated.  (implicitly starts
                                        a new print job)
                        return  none
                        note 1) The current printer mode (either printer
                                output combined or separated) can be set.
                             2) may be used by COMMAND.COM
    (LANtastic) 09h     Flush Printer Output
                        return  none
                        note 1) Printer output is flushed and a new
                                print job is started.  If no output
                                exists to be flushed then this function
                                has no effect.
                             2) may be used by COMMAND.COM
                09h     unknown - may be used by COMMAND.COM
(DOS 5, doc'd)  0Ah     Set Extended Error Information
                        DS:DX   address of 11-word error information 
                                table:
                                format of error information table:
                                offset  size    description
                                00h    word    value that next call to
                                               fn 59h  will return in AX
                                02h    word    value that next call to
                                               fn 59h will return in BX
                                04h    word    CX
                                06h    word    DX
                                08h    word    SI
                                0Ah    word    DI
                                0Ch    word    DS
                                0Eh    word    ES
                                10h    word    reserved (set to 0)
                                12h    word    user (computer) ID,
                                               0=local
                                14h    word    program ID, 0=local
                                               program
                return  none
return   DS:SI   (for 06h) pointer to critical error flag
note 1) Function 0Ah; DOS 3.1+.
     2) Function 06h; setting CritErr flag allows use of functions
        50h/51h from int 28h under DOS 2.x by forcing the use of the
        correct stack.
     3) Functions 07h, 08h, 09h are identical in DOS 3.1 and call int
        2Fh fn 1125h.


Function  5Eh   Network Printer
                DOS 3.1+ with Networks software
                PC-MOS/386 through 4.1 has limited support for functions
                5Eh through 5F04h.  The MOS NETBIOS driver must be
                loaded.  A device name is returned for 5E00h and an
                "end of list" status is returned for other functions.
entry   AH      5Eh
        AL      00h     Get Machine Name
                        DS:DX   pointer to 16-byte buffer for ASCIIZ name
                        return  CH      00h     if name not defined
                                        <>0     name is defined
                                CL      00h     name not set
                                        <>0     NetBIOS name number
                                DS:DX   pointer to ASCIIZ name if CH <>0
                                CF      set on error
                                        AX      error code (01h)
                        note 1) The ASCIIZ name is a 15 byte string
                                padded to length with zeroes.
                             2) The NETBIOS number in CL and name at
                                DS:DX are valid only if the value
                                returned in CH is <>0.
                01h     Set Machine Name
                        CH      00h     undefine name
                                <>0     define name
                        CL      name number
                        DS:DX   pointer to ASCIIZ name
                02h     Set Printer Control String
                        BX      redirection list index
                        CX      length of setup string (max 64 bytes)
                        DS:SI   pointer to ASCIIZ setup string buffer
                        return: CF      set on error
                                        AX      error code (01h)
                        note 1) Set printer setup sets a setup string
                                to be sent to the network printer
                                whenever a file is queued to the
                                printer.
                             2) LANtastic LANOS does not process this
                                request since printer setup strings are
                                controlled by the system administrator
                                using the NET_MGR program.  The system
                                call does not return an error, however.
                03h     Get Printer Control String
                        BX      redirection list index
                        ES:DI   pointer to 64-byte string buffer
                        return  CX      length of setup string
                                        (maximum 64 bytes)
                        return: CF      set on error
                                        AX      error code (01h)
                        note 1) This call will return the setup string
                                set with fn 02h above.
                             2) LANtastic LANOS does not process this
                                request since printer setup strings are
                                controlled by the system administer
                                using the NET_MGR program.  The system
                                call does not return an error, however,
                                and the length of the setup string (CX)
                                is 0.
                04h     DOS 3.1+ +Microsoft Networks - unknown
                        note    Calls int 2F/AX=111Fh with 5E04h on
                                stack.
                05h     DOS 3.1+ +Microsoft Networks - unknown
                        note    Calls int 2F/AX=111Fh with 5E05h on
                                stack.
                06h     DOS 3.1+ +Microsoft Networks - unknown
                        note    Calls int 2F/AX=111Fh with 5E06h on
                                stack.
return  CF      clear   successful
                set     error
                        AX      error code (01h for all listed subfns)
note 1) Used in IBM's & Microsoft's Network programs.
     2) Partial documentation in Fall 1985 Byte, in Advanced MS-DOS,
        in MS-DOS Encyclopedia, LANtastic Programmer's Manual.  
     3) These services require that the network software be installed.
     4) SHARE must be loaded or results can be unpredictable on 00h,
        or fail with 02h or 03h.
     5) The redirection entry index is an index into a table that
        identifies the printer as a device on the network.


Function  5Fh   Network Redirection
                (DOS 3.1+ and Microsoft Networks)
entry   AH      5Fh
        AL     *00h     Unknown
               *01h     Unknown
                02h     Get Redirection List Entry
                        BX      redirection entry index.  Index 0
                                specifies the first entry
                        DS:SI   pointer to 16 byte area which will
                                receive the ASCIIZ local device name
                        ES:DI   pointer to 128 byte buffer for the
                                ASCIIZ network device name
                        return  CF      set on error
                                        AX      error code (01h, 12h)
                                BH      device status flag
                                        (bit 0=0 if valid)
                                        (bit 0=1 if invalid)
                                        (bits 1-7 reserved)
                                BL      device type
                                        03      printer device
                                        04      drive device (file)
                                CX      value stored by fn 03h call.
                                        Should be 0 for compatiblity
                                        with LAN OS
                                DS:SI   pointer to 16 byte ASCIIZ local
                                        device name
                                ES:DI   pointer to 128 byte ASCIIZ
                                        network name
                        note 1) DX and BP are destroyed by this call.
                             2) This call returns information about a
                                single redirected device (see fn 03h).
                                This fn may be used to scan the list of
                                redirected devices.
                03h     Redirect Device - Make Assign List Entry
                        Redirects a workstation drive or device to a
                        server directory or device.
                        AX      error code if error
                        BL      device type
                                03h     printer device
                                04h     file device
                        CX      stored parameter value (0 for
                                compatibility with IBM PC Network
                                program and LANtastic)
                        DS:SI   pointer to 16-byte ASCIIZ source
                                device name for printer: PRN, LPT1,
                                LPT2, LPT3
                        ES:DI   pointer to destination 128-byte
                                ASCIIZ network path and ASCIIZ
                                password  (e.g.,'\\machine_name\path',
                                0,'password',0)
                        return  CF      set on error
                                        AX      error code (01h, 03h,
                                                05h, 08h, 0Fh, 12h)
                        note 1) Redirect device allows you to connect
                                local devices to network paths.  For
                                example you can connect your LPT1 to
                                a printer on another node.  References
                                to LPT1 are routed to the network.
                             2) If the password is omitted, the
                                pathname must be followed by two null
                                bytes.
                             3) For printer redirection, MS-Network
                                intercepts int 17h.  When redirection
                                is canceled, all printing is sent to
                                the first local printer. (LPT1)
                04h     Cancel Redirection Assignment
                        DS:SI   pointer to ASCIIZ device name or
                                network path to be canceled
                        return  CF      set on error
                                        AX      error code (01h, 03h,
                                                05h, 08h, 0Fh, 12h)
                        note 1) Cancel device redirection allows you
                                to remove a device redirection so that
                                the device is restored to its former
                                state.
return  CF      clear   successful
                set     if error
                        AX      error code
                                (fn 02h) 01h, 12h
                                (fn 03h) 01h, 03h, 05h, 08h
                                (fn 04h) 01h, 0Fh
note 1) Used in IBM's Network program and Microsoft MS-Networks.
     2) Partial documentation in Fall 1985 Byte, in Advanced MS-DOS,
        in the MS-DOS Encyclopedia, LANtastic Programmer's Manual.  
     3) These services require that the network software be installed.
     4) SHARE must be loaded or the call will fail.
     5) The network device name requires a password.
     6) Only printer and disk devices are supported for redirection.
        STDAUX, STDIN, STDOUT, and STERR are not supported by the
        Microsoft/IBM specification.   Other companies have managed
        to do this with various nonstandard additions to the API.


Function  60h   Parse pathname  (TRUENAME)     (DOS 3.0+)
 *              Perform name processing on a string (internal to DOS)
entry   AH      60h
        DS:SI   pointer to ASCIIZ source string (null terminated)
        ES:DI   pointer to destination 80 byte ASCIIZ string buffer
return  ES:DI   buffer filled with qualified name in form (drive):(path)
        CF      set     error
                        AX      error code (02h, 03h)
                clear   no error
note 1) Documented in Zenith 3.05 Technical Reference.
     2) All name processing is performed on the input string; string
        substitution is performed on the components, current drive/
        directories are prepended, .  and ..  are removed.  Under most
        networking software, the drive letter is replaced with the node
        name, i.e. returns pathname like \\SERVER\UTILS\TEST.TXT
        instead of F:\UTILS\TEST.TXT.
     3) Example: If current drive/directory is C:\TEST,  MYFILE.X is
        translated to C:\TEST\MYFILE.X; ..\SOURCE\SAMPLE.ASM is 
        translated to C:\SOURCE\SAMPLE.ASM.
     4) It is the caller's responsibility to make sure DS:SI does not
        point to a null string.  If it does, SI is incremented, a null
        byte is stored at ES:DI, and the routine returns.
     5) Used by CHKDSK, at least in DOS 3.3, and DOS 3.x.
     6) If path string is on a JOINed drive, the returned name is the
        one that would be needed if the drive were not JOINed;
        similarly for a SUBSTed drive letter.  Because of this, it is
        possible to get a qualified name that is not legal with the
        current combination of SUBSTs and JOINs.
     7) Used by DOS 4.0 SHELLC.EXE.
     8) This call has been discovered in DOS versions as early as
        2.11.
     9) In Novell Netware 2.1x, this call is not supported when the
        8th bit (high ASCII) is set on any letter in the file or
        pathname, and when the file being inquired about is on a
        remote drive.  This causes problems with machines using
        foreign code pages.
    10) You need DPMI services to use this call under MS Windows 3.x.
        There is an example in PC Magazine, 25 June 1991, p. 389
        called TRUENAME.C.


Function  61h   undocumented - (DOS 3.0)
 *              Internal to DOS - parameters not known
entry   AH      61h
return  AL      00h
note    Supposedly documented in Zenith DOS 3.05 Technical Reference.


Function  62h   Get Program Segment Prefix (PSP) (DOS 3.0+)
entry   AH      62h
return  BX      segment address of PSP
note    Under DOS 3.x+, this function does not use any of DOS' internal
        stacks and is thus fully reentrant.


Function  63h   Get Lead Byte Table  (MS-DOS 2.25 only)
                Added in DOS 2.25 for additional foreign character
                set support.
entry   AH      63h
        AL      subfunction
                00h     get system lead byte table address
                01h     set/clear interim console flag
                        DL      0000h   to clear interim console flag
                                0001h   to set interim console flag
                02h     get interim console flag
return  DS:SI   pointer to lead byte table (AL = 00h)
        DL      interim console flag (AL = 02h)
note 1) Function 63h destroys all registers except SS:SP on return.
        To avoid saving registers repeatedly, a process can copy the
        table or save the pointer for later use.
     2) Works ONLY in MS-DOS 2.25!
     3) Note fn 63h does not return errors in AL or CF.
     4) Original support was for Kanji (Japanese) and Hanegul (Korean)
        only.
     5) The lead byte table contains pairs of bytes that represent the
        inclusive boundary values for the lead bytes of the specified
        alphabet.  Because of the way bytes are ordered by the 8086
        microprocessor family, the values must be read as byte values,
        not as word values.
     6) If the interim console flag is set (DL=0001h) by a program
        through a call to fn 63h, the following int 21h functions
        return interim character information on request: 07h, 08h,
        0Bh, 0Ch.


Function  64h   Undocumented - Used internally by DOS
entry   AH      64h
return  unknown
note 1) DOS 3.2+ internal function of some type? May be a network
        function.
     2) In DOS 3.31 it seems that when you load AL with a nonzero
        number, int 28h will get called more often.  AL=0 resets back
        to the default "boot up" state.


Function  65h   Get Extended Country Information (DOS 3.3+)
                Returns information about the selected country
                formats, code pages, and conversion tables
entry   AH      65h
        AL      information ID code
                01h     get general internationalization info
                02h     get pointer to uppercase table (130 bytes max)
                        (maps chars 80h-0FFh to their uppercase
                         equivalents, if any; used mainly to map
                         accented or other vowels to the corresponding
                         plain vowels)
                03h     unknown
                04h     get pointer to filename uppercase table (130
                        bytes max) (similar to table for AL = 02h)
   (DOS 5.0+)   05h     get filename character table - specifies which
                        chars must not be used in filenames.
                06h     get pointer to collating sequence table (258
                        bytes max)  (maps uppercase, lower, and
                        accented chars together for sorting)
                07h     get pointer to double-byte character set table
   (DOS 5.0+)   20h     convert character - converts character in DL to
                        uppercase using the current uppercase table
   (DOS 5.0+)   21h     convert string - converts string in DS:DX,
                        length CX to uppercase using current uppercase
                        table, returns in DS:DX
   (DOS 5.0+)   22h     convert ASCIIZ string - converts string in
                        DS:DX to uppercase using current uppercase
                        table, returns in DS:DX

        BX      code page (0FFFFh = current code page)
        CX      amount of information to be returned (minimum 5)
        DX      target country ID (0FFFFh = default current country)
        ES:DI   segment/offset pointer to country information buffer
return  CF      set on error
                AX      error code (02h)
                        otherwise:
        CX      size of country information returned
        ES:DI   pointer to country information:
              offset   length   description
                00h   1 byte    info ID  (for all following buffers)
        If information ID code <> 1:
                01h     dword  pointer to information
        If information ID code = 1:
                01h     word    length of remainder of buffer (<= 38)
                03h     word    country ID
                05h     word    code page number
                07h  34 bytes   same as for int 21h function 38h
        If information ID code = 2:
                01h     word    table size
                05h     dword   pointer to uppercase table
            128 bytes uppercase equivalents (if any) of chars 80h-0FFh
        If information ID code = 4:
                01h     word    table size
                05h     dword   pointer to collating table
            256 bytes   values used to sort characters 00h-0FFh
        If information ID code = 6:
                01h     word    table size
                05h     dword   pointer to filename uppercase table.
                                This table starts with a 2-byte length
                                field, then 256 ASCII values placed in
                                order
            128 bytes   uppercase equivalents (if any) of chars
                        80h-0FFh
        If information ID code = 7: (DOS 4.0)
                unknown
note 1) For AL=02h, 04h, or 06h, the first two bytes of the table
        give its length and then a 128 byte table of uppercase ASCII
        characters for 02h or 04h and a pointer to the collating
        sequence for 06h.
     2) The country code and code page must match.  If not, error 02h
        is in AX.
     3) If more information is provided than was requested by CX, it
        is truncated without generating an error.
     4) Country information:
        bytes   description
        01h     value of AL (01h)
        02h,03h size (max = 38)
        04h,05h country code
        06h,07h code page
        08h,09h date format
        0Ah,0Eh currency symbol
        0Fh,10h thousands separator
        11h,12h decimal separator
        13h,14h date separator
        15h,16h time separator
        17h     currency format flags
        18h     digits in currency
        19h     time format
        20h-22h monocase routine entry point
        23h-24h data list separator
        25h-29h zeros


Function  66h   Get/Set Global Code Page Table (DOS 3.3+)
                Query/reset code page defaults
entry   AH      66h
        AL      00h     Get Global Code Page
                01h     Set Global Page
                        BX      active code page
                        DX      system code page
                                (active page at boot time)
return  CF      clear  successful
                set    AX       error code (unknown)
        if 00h         BX       active code page
                       DX       system code page
                                (active page at boot time)
note 1) BX = active code page: 437 = US, 860 = Portugal, 863 = Canada
                               (French) 865 = Norway/Denmark, 850 =
                               multilingual
     2) MS 5.0 TR shows fns as 01h and 02h.


Function  67h   Set Handle Count  (DOS 3.3+)
                Supports more than 20 open files per process
entry   AH      67h
        BX      desired number of handles (20 to 65,535)
return  CF      clear   if OK
                set     if error
                AX      error code (unknown)
note 1) This function changes the 20-byte handle table pointer in the
        PSP to point to a new, larger handle table elsewhere in memory.
     2) The memory the 67h call allocates is taken from the normal
        DOS pool, and is reclaimed on process termination, so nothing
        is lost.
     3) When calling this function you must release enough memory for
        DOS to contain the extended handle list.
     4) If the requested number of handles is less than 20 nothing
        is done.
     5) Early versions of PC-MOS/386 v4.1 did not properly deallocate
        memory when the number of handles was reduced.
     6) The error value returned in AX is not documented in the IBM
        4.0 DOS Technical Reference, the MSDOS Encyclopedia or the MS
        5.0 TR.
     7) For PC-MOS/386 4.x, the only error code is 08h (insufficient
        memory).


Function  68h   Commit File (DOS 3.3+)
                Write all buffered data to disk
entry   AH      68h
        BX      file handle of previously opened file
return  CF      clear   successful
                set     on error
                        AX      error code (unknown)
note 1) Faster and more secure method of closing a file in a network
        than current close commands.
     2) This is effectively the same as DUPing the handle for a file
        and then closing the new one, except that this call won't fail
        if the system is out of handles.
     3) The file's buffers are flushed and its directory and FAT
        entries are updated.
     4) The error value returned in AX is not documented in the IBM
        4.0 DOS Technical Reference, the MSDOS Encyclopedia or the MS
        5.0 TR.
     5) For PC-MOS/386 4.x, the error codes are 06h (invalid handle)
        and 22h (wrong disk).


Function  69h   Disk Serial Number  DOS 4.0+ (US versions)
                Handles "Volume Serial Number" on disks formatted with
                DOS 4.0+
entry   AH      69h     Get Volume Serial Number
        AL      00h     get serial number
                01h     set serial number
        BL      drive (0=default, 1=A, etc)
        DS:DX   pointer to disk information table
return  CF      set     on error
                AX      error code
                clear   if successful
                AH      destroyed
                AL      (fn 00h) buffer filled with appropriate values
                                 from extended BPB
                        (fn 01h) extended BPB on disk set to values
                                 from buffer
        DS:DX   disk information table. Format:
                offset  size    description
                00h     word    unknown (zeroes on my system)
                02h    dword    disk serial number (binary)
                06h 11 bytes    volume label or "NO NAME    " if none
                11h  8 bytes    FAT type - string "FAT12   " or
                                "FAT16   "
note 1) The FAT type field refers to the number of bits per directory
        entry.
     2) Does not generate a critical error; all errors are returned
        in AX.
     3) Error 0005h given if no extended BPB on disk.
     4) Does not work on network drives (error 0001h).
     5) Buffer after first two bytes is exact copy of bytes 27h thru
        3Dh of extended BPB on disk.
     6) FORMAT (in DOS 5.0) does not call int 21h/fn 69h. (Get/Set 
        Volume Serial Number)  For floppy disks, it calls int 21h/fn 
        440Dh, CH=08, CL=46 [Set Media ID], and passes the serial 
        number.   (from dsparks, BIX) 


Function  6Ah   Unknown  (DOS 4.0?)


Function  6Bh   Unknown  (DOS 4.0?)


Function  6Ch   Extended Open/Create  DOS 4.0+ (US)
                Combines functions available with Open, Create, Create
                New, and Commit File
entry   AH      6Ch
        AL      00h  reserved  [which means there might be other
                                subfunctions?]
        BX      mode    format  0WF0 0000 ISSS 0AAA
                                AAA is access code (read, write,
                                                    read/write)
                                SSS is sharing mode
                                I       0       pass handle to child
                                        1       no inherit [interesting!]
                                F       0       use int 24h for errors
                                        1       disable int 24h for all
                                                I/O on this handle; use
                                                own error routine
                                W       0       no commit
                                        1       auto commit on all writes
        CX      create attribute
           bits 0       read only
                1       hidden
                2       system
                3       volume label
                4       reserved
                5       archive
                6-15    reserved
        DH      00h (reserved)
        DL      action if file exists/does not exists
           bits 0-3     action if file exists
                        0000    fail
                        0001    open
                        0010    replace/open
                4-7     action if file does not exist
                        0000    fail
                        0001    create
        DS:SI   pointer to ASCIIZ file name
return  CF      set on error
                AX      error code (unknown)
                clear
                AX      file handle
                CX      action taken
                        01h     file opened
                        02h     file created/opened
                        03h     file replaced/opened
note    When APPEND is installed, if DX=xx1x it looks only in current
        directory, if DX=xx0x it will search the full append path.
        DX is called the open flag and gives what action to take if
        the file exists or does not exist.


Function  89h   undocumented - DOS_Sleep
 *              Not documented by Microsoft
entry   AH      89h
return  unknown
note 1) Function included in Microsoft C 4.0 startup code MSDOS.INC.
     2) Debugging shows that the first instruction on entry to DOS
        compares AH with 64h (at least in DOS 3.2) and aborts the
        call if AH > 64.
     3) Possibly used in European MSDOS 4.0?



Aftermarket Application Installed Function Calls:

Novell Netware 2.11:
        Novell no longer recommends the int 21h method for invoking
        the Netware functions.  Int 21h will be supported
        indefinitely, but the new net API calls for addressing the
        software through the Multiplex Interrupt (2Fh).  You may
        address the API through int 2Fh in the same manner as int 21h;
        only the interrupt number is different.

        Novell API calls are referenced in Chapter 13.  Most functions
        from 0B6h through 0F9h are preempted by NetWare; if your
        software uses any of these calls for another purpose it will
        likely not run under NetWare.

NOTE:   Novell (and most others') network software and SoftLogic's
        DoubleDOS conflict on the following int 21h functions
        0EAh-0EEh.  Netware must use int 2Fh functions instead of 21h
        functions if DoubleDOS will be used on the network.


Functions 0E0h - 0F6h: used by AI Architects/Ergo Computing
          DOS extender


Functions 0E4h - 0EEh: used by DoubleDOS task switcher


Function  0FEh  Enable Reader v4.0 API
                Enable Reader is a speech synthesizer interface for
                the blind.  It will save all registers except the
                flags, where the zero flag will be set if the call was
                not one of the available Enable Reader 4.0 functions.

entry   AH      0FEh
        AL      01h     Driver Output
        DL      Character To Output
return  none
note    The Driver Output call will output the character in DL through
        the Enable Reader driver, without turning off the Help
        Functions.  It will be filtered by the ASCII sort routine in
        the Enable Reader Driver, and if it is punctuation it will be
        sent according to the level of punctuation selected.

entry   AH      0FEh
        AL      02h     Direct Output
        DL      ASCII character to output
return  none
note    The Direct Output call will send the byte in DL directly to
        the synthesizer, bypassing the Enable Reader driver and ASCII
        filter sort routine.

entry   AH      0FEh
        AL      03h     Message Output
        DL      character to output
return  none
note    The Message Output call allows character filtration and
        punctuation, but turns off the Help functions in the driver.

entry   AH      0FEh
        AL      41h (ASCII A) Auto
return  none
note    The AUTO call turns the Spell mode on or off.

entry   AH      0FEh
        AL      4Eh (ASCII N) Punctuation Levels
return  none
note    This call selects one of five Punctuation Character Sets that
        can be accessed.  The fifth level is "Output Punctuation",
        which allows all ASCII characters to be sent to the synthesizer
        without being filtered or translated into the Enable Reader 4.0
        Punctuation Words.

entry   AH      0FEh
        AL      4Fh (ASCII O) Help Word Levels
return  none
note    The Help call selects one of four levels of help. By selecting
        "No Help" at the start of your program, you can use the other
        Help Functions without having them speak their prompts.

entry   AH      0FEh
        AL      51h (ASCII Q) Quit
return  none
note    This call will stop the synthesizer from speaking.

entry   AH      0FEh
        AL      5Ah (ASCII Z) Letter-to-Word Translator
return  none
note    This call turns the Letter-To-Word Translator on or off.
  For a discussion on the TRANSLATOR Function, read

entry   AH      0FEh
        AL      54h (ASCII T) Upper Case Identification
return  none
note    This call toggles identification of uppercase letters.

entry   AH      0FEh
        AL      56h (ASCII V) Video Output
return  none
note    The Video Output call toggles the output to the synthesizer
        from data that is printed on the video screen.


Function  0FFh  CED   (CJ Dunford's DOS macro and command-line editor)
                CED installable commands
entry   AH      0FFh
        AL      00h     Add Installable Command
                01h     Remove Installable Command
                02h     Reserved, may be used to test for CED
                        installation
        BL      mode byte
            bit 0       callable from DOS prompt
                1       callable from application
                2-7     not used in public domain CED
        DS:SI   pointer to CR-terminated command name
        ES:DI   pointer to far routine entry point
return  CF      set on error
        AX      01h     invalid function
                02h     command not found (subfunction 1 only)
                08h     insufficient memory (subfunction 0 only)
                0Eh     bad data (subfunction 0 only)
        AH      0FFh    if CED not installed
note 1) When PCED returns, AX and the flags are changed.  Other
        registers are preserved, except as noted.


   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                        C H A P T E R   F I V E

                      INTERRUPTS 22H THROUGH 0FFH


                            C O N T E N T S

Interrupt 22h   Terminate Address .............................. 5**1
Interrupt 23h   Ctrl-Break Exit Address ........................ 5**2
Interrupt 24h   Critical Error Handler ......................... 5**3
Interrupt 25h   Absolute Disk Read ............................. 5**4
Interrupt 26h   Absolute Disk Write ............................ 5**5
Interrupt 27h   Terminate And Stay Resident .................... 5**6
Interrupt 28h   DOS Idle Interrupt ............................. 5**7
Interrupt 29h   Fast Screen Write .............................. 5**8
Interrupt 2Ah   Microsoft Networks - Session Layer Interrupt ... 5**9
Interrupt 2Bh   Unknown ........................................ 5**10
Interrupt 2Ch   Unknown ........................................ 5**11
Interrupt 2Dh   Unknown ........................................ 5**12
Interrupt 2Eh   Alternate EXEC (DOS 2.0+) ...................... 5**13
Interrupt 2Fh   Multiplex Interrupt ............................ 5**14
Interrupt 30h   FAR jump instruction for CP/M-style calls ...... 5**15
Interrupt 31h   Unknown ........................................ 5**16
Interrupt 32h   Unknown ........................................ 5**17
Interrupt 33h   Used by Microsoft Mouse Driver Function Calls .. 5**18
Interrupt 34h   Turbo/Microsoft langs - Floating Point emul. ... 5**19
Interrupt 35h   Turbo/Microsoft langs - Floating Point emul. ... 5**20
Interrupt 36h   Turbo/Microsoft langs - Floating Point emul. ... 5**21
Interrupt 37h   Turbo/Microsoft langs - Floating Point emul. ... 5**22
Interrupt 38h   Turbo/Microsoft langs - Floating Point emul. ... 5**23
Interrupt 39h   Turbo/Microsoft langs - Floating Point emul. ... 5**24
Interrupt 3Ah   Turbo/Microsoft langs - Floating Point emul. ... 5**25
Interrupt 3Bh   Turbo/Microsoft langs - Floating Point emul. ... 5**26
Interrupt 3Ch   Turbo/Microsoft langs - Floating Point emul. ... 5**27
Interrupt 3Dh   Turbo/Microsoft langs - Floating Point emul. ... 5**28
Interrupt 3Eh   Turbo/Microsoft langs - Floating Point emul. ... 5**29
Interrupt 3Fh   Overlay Manager Interrupt (Microsoft LINK.EXE) . 5**30
Interrupt 40h   Hard Disk BIOS ................................. 5**31
Interrupt 41h   Hard Disk Parameters ........................... 5**32
Interrupt 42h   Pointer to screen BIOS entry ................... 5**33
Interrupt 43h   Pointer to EGA Graphics Character Table ........ 5**34
Interrupt 44h   Pointer to graphics character table ............ 5**35
Interrupt 45h   Reserved by IBM  (not initialized) ............. 5**36
Interrupt 46h   Pointer to second hard disk parameter block .... 5**37
Interrupt 47h   Reserved by IBM  (not initialized) ............. 5**38
Interrupt 48h   Cordless Keyboard Translation .................. 5**39
Interrupt 49h   Non-kbd Scan Code Translation Table Addr (PCjr)  5**40
Interrupt 4Ah   Real-Time Clock Alarm (Convertible, PS/2) ...... 5**41
Interrupt 4Bh   Reserved by IBM  (not initialized) ............. 5**42
Interrupt 4Ch   Reserved by IBM  (not initialized) ............. 5**43
Interrupt 4Dh   Reserved by IBM  (not initialized) ............. 5**44
Interrupt 4Eh   Reserved by IBM  (not initialized) ............. 5**45
Interrupt 4Fh   Reserved by IBM  (not initialized) ............. 5**46
Interrupt 50-57 IRQ0-IRQ7 Relocation ........................... 5**47
Interrupt 58h   Reserved by IBM  (not initialized) ............. 5**48
Interrupt 59h   Reserved by IBM  (not initialized) ............. 5**49
Interrupt 5Ah   Reserved by IBM  (not initialized)  ............ 5**50
Interrupt 5Bh   Reserved by IBM  (not initialized) ............. 5**51
Interrupt 5Ah   Cluster Adapter BIOS entry address ............. 5**52
Interrupt 5Bh   Reserved by IBM  (not initialized) ............. 5**53
Interrupt 5Ch   NETBIOS interface entry port, TOPS ............. 5**54
Interrupt 5Dh   Reserved by IBM  (not initialized) ............. 5**55
Interrupt 5Eh   Reserved by IBM  (not initialized) ............. 5**56
Interrupt 5Fh   Reserved by IBM  (not initialized) ............. 5**57
Interrupt 60h-67h  User Program Interrupts ..................... 5**58
Interrupt 60h   Network OS Interface ........................... 5**59
Interrupt 67h   Expanded Memory Board Driver Interrupt ......... 5**60
Interrupt 68h   Not Used  (not initialized) .................... 5**61
Interrupt 69h   Not Used  (not initialized) .................... 5**62
Interrupt 6Ah   Not Used  (not initialized) .................... 5**63
Interrupt 6Bh   Not Used  (not initialized) .................... 5**64
Interrupt 6Ch   System Resume Vector (Convertible) ............. 5**65
Interrupt 6Dh   Not Used  (not initialized) .................... 5**66
Interrupt 6Eh   Not Used  (not initialized) .................... 5**67
Interrupt 6Fh   10-Net API...................................... 5**68
Interrupt 70h   IRQ 8, Real Time Clock Int (AT, XT/286, PS/2) .. 5**69
Interrupt 71h   IRQ 9, Redirected to IRQ 8 (AT, XT/286, PS/2) .. 5**70
Interrupt 72h   IRQ 10  (AT, XT/286, PS/2)  Reserved ........... 5**71
Interrupt 73h   IRQ 11  (AT, XT/286, PS/2)  Reserved ........... 5**72
Interrupt 74h   IRQ 12  Mouse Interrupt (PS/2) ................. 5**73
Interrupt 75h   IRQ 13, Coprocessor Error (AT) ................. 5**74
Interrupt 76h   IRQ 14, Hard Disk Controller (AT, XT/286, PS/2)  5**75
Interrupt 77h   IRQ 15 (AT, XT/286, PS/2)  Reserved ............ 5**76
Interrupt 78h   Not Used ....................................... 5**77
Interrupt 79h   Not Used ....................................... 5**78
Interrupt 7Ah   Reserved ....................................... 5**79
Interrupt 7Bh-7Eh  Not Used by IBM ............................. 5**80
Interrupt 7Ch   REXX-PC API .................................... 5**81
Interrupt 7Fh   IBM 8514/A Graphics Adapter API ................ 5**82
Interrupt 80h-85h  Reserved by BASIC ........................... 5**83
Interrupt 86h   Int 18 when relocated by NETBIOS ............... 5**84
Interrupt 86h-0F0h  Used by BASIC when interpreter is running .. 5**85
Interrupt 0A4h  Right Hand Man API ............................. 5**86
Interrupt 0D4h  PC-MOS/386 API ................................. 5**87
Interrupt 0E0h  Digital Research CP/M-86 function calls ........ 5**88
Interrupt 0E1h  PC Cluster Disk Server Information ............. 5**89
Interrupt 0E2h  PC Cluster Program ............................. 5**90
Interrupt 0E4h  Logitech Modula-2 v2.0   Monitor Entry ......... 5**91
Interrupt 0E5h  Not Used ....................................... 5**92
Interrupt 0E6h  Not Used ....................................... 5**93
Interrupt 0E7h  Not Used ....................................... 5**94
Interrupt 0E8h  Not Used ....................................... 5**95
Interrupt 0E9h  Not Used ....................................... 5**96
Interrupt 0EAh  Not Used ....................................... 5**97
Interrupt 0EBh  Not Used ....................................... 5**98
Interrupt 0ECh  Not Used ....................................... 5**99
Interrupt 0EDh  Not Used ....................................... 5**100
Interrupt 0EEh  Not Used ....................................... 5**101
Interrupt 0EFh  GEM interface (Digital Research) ............... 5**102
Interrupt 0F0h  unknown ........................................ 5**103
Interrupts 0F1h-0FFh  (absolute addresses 3C4h-3FFh) ........... 5**104
Interrupt 0F4h  Not Used ............ .......................... 5**105
Interrupt 0F5h  Not Used ............ .......................... 5**106
Interrupt 0F8h  Set Shell Interrupt (OEM) ...................... 5**107
Interrupt 0F9h  Reserved ....................................... 5**108
Interrupt 0FAh  USART ready (RS-232C) .......................... 5**109
Interrupt 0FBh  USART RS ready (keyboard) ...................... 5**110
Interrupt 0FCh  Unknown ........................................ 5**111
Interrupt 0FDh  reserved for user interrupt .................... 5**112
Interrupt 0FEh  reserved by IBM ................................ 5**113
Interrupt 0FFh  reserved by IBM ................................ 5**114


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 22h   Terminate Address ............................. 5**1 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0088h)
  This interrupt transfers control to the far (dword) address at this 
interrupt location when an application program terminates.  The default 
address for this interrupt is 0:0088h through 0:008Bh.  This address is 
copied into the program's Program Segment Prefix at bytes 0Ah through 
0Dh at the time the segment is created and is restored from the PSP 
when the program terminates.  The calling program is normally 
COMMAND.COM or an application.  Do not issue this interrupt directly, 
as the EXEC function call does this for you.  If an application spawns 
a child process, it must set the Terminate Address prior to issuing 
the EXEC function call, otherwise when the second program terminated 
it would return to the calling program's Terminate Address rather than 
its own.  This address may be set with int 21, function 25h. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 23h   Ctrl-Break Exit Address ....................... 5**2 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:008Ch)
  If the user enters a Ctrl-Break during STDIN, STDOUT, STDPRN, or 
STDAUX, int 23h is executed.  If BREAK is on, int 23h is checked on 
MOST function calls (notably 06h).  If the user written Ctrl-Break 
routine saves all registers, it may end with a return-from-interrupt 
instruction (IRET) to continue program execution.  If the user-written 
interrupt program returns with a long return, the carry flag is used 
to determine whether the program will be aborted.  If the carry flag is 
set, the program is aborted, otherwise execution continues (as with a 
return by IRET).  If the user-written Ctrl-Break interrupt uses 
function calls 09h or 0Ah, (Display String or Buffered Keyboard Input) 
then a three-byte string of 03h-0Dh-0Ah (ETX/CR/LF) is sent to STDOUT. 
If execution is continued with an IRET, I/O continues from the start 
of the line.  When the interrupt occurs, all registers are set to the 
value they had when the original function call to DOS was made. 

  There are no restrictions on what the Ctrl-Break handler is allowed 
to do, including DOS function calls, as long as the registers are 
unchanged if an IRET is used. 

  If the program creates a new segment and loads a second program 
which itself changes the Ctrl-Break address, the termination of the 
second program and return to the first causes the Ctrl-Break address 
to be restored from the PSP to the value it had before execution of 
the second program. 

  DOS can check for a Ctrl-C at a couple of different places.  In at 
least some cases, the value in the AX register on entry to the int 23h 
handler is the same as it was on the original entry to int 21h. 

  COMMAND.COM makes use of this fact in its int 23h handler.  When 
running a batch file, if you press Ctrl-C it prompts you with the 
"Terminate batch job (Y/N)?" question.  If you press Ctrl-C in 
response to that question, the int 23h handler notices that it's being 
called recursively (having set an internal flag), and uses the value 
of AX to determine how far it had gotten on the previous pass.  If you 
have not responded to the query yet, it asks it again; otherwise it 
just terminates the current program. 

  This could cause a problem in a program which was catching int 23h 
so that it could release EMS or other resources  on exit, then pass it 
on to the original handler.  When called a second time, it would 
correctly notice that it had already cleaned up and wouldn't do it 
again, but by the time it got to the original handler, AX would be 
trashed.  The result would be the standard "Memory allocation 
error/Cannot load COMMAND, system halted". 

  Apparently, if you want to catch int 23h but also pass it on to the 
original handler, you should either save and restore registers, or 
restore the original vector on the first trap so you don't get invoked 
again. 



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 24h   Critical Error Handler ........................ 5**3 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0090h)

  When an unrecoverable I/O error occurs, control is transferred to an 
error handler in the resident part of COMMAND.COM with an int 24h.  
This may be the standard DOS error handler (Abort, Retry, Ignore, 
Fail?) or a user-written routine. 

  On entry to the error handler, AH will have its bit 7=0 (high order 
bit) if the error was a disk error (probably the most common error), 
bit 7=1 if not. 

  BP:SI contains the address of a Device Header Control Block from 
which additional information can be retrieved (see below).  The 
register is set up for a retry operation and an error code is in the 
lower half of the DI register with the upper half undefined. 

  DOS places the following items on the user stack.  The stack 
contains the following from top to bottom: 

        IP   ³   DOS registers from the issuing int 24h
        CS   ³
      flags  ³
      ÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
        AX   ³   user registers at time of original int 21h request
        BX   ³
        CX   ³
        SI   ³
        DI   ³
        BP   ³
        DS   ³
        ES   ³
      ÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
        IP   ³   original int 21h from the user to DOS
        CS   ³
      flags  ³

  To reroute the critical error handler to a user-written critical
error handler, the following should be done:

Before an int 24h occurs:
1) The user application initialization code should save the int 24h
   vector and replace the vector with one pointing to the user error
   routine.

When the int 24h occurs:
2) When the user error routine received control it should push the flag
   registers onto the stack and execute a far call to the original int
   24h vector saved in step 1.
3) DOS gives the appropriate prompt, and waits for user input (Abort,
   Retry, Ignore, Fail).  After the user input, DOS returns control to
   the user error routine instruction following the far call.
4) The user error routine can now do any tasks necessary.  To return
   to the original application at the point the error occurred, the
   error routine needs to execute an IRET instruction.  Otherwise, the
   user error routine should remove the IP, CS, and flag registers from
   the stack.  Control can then be passed to the desired routine.

  Int 24h provides the following values in registers on entry to the
interrupt handler:

entry   AH      status byte (bits)
                7       0       disk I/O hard error
                        1       other error - if block device, bad FAT
                                - if char device, code in DI
                6       unused
                5       0       if IGNORE is not allowed
                        1       if IGNORE is allowed
                4       0       if RETRY  is not allowed
                        1       if RETRY  is allowed
                3       0       if FAIL   is not allowed
                        1       if FAIL   is allowed
                2 \     disk area of error  00 = DOS area  01 = FAT
                1 /                         10 = root dir  11 = data area
                0       0       if read operation
                        1       if write operation
        AL      drive number if AH bit 7 = 1, otherwise undefined
                If it is a hard error on disk (AH bit 7=0), register AL
                contains the failing drive number (0=A:, 1=B:, etc.).
        BP:SI   address of a Device Header Control Block for which error
                occurred. Block device if high bit of BP:SI+4 = 1
        DI      (low byte) error code (note: high byte is undefined)
               error code                 description
                00h             attempt to write on write-protected diskette
                01h             unknown unit
                02h             drive not ready
                03h             unknown command
                04h             data error (bad CRC)
                05h             bad request structure length
                06h             seek error
                07h             unknown media type
                08h             sector not found
                09h             printer out of paper
                0Ah             write fault
                0Bh             read fault
                0Ch             general failure
                0Fh             invalid disk change      (DOS 3.0+)
                10h             FCB unavailable          (DOS 3.0+)
                11h             sharing buffer overflow  (DOS 3.0+)

        note: Only codes 00h through 0Ch are defined in DR-DOS 3.32.

The handler must return this information:

  The registers are set such that if an IRET is executed, DOS responds
according to (AL) as follows:
AL      00h     IGNORE the error
        01h     RETRY the operation
        02h     ABORT via int 22h (jump to terminate address)
        03h     FAIL the system call that is in progress (DOS 3.0+)
note 1) Be careful when choosing to ignore a response because this
        causes DOS to think that an operation has completed
        successfully when it may not have.
     2) If the error was a character device, the contents of AL are
        invalid.
     3) Early PS/2 BIOSes did not perform a retry on disk errors until
        a disk had been read at least once after boot-up.


Other Errors

  If AH bit 7=1, the error occurred on a character device, or was the 
result of a bad memory image of the FAT.  The device header passed in 
BP:SI can be examined to determine which case exists.  If the 
attribute byte high-order bit indicates a block device, then the error 
was a bad FAT.  Otherwise, the error is on a character device. 

  If a character device is involved, the contents of AL are 
unpredictable, and the error code is in DI as above. 

note 1) Before giving this routine control for disk errors, DOS 
        performs several retries.  The number of retries varies 
        according to the DOS version. 
     2) For disk errors, this exit is taken only for errors occurring 
        during an int 21h function call.  It is not used for errors 
        during an int 25h or 26h. 
     3) This routine is entered in a disabled state. 
     4) All registers must be preserved. 
     5) This interrupt handler should refrain from using DOS function 
        calls.  If necessary, it may use calls 01h through 12h.  Use 
        of any other call destroys the DOS stack and leaves DOS in an 
        unpredictable state. 
     6) The interrupt handler must not change the contents of the 
        device header. 
     7) If the interrupt handler handles errors itself rather than 
        returning to DOS, it should restore the application program's 
        registers from the stack, remove all but the last three words 
        on the stack, then issue an IRET.  This will return to the 
        program immediately after the int 21h that experienced the 
        error.  Note that if this is done DOS will be in an unstable 
        state until a function call higher than 12h is issued, 
        therefore not recommended. 
     8) For DOS 3.x+, IGNORE requests (AL=0) are converted to FAIL for 
        critical errors that occur on FAT or DIR sectors. 
     9) For DOS 3.10 up, IGNORE requests (AL=0) are converted to FAIL 
        requests for network critical errors (50-79). 
    10) The device header pointed to by BP:SI is as follows: 
       dword    pointer to next device (0FFFFh if last device)
        word    attributes:
                bit     15      1  if character device.
                                   If bit 15 is 1:
                                   bit 0 = 1 if current standard input
                                   bit 1 = 1 if current standard output
                                   bit 2 = 1 if current NULL device
                                   bit 3 = 1 if current CLOCK device
                                0  if block device.
                bit     14      is the IOCTL bit
        word    pointer to device driver strategy entry point
        word    pointer to device driver interrupt entry point
      8 bytes   character device named field for block devices.  The
                first byte is the number of units.
    11) To tell if the error occurred on a block or character device,
        look at bit 15 in the attribute field (WORD at BP:SI+4).
    12) If the name of the character device is desired, look at the
        eight bytes starting at BP:SI+10.


Handling of Invalid Responses (DOS 3.0+)

     A) If IGNORE (AL=0) is specified by the user and IGNORE is not 
        allowed (bit 5=0), make the response FAIL (AL=3). 
     B) If RETRY (AL=1) is specified by the user and RETRY is not 
        allowed (bit 4=0), make the response FAIL (AL=3). 
     C) If FAIL (AL=3) is specified by the user and FAIL is not 
        allowed (bit 3=0), make the response ABORT. (AL=2) 




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 25h   Absolute Disk Read ............................ 5**4 ³
³Interrupt 26h   Absolute Disk Write ........................... 5**5 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0094h, 0:0098h)

  These transfer control directly to the disk device driver.  On 
return, the original flags are still on the stack (put there by the 
INT instruction).  This is necessary because return information is 
passed back in the current flags. All registers except the segment 
registers are destroyed by these calls. 

  These interrupts should be avoided for software that is intended to 
run on a network, as they may cause troubles in network environments. 

  PC-MOS/386 provides these services only for compatibility with 
existing DOS-mode apps.  25h/26h are not available for native mode 
386-mode DOS apps. 

  The number of sectors specified is transferred between the given 
drive and the transfer address.  Logical sector numbers are obtained 
by numbering each sector sequentially starting from track 0, head 0, 
sector 1 (logical sector 0) and continuing along the same head, then 
to the next head until the last sector on the last head of the track 
is counted.  Thus, logical sector 1 is track 0, head 0, sector 2; 
logical sector 2 is track 0, head 0, sector 3; and so on.  Numbering 
then continues wih sector 1 on head 0 of the next track.  Note that 
although the sectors are sequentially numbered (for example, sectors 2 
and 3 on track 0 in the example above), they may not be physically 
adjacent on disk, due to interleaving.  Note that the mapping is 
different from that used by DOS 1.10 for double-sided diskettes. 

 The request is as follows:

int 25h for Absolute Disk Read,      | except Compaq DOS 3.31 or DOS 4.0+
int 26h for Absolute Disk Write      | over-32Mb partitions
entry   AL      drive number (0=A:, 1=B:, etc)
        CX      number of sectors to read (int 25h) or write (int 26h)
        DS:BX   segment/offset of disk transfer address buffer (DTA)
        DX      first relative sector to read - beginning logical sector
                number
return  CF      set if error
        AL      error code issued to int 24h in low half of DI
        AH      01h     bad command
                02h     bad address mark
                03h     write-protected disk
                04h     requested sector not found
                08h     DMA failure
                10h     data error (bad CRC)
                20h     controller failed
                40h     seek operation failed
                80h     attachment failed to respond
note 1) DOS returns with a far ret which leave the original flags on 
        the stack.  Be sure to pop the stack to prevent uncontrolled 
        growth. 
     2) MSC 3.0's int86() was a straight interrupt call.  MSC 4.0 and 
        later make special provision for adjusting the stack on int 
        25h and 26h.  This probably won't hurt anything but you should 
        be aware of it. 
     3) Ints 25h and 26h will try rereading a disk if they get an 
        error the first time. 

  To address partition sizes greater than 32Mb an extended format is 
provided in Compaq DOS 3.31, DOS 4.0, and DR-DOS.  This format passes 
a 32-bit address value by means of a parameter block.  The extended 
format may be used to address disks smaller than 32Mb as well as 
larger. 

 The request is as follows:

int 25h for Absolute Disk Read,            | Compaq DOS 3.31 or DOS 4.0+
int 26h for Absolute Disk Write            | over-32Mb partitions
entry   AL      drive number (0=A:, 1=B:, etc)
        CX      0FFFFh
        DS:BX   address of parameter block. Block format:
              4 bytes    sector number
              2 bytes    number of sectors to read
              4 bytes    FAR pointer to buffer
return  CF      set if error
        AL      error code issued to int 24h in low half of DI
        AH      01h     bad command
                02h     bad address mark
                03h     write-protected disk
                04h     requested sector not found
                08h     DMA failure
                10h     data error (bad CRC)
                20h     controller failed
                40h     seek operation failed
                80h     attachment failed to respond
note 1) DOS returns with a far ret which leave the original flags on 
        the stack. Be sure to pop the stack to prevent uncontrolled 
        growth. 
     2) MSC 3.0's int86() was a straight interrupt call.  MSC 4.0 and 
        later make special provision for adjusting the stack on int 
        25h and 26h.  This probably won't hurt anything but you should 
        be aware of it. 
     3) Ints 25h and 26h will try rereading a disk if they get an 
        error the first time. 
     4) Partition is potentially >32M (and requires this form of the 
        call) if bit 1 of device attribute word in device driver is 
        set. 
     5) In the IBM OS/2 Tech Ref Volume 1, page 7-33, under "DOS 
        Environment Software Interrupt Support", it lists:
        25h  direct read       supported
        26h  direct write      an error is returned on requests for 
                               non-removable media 

  Interrupts 25h and 26h can read logical sectors only.  They cannot 
read hidden sectors. 

  Critical errors are not processed by ints 25h and 26h.  Should one 
happen, the  interrupt routine will return an error value to the 
program but will not itself call the critical error handler at int 
24h. 
  
 The Microsoft DOS 5.0 Technical Reference refers to this call as 
"superceded" and directs you to int 21h, fn 440Dh, minor code 61h, 
"Read Track on Logical Drive" and minor code 41h, "Write Track on 
Logical Drive."  See Chapter 4. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 27h   Terminate And Stay Resident ................... 5**6 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:009Ch)       (obsolete)
  This vector is used by programs that are to remain resident when 
COMMAND.COM regains control. 

  After initializing itself, the program must set DX to its last 
address plus one relative to the program's initial DS or ES value (the 
offset at which other programs can be loaded), then execute interrupt 
27h.  DOS then considers the program as an extension of itself, so the 
program is not overlaid when other programs are executed.  This is 
useful for loading programs such as utilities and interrupt handlers 
that must remain resident. 

entry   CS      current program segment
        DX      last program byte + 1
return  none
note 1) This interrupt must not be used by .EXE programs that are 
        loaded into the high end of memory. 
     2) This interrupt restores the interrupt 22h, 23h, and 24h 
        vectors in the same manner as interrupt 20h.  Therefore, it 
        cannot be used to install permanently resident Ctrl-Break or 
        critical error handler routines. 
     3) The maximum size of memory that can be made resident by this 
        method is 64K. 
     4) Memory can be more efficiently used if the block containing a 
        copy of the environment is deallocated before terminating.  
        This can be done by loading ES with the segment contained in 
        2Ch of the PSP, and issuing function call 49h (Free Allocated 
        Memory). 
     5) DOS function call 4Ch allows a program to pass a completion 
        code to DOS, which can be interpreted with processing (see 
        function call 31h). 
     6) If int 27h is called by a program linked with the /HIGH 
        switch, it will occupy the top of memory and prevent 
        COMMAND.COM from reloading, which is probably not what you 
        want. 
     7) Int 21, function 31h is the preferred method to cause a 
        program to remain resident because this allows return 
        information to be passed and allows a program larger than 64K 
        to remain resident. 
     8) It is possible to make an EXE program resident with this call 
        by putting a 27h in the second byte of the PSP and terminating 
        with a RET FAR. 
     9) Programs terminating with int 27h do not close files on exit. 
        Your program must explicitly close any opened files before 
        going resident. 
    10) Int 27h does not work correctly when DX contains values from 
        0FFF1h to 0FFFFh.  In this case, DOS discards the high bit of 
        the contents of DX, resulting in 32k less resident memory than 
        was requested by the program. 
    11) This interrupt will work with PC-MOS/386, but there are a 
        number of MOS-specific advantages to using int 21h/31h 
        instead.  See Chapter 4 for further explanation. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 28h   (not documented by Microsoft) ................. 5**7 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           *    DOS Idle Interrupt

  Int 28h has been provided by DOS since release 2.0.  The int 28h 
process is similar to the "Timer Tick" process provided by BIOS via 
int 1Ch in that it is an "outbound" (from DOS) call which an 
application can "hook onto" to get service at a particular entry 
point.  DOS normally only issues int 28h when it recieves a function 
call (int 21h) from a foreground application with an argument in the 
range of 0 thru 12 (0Ch) in the AH register, or when it is idling 
waiting for keyboard input.  In effect, when DOS issues int 28h, it is 
saying to the background task "I'm not doing anything hot right now, 
if you can use the time, go ahead."  This means that a foreground 
application which doesn't do many low-number DOS functions can preempt 
CPU time easily. 

  When int 28h is being issued it is usually safe to do DOS calls.  
You won't get int 28hs if a program is running that doesn't do its 
keyboard input through DOS.  You should rely on the timer interrupt 
for these.  It is used primarily by the PRINT.COM routines, but any 
number of other routines can be chained to it by saving the original 
vector and calling it with a FAR call (or just JMPing to it) at the 
end of the new routine. 

  Int 28h is not called at all when any non-trivial foreground task is 
running. As soon as a foreground program has a file open, int 28h no 
longer gets called. Could make a good driver for for a background 
program that works as long as there is nothing else going on in the 
machine. 

  DOS uses 3 separate internal stacks: one for calls 01h through 0Ch; 
another for calls 0Dh and above; and a third for calls 01h through 0Ch 
when a Critical Error is in progress.  When int 28h is called, any 
calls above 0Ch can be executed without destroying the internal stack 
used by DOS at the time. 

  The byte which is pushed on the stack before an int 28h just 
indicates which stack area is being used by the current int 21h call.  
In DOS 3.1, the code sequence that calls int 28h looks like this: 

        PUSH    SS:[0304]
        INT     28
        POP     SS:[0304]

  The low-order byte of the word pushed contains 1 if the int 21h call 
currently in progress is for services 1 through 0Ch, and 0 for service 
0 and for 0Dh and up.  Assuming that the last DOS call was not a 
reentrant one, this tells you which set of DOS services should be safe 
to call. 

entry   no parameters available
return  none
note 1) The int 28h handler may invoke any int 21h function except 
        functions 00h through 0Ch (and 50h/51h under DOS 2.x unless 
        DOS CritErr flag is set). 
     2) Apparently int 28h is also called during screen writes. 
     3) Until some program installs its own routine, this interrupt 
        vector simply points to an IRET opcode. 
     4) Supported in OS/2 1.0's DOS Compatibility Box. 
     5) It is possible, if you are careful, to enhance the background 
        priority by providing more int 28h calls than DOS normally 
        would issue. 
     6) If the InDOS flag is zero on int 28h, then it was called by 
        someone other than DOS, and the word on the stack should NOT 
        be examined. 
     7) From Quarterdeck Tech Support: "Turbo Pascal 4.0 uses int 28h 
        as a convenience for its SideKick product users.  Interrupt 28 
        is the DOS busy flag which DESQview treats as a pause and 
        gives up time... foreground gets little time and background 
        gets a lot...reverse of normal." 
     8) This interrupt is supported by PC-MOS/386 and MS Windows 3.0+. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 29h   (not documented by Microsoft) ................. 5**8 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           *    Internal - Quick Screen Output

  This method is extremely fast (much faster than DOS 21h subfunctions 
2 and 9, for example), and it is portable, even to "non-compatible" 
MS-DOS computers. 

entry   AL      ASCII value for character to output to screen
return  unknown
note 1) Documented by Digital Equipment's DOS Reference as provided 
        with the DEC Rainbow.  Also documented by Digital Research in 
        the DR-DOS manual. 
     2) If ANSI.SYS is installed, character output is filtered through 
        it. 
     3) Works on the IBM PC and compatibles, Wang PC, HP-150 and 
        Vectra, DEC Rainbow, NEC APC, Texas Instruments PC and others. 
     4) This interrupt is called from the DOS's output routines if 
        output is going to a device rather than a file, and the device 
        driver's attribute word has bit 3 (04h) set to "1". 
     5) This call has been tested with MSDOS 2.11, PCDOS 2.1, PCDOS 
        3.1, PCDOS 3.2, PCDOS 3.3, PCDOS 4.01, and Compaq DOS 3.31. 
     6) Used in IBMBIO.COM as a vector to int 10, function 0Eh (write 
        TTY) followed by an IRET. 
     7) Most of the fast ANSI device drivers use this interrupt - 
        ZANSI.SYS, NANSI.SYS, and PCMag's ANSI.COM, Quarterdeck's 
        DVANSI.SYS. 
     8) When using int 29h to output characters the ASCII 7 (BELL) 
        will suppress character output while the bell is sounding. 
     9) When device drivers (or the SYSINIT module which loads the 
        drivers) need to do console output, they use int 29h, to call 
        the console device driver directly.  For example, messages 
        telling you about errors in your CONFIG.SYS file are printed 
        using this service. 



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Ah   Microsoft Networks - Session Layer Interrupt .. 5**9 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        1)  This interrupt was not officially documented by Microsoft 
            until the release of Windows 3.0, which has setup 
            parameters for int 2Ah. 
        2)  LANtastic NetBIOS interface, original IBM PC LAN 
            interface. 
        3)  NetBIOS alternate interface.  The alternate interface 
            (2Ah) was originally designed as a "higher" level 
            interface to network communications rather than the "low" 
            level interface (5Ch) provided by the NETBIOS.  The 2Ah 
            interface, however, does not support any higher level 
            functions than does the 5Ch interface and therefore has 
            not become a de facto standard as has the 5Ch interface. 
        4)  Most DOS 4.0 external programs (SHARE, etc) check this 
            interrupt during installation. 

entry   AH      00h     Check for Int 2Ah Network BIOS Installation
                        return  AH      nonzero if installed
                01h     Execute NETBIOS Request (no error retry)
                        ES:BX   pointer to NCB
return          AL      NETBIOS error code
                AH      00h     if no error
                        01h     if error
                02h     Set Net Printer Mode
                03h     Get Shared-Device Direct I/O Status
                        AL      00h
                        DS:SI   pointer to ASCIIZ disk device name
                        return  CF      clear   if allowed
                                        set     if denied
                        note 1) Direct I/O is through ints 13h, 25h, or 
                                26h. 
                             2) If the device is redirected (see int 
                                21h/5F02h) or this call returns with 
                                carry set, the program should not 
                                perform direct disk I/O. 
                             3) The device pointed to by DS:SI must 
                                include the colon in the drive:pathname. 
                             4) It may take some time for this call to 
                                return to the calling program. Do not 
                                use in time-sensitive applications. 
                04h     Execute NETBIOS
                        AL      00h     retry on error
                                01h     no retry on error
                        ES:BX   pointer to network control block
                        return  AX      0000h   for no error
                                AH      01h     if error
                                        AL      error code (unknown)
                        note 1) IBM PC LAN says, "for adapter 
                                independence, use int 2Ah. No not use 
                                5Ch function provided by the network 
                                adapter." 
                             2) Error codes that are automatically 
                                retried are: 
                                09h     no session resources available
                                12h     session open rejected
                                21h     interface busy
                05h     Get Network Resource Information
                        AL      00h
                        return  AX      reserved
                                BX      # of network names (16 - names in 
                                        use) 
                                CX      number of available NCB commands 
                                DX      number of sessions (max - pending) 
                06h     Network Print-Stream Control
                (IBM PC LAN)
                        AL      01h     Set spooled output to
                                        concatenation mode
                                02h     Set spooled output to
                                        truncation mode
                                03h     Trunate printer stream
                        return  CF      clear   no error
                                        set     AX      DOS error code
                (LANtastic)
                        AL      01h     Set spooled output to combined
                                        mode
                                return  none
                                02h     Set spooled output in separate
                                        mode
                                return  none
                                note    Printer output is not combined 
                                        when multiple programs are run or 
                                        when the printer is opened or 
                                        closed. This cmd. implicitly 
                                        starts a new print job. 
                                03h     Flush printer output 
                                return  none 
                                note 1) Printer output is flushed and a 
                                        new print job is started. If no 
                                        output exists to be flushed then 
                                        this function has no affect. 
                                     2) 03h is equivalent to 
                                        Ctrl/Alt/keypad-* 
                        note    NETBIOS 1.10
                07h-19h unknown
                20h     unknown
                        note    AL=01h intercepted by DESQview 2.0.
                23h     Receive Broadcast Datagram
                        IBM PC LAN 1.2. Manual says "use is not allowed".
                80h     Begin DOS Critical Section
                        AL      critical section number (1 to 6)
                note    SHARE.EXE uses critical section number 01h.
                81h     End DOS Critical Section
                        AL      critical section number (1 to 6)
                note    SHARE.EXE uses critical section number 01h.
                82h     Server Hook
                        stack   AX from call to int 21h
                        return  stack unchanged
                        note    Called by the int 21h function dispatcher
                                in DOS 3.10+ for function 0 and functions
                                greater than 0Ch except 59h.
                84h     Keyboard Busy Loop
                        note    Same functionality as DOS's int 28h?
                87h     Used by DOS PRINT to mark Critical Regions:
                        AL      00h     Begin Critical Region
                                01h     End Critical Region
                        return  CF      set     region already active
               0A3h     Receive Broadcast Datagram
                        IBM PC LAN 1.2. Manual says "use is not allowed".


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Bh   (not documented by Microsoft) ................. 5**10³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           *    Unknown - Internal Routine for DOS (IRET)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Ch   (not documented by Microsoft) ................. 5**11³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           *    Unknown - Internal Routine for DOS (IRET)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Dh   (not documented by Microsoft) ................. 5**12³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           *    Unknown - Internal Routine for DOS (IRET)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Eh   (undocumented by Microsoft)  (DOS 2.0+) ....... 5**13³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           *    Internal Routine for DOS  (Alternate EXEC)

  This interrupt passes a command line addressed by DS:SI to 
COMMAND.COM.  The command line must be formatted just like the 
unformatted parameter area of a Program Segment Prefix.  That is, the 
first byte must be a count of characters, and the second and 
subsequent bytes must be a command line with parameters, terminated by 
a carriage return character. 

  When executed, int 2Eh will reload the transient part of the command 
interpreter if it is not currently in memory.  If called from a 
program that was called from a batch file, it will abort the batch 
file.  If executed from a program which has been spawned by the EXEC 
function, it will abort the whole chain and probably lock up the 
computer.  Int 2Eh also destroys all registers including the stack 
pointer. 

  Int 2Eh is called from the transient portion of the program to reset 
the DOS PSP pointers using the above Functions #81 & #80, and then 
reenters the resident program. 

  When called with a valid command line, the command will be carried 
out by COMMAND.COM just as though you had typed it in at the DOS 
prompt.  Note that the count does not include the carriage return.  
This is an elegant way to perform a SET from an application program 
against the master environment block for example. 

entry   DS:SI   pointer to an ASCIIZ command line in the form:
                        count byte
                        ASCII string
                        carriage return
                        null byte
note 1) Destroys all registers including stack pointer. 
     2) Seems to work OK in both DOS 2.x and 3.x. 
     3) It is reportedly not used by DOS. 
     4) As far as known, int 2Eh is not used by DOS 3.1, although it 
        was called by COMMAND.COM of PCDOS 3.0, so it appears to be in 
        3.1 only for the sake of compatibility. 
     5) Not used by the aftermarket 4DOS command interpreter prior to 
        version 3.0. 3.0 merely hooks this vector and does nothing 
        with it.  3.02 and later provide a TSR to add 2Eh capability. 
     6) Trapped by PC-MOS/386 to prevent illegal entry into the 
        command processor. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Fh   Multiplex Interrupt ........................... 5**14³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 Interrupt 2Fh is the multiplex interrupt.  A general interface is 
defined between two processes.  It is up to the specific application 
using interrupt 2Fh to define specific functions and parameters. 

 This interrupt is becoming more commonly used as the available 
interrupt 21 functions are getting to be in short supply.  Int 2Fh 
doesn't require any support from DOS itself for it to be used in 
application programs.  It's not handled by DOS, but by the programs 
themselves. 

 Every multiplex interrupt handler is assigned a specific multiplex 
number. The multiplex number is specified in the AH register; the AH 
value tells which program your request is directed toward.  The 
specific function that the handler is to perform is placed in the AL 
register.  Other parameters are places in the other registers as 
needed.  The handlers are chained into the 2Fh interrupt vector and 
the multiplex number is checked to see if any other application is 
using the same multiplex number.  There is no predefined method for 
assigning a multiplex number to a handler.  You must just pick one.  
To avoid a conflict if two applications choose the same multiplex 
number, the multiplex numbers used by an application should be 
patchable.  In order to check for a previous installation of the 
current application, you can search memory for a unique string 
included in your program.  If the value you wanted in AH is taken but 
you don't find the string, then another application has grabbed that 
location. 

  Int 2Fh was not documented under DOS 2.x.  There is no reason not to 
use int 2Fh as the multiplex interrupt in DOS 2.x.  The only problem 
is that DOS 2.x does not initialize the int 2Fh vector, so when you 
try to chain to it like you are supposed to, it will crash.  If your 
program checks the vector for being zero and initializes it itself or 
doesn't chain in that case, it will work for you n 2.x just the same 
as 3.x. 

  DOS 3.2 itself contains some int 2Fh handlers - it uses values of 
08h, 13h, and 0F8h.  There may be more.  NLSFUNC from DOS 3.3 up uses 
part of int 2Fh and so does GRAFTABL. 

  For int 2Fh calls, register AH identifies which program is to handle 
the interrupt.  AH values 00h-7Fh are reserved for DOS, not that 
anyone cares much. Values 0C0h-0FFh are reserved for applications.  
Register AL contains the subfunction code if used. 

  IBM has reported that PC-DOS 4.0 will sometimes hang when 
substituting int 2Fh for int 67h for network calls.  Most of DOS 4.0's 
external commands check the 2Fh PRINT and other statuses while 
operating for enhanced network support. DOS 4.0 SHARE.EXE traps the 
2Fh interrupt.  IBM and Microsoft DOS programming information for 
versions prior to 4.0 strongly imply that 2Fh functions not used by 
PRINT.COM are open for general use.  DOS 4.0 uses quite a few 2Fh 
functions and this may be a cause of incompatibility with some 
software. 

  LANtastic NOS SERVER.EXE v2.49s and earlier will not run under DOS 
4.x due to int 2Fh conflicts.  This conflict also occurs under DR-DOS 
versions 3.40 and 3.41.  DR-DOS is internally similar to DOS 4.0. 


Function   01h  PRINT.COM
           PC-DOS 3.3's PRINT.COM hooks the following interrupt vectors:
                05h     PrintScreen Interrupt
                13h     BIOS Disk Interrupt
                14h     BIOS Serial Communications Interrupt
                15h     BIOS "System Services" Interrupt
                17h     BIOS Printer Interrupt
                19h     Bootstrap Loader Interrupt
                1Ch     Timer Tick
                23h     Control-C Terminate Address
                24h     Critical Error Handler Address
                28h     DOS Idle Interrupt (undocumented)
                2Fh     Multiplex Interrupt

entry   AH      01h
                AL      00h     PRINT  Get Installed State
                        This call must be defined by all int 2Fh 
                        handlers. It is used by the caller of the 
                        handler to determine if the handler is present. 
                        On entry, AL=0. On return, AL contains the 
                        installed state as follows: 
                return  AL      0FFh    installed
                                01h     not installed, not OK to install
                                00h     not installed, OK to install

                        01h     PRINT  Submit File
                        DS:DX   pointer to submit packet
                                format  byte    level
                                        dword   pointer to ASCIIZ filename
                return  CF      set if error
                                AX      error code
                note 1) A submit packet contains the level (BYTE) and a 
                        pointer to the ASCIIZ string (DWORD in 
                        offset:segment form). The ASCIIZ string must 
                        contain the drive, path, and filename of the 
                        file you want to print. The filename cannot 
                        contain global filename characters. 
                return  CF      set if error
                                AX      error code

                        02h     PRINT Cancel File
                        On entry, AL=2 and DS:DX points to the ASCIIZ 
                        string for the print file you want to cancel. 
                        Global filename characters are allowed in the 
                        filename. 
                DS:DX   pointer to ASCIIZ file name to cancel (wildcards 
                        OK) 
                return  CF      set if error
                                AX      error code

                        03h     PRINT Remove All Files
                return  CF      set if error
                                AX      error code

                        04h     PRINT Hold Queue/Get Status
                        This call holds the jobs in the print queue so 
                        that you can scan the queue. Issuing any other 
                        code releases the jobs. On entry, AL=4. On 
                        return, DX contains the error count. DS:SI 
                        points to the print queue. The print queue 
                        consists of a series of filename entries. Each 
                        entry is 64 bytes long. The first entry in the 
                        queue is the file currently being printed. The 
                        end of the queue is marked by the entry having a 
                        null as the first character. 
               return   DX      error count
                        DS:SI   pointer to print queue (null-string 
                                terminated list of 64-byte ASCIIZ 
                                filenames) 
                        CF      set if error
                                AX      error code
                                        01h     function invalid
                                        02h     file not found
                                        03h     path not found
                                        04h     too many open files
                                        05h     access denied
                                        08h     queue full
                                        09h     spooler busy
                                        0Ch     name too long
                                        0Fh     drive invalid

                        05h     PRINT release print jobs
                return  none
                note 1) This call has no parameters.
                     2) Restarts the print queue.  This call must be 
                        called to restart the current print job or after 
                        calling function 04h to pause the print job. 

                        06h     PRINT get printer device (DOS 3.3+)
                return  CF      clear   OK
                                AX      0000h
                        CF      set
                                AX      0008h   (ERROR_QUEUE_FULL)
                                DS:SI   pointer to printer device header 
                                        struc.
                note 1) This call has no parameters.
                     2) 


Function  02h   PC LAN Program
entry   AH      02h
other parameters unknown


Function  05h   DOS 3.0+ Critical Error Handler
entry   AH      05h
        AL      00h     Installation Check
                return  AL      00h     not installed, OK to install
                                01h     not installed, not OK to install
                                0FFh    installed
                note    This set of functions allows a user program to
                        partially or completely override the default
                        critical error handler in COMMAND.COM.
        AL      xxh     Handle Error - nonzero error code in AL
                        (xxh indicates nonzero extended error code)
                return  CF      clear
                        ES:DI   pointer to ASCIIZ error message
                        AL      (?)
                        CF      set     use default error handler
for LANtastic LANOS:
entry   AH      05h
        AL      00h     for installation check
                #       for error code (in pre DOS 4.00)
                1 or 2  for error code in DOS 4.00
        BX      in      Error code
return  CF      clear   if error code converted to text
                set     if error code can't be converted
        ES:DI   pointer to ASCIIZ text buffer containing error text. 
                This is a read-only text buffer and you must not alter 
                the text in this buffer. 


Function  06h   ASSIGN
entry   AH      06h
        AL      00h     Installation Check
                01h     Get Memory Segment
return (AH=00h) AL      (to 4.01) nonzero if ASSIGN is installed
                        (5.0)      0FFh if ASSIGN is installed
       (AH=01h) ES      segment of ASSIGN work area
note 1) Many references report the return value in AH, but this call 
        appears to return its information in AL. 
     2) Microsoft Press' "Advanced MSDOS Programming" (Second Edition) 
        documents int 2Fh, AX=2000 to check for ASSIGN, but according 
        to Ray Duncan (the author) this is a typo. 


Function   08h  DRIVER.SYS
entry   AH      08h
        AL      00h     Installation Check
                return  AL      00h     not installed, OK to install
                                01h     not installed, not OK to install
                                0FFh    installed
                01h     Add New Block Device
                        DS:DI   pointer to device driver header
                note    Moves down list of drivers, copying and 
                        modifying word at offset 29h.  Device driver 
                        appended to driver chain. 
                02h     Execute Device Driver Request
                        ES:BX   pointer to device driver request header
                return  Request header updated as per requested 
                        operation. 


Function   10h  SHARE                                   (DOS 3.0+)
entry   AH      10h
        AL      00h     Installation Check
return  AL      00h     not installed, OK to install
                01h     not installed, not OK to install
                0FFh    installed
note 1) Values of AL other than 00h appear to put DOS 3.3 SHARE into 
        an infinite loop. 
     2) PC-MOS/386 will always report SHARE.EXE as being present, as 
        its functions are duplicated within the PC-MOS/386 kernel. 
     3) If DOS 4.0's SHARE is loaded manually, either in the CONFIG or 
        AUTOEXEC file, it can't access the NUL device if 4DOS 3.x is 
        installed.  If SHARE.EXE is in the root, the problem doesn't 
        usually occur.  It's been reported that 4DOS is not the only 
        program that has problems with SHARE.EXE and the NUL device, 
        so it's more likely to be an MS-DOS problem than a 4DOS 
        problem.  (dgh on BIX) 
     4) MS Windows intercepts this call and always returns nonzero 
        regardless of SHARE's presence.  If your program uses file 
        sharing you should try locking and reading a file and watch 
        for the error codes returned by int 21h/5Ch. (Lock/Unlock 
        File) 
     5) SHARE function is built into DR-DOS 3.4x, but was removed to a 
        separate TSR module in 5.0 and 6.0. 


Function   11h  Multiplex - Network Redirection
note    In DOS 4.0+, the 11xx calls are all in IFSFUNC.EXE, not in the 
        PC LAN Program redirector. 

entry   AH      11h
        AL      00h     Installation Check
                        return  AL      00h    not installed, OK to 
                                               install 
                                        01h    not installed, not OK to 
                                               install 
                                        0FFh   installed 
                06h     Close Remote File
                08h     Read From Remote File
                09h     Write to Remote File
                0Ah     Lock Region of File
                        BX      file handle
                        CX:DX   starting offset
                        SI      high word of size
                        stack   word    low word of size
                        return  CF      set on error
                                        AL      DOS error code
                                stack   unchanged
                0Bh     Unlock a File Region
                        BX      file handle
                        CX:DX   starting offset
                        SI      high word of size
                        stack   word    low word of size
                        return  CF      set on error
                                        AL      DOS error code
                                        stack   unchanged
                0Ch     Get Disk Space
                        return  AL      sectors per cluster
                                BX      total clusters
                                CX      bytes per sector
                                DX      number of available clusters
                0Dh     unknown
                0Eh     Set Remote File's Attributes
                0Fh     Get Remote File's Attributes
                10h     unknown
                11h     Rename Remote File
                12h     unknown
                13h     Delete Remote File?
                14h     unknown
                15h     unknown
                16h     Open Existing Remote File?
                17h     unknown
                18h     unknown
                19h     CHDIR?
                1Ah     unknown
                1Bh     Find First?
                1Ch     Find Next?
                1Dh     Close All Remote Files for Process?
                1Eh     Do Redirection
                        stack   word    function to execute
                                5F02h   get redirection list entry
                                        BX      redirection list index 
                                        DS:SI   pointer to 16-byte local 
                                                device name buffer 
                                        ES:DI   pointer to 128-byte 
                                                network name buffer 
                                5F03h   redirect device
                                        BL      device type (see 
                                                21h/5F03h) 
                                        CX      stored parameter value 
                                        DS:SI   pointer to ASCIIZ source 
                                                device name 
                                        ES:DI   pointer to destination 
                                                ASCIIZ network path + 
                                                ASCIIZ password 
                                5F04h   cancel redirection
                                        DS:SI   pointer to ASCIIZ device 
                                                name or network path 
                        return  CF      set on error
                1Fh     Printer Setup
                        stack   word    function
                                5E02h   set printer setup
                                5E03h   get printer setup
                        return  CF      set on error
                20h     Reset Disks and Flush Buffers?
                21h     Seek on Remote File?
                        return  CF      set     on error
                                        clear   if successful
                                DX:AX   new file position?
                22h     Process Termination Hook?
                23h-26h unknown


Function   12h  Multiplex, DOS 3.0+ Internal Services


Function   13h  DOS 3.3+(?) Monitor Int 19h
entry   AH      13h
        DS:DX   pointer to the int13h vector to be restored when doing 
                an int19h call 
        ES:BX   pointer to the int13h vector to be used when DOS 
                passes the int13h call along 
return  DS:DX   the original int13h vector used by int19h 
        ES:BX   the original int13h vector to which DOS passed the 
                calls along 
note    Usually, the original vectors will be the same thing, either 
        F000:EC59 for floppy disk systems, or maybe F000:A343 for hard 
        disk systems, but these guys could vary, especially if you're 
        using a non-standard controller. 


Function   14h  NLSFUNC.COM
entry   AH      14h
        AL      00h     installation check
                return  AL      00h     not installed, OK to install
                                01h     not installed, not OK to install
                                0FFh    installed
                01h     unknown
                note    Calls int 2Fh/1227h under certain circumstances.
                02h     unknown
                note    Calls int 2Fh/1227h under certain circumstances.
                03h     unknown
                note    In DOS 3.3, appears to be identical to
                        subfunction 01h.
other parameters unknown


Function   15h  CD-ROM extensions
                Microsoft CD-ROM driver versions 1.0 through 2.0 will 
                work only up to DOS 3.31.  DOS 4.0 and up require 2.1 
                drivers. MSCDEX abandons INT 13; and redirection 
                within DOS to do its work. Some LAN software, such as 
                LANtastic, uses the same mechanism to implement 
                network drives.  MSCDEX provides IFS functionality in 
                any version of DOS back to 3.0. 

entry   AH      15h     CD-ROM services
        AL      subfunctions
                00h     Get Number of CD-ROM Drives (Installation Check)
                BX      00h
                return  BX      number of CD-ROM drive letters used
                                0000h   MSCDEX not installed
                        CX      starting drive letter (0=A:, 1=B:, etc)
                note    This installation check does not follow the 
                        format used by other software. 

                01h     Get Drive Device List
                ES:BX   pointer to buffer to hold drive letter list
                        (5 bytes per drive letter)
                return  buffer filled, for each drive letter:
                        byte    subunit number in driver
                        dword   address of device driver header

                02h     Get Copyright File Name
                CX      drive number (0=A:)
                ES:BX   pointer to 38-byte buffer for name of copyright 
                        file 
                return  CF      set if drive is not a CD-ROM drive
                                AX      error code  (15h)

                03h     Get Abstract File Name
                ES:BX   pointer to 38-byte buffer for name of abstract
                        file
                CX      drive number (0=A:)
                return  CF      set if drive is not a CD-ROM drive
                                AX      error code  (15h)

                04h     Get Bibliographic Doc File Name
                CX      drive number (0=A:)
                ES:BX   pointer to 38-byte buffer for name of
                        bibliographic documentation file
                return  CF      set if drive is not a CD-ROM drive
                                AX      error code  (15h)

                05h     Read VTOC (Volume Table of Contents)
                CX      drive number (0=A:)
                DX      sector index (0=first volume descriptor, 
                        1=second,...) 
                ES:BX   pointer to 2048-byte buffer
                return  CF      set on error
                                AX      error code (15h, 21h)
                        CF      clear if successful
                                AX      volume descriptor type
                                        00h     other
                                        01h     standard
                                        0FFh    terminator

                06h     Turn Debugging On
                BX      debugging function to enable
                note    Reserved for development.

                07h     Turn Debugging Off
                BX      debugging function to disable
                note    Reserved for development.

                08h     Absolute Disk Read
                CX      drive number (0=A:)
                DX      number of sectors to read
                ES:BX   pointer to buffer
                SI:DI   starting sector number
                return  CF      set on error
                                AL      error code  (15h, 21h)

                09h     Absolute Disk Write
                CX      drive number (0=A:)
                DX      number of sectors to write
                ES:BX   pointer to buffer
                SI:DI   starting sector number
                note    Corresponds to int 26h and is currently reserved 
                        and nonfunctional. 

                0Ah     Reserved by Microsoft

                0Bh     CD-ROM 2.00 - Drive Check
                CX      drive number (0=A:)
                return  BX      0ADADh if MSCDEX.EXE installed
                        AX      0000h   if drive not supported
                                <>0     if supported

                0Ch     CD-ROM 2.00 - Get MSCDEX.EXE Version
                return  BH      major version
                        BL      minor version
                note    MSCDEX.EXE versions prior to 1.02 return BX=0.

                0Dh     CD-ROM 2.00 - Get CD-ROM Drive Letters
                ES:BX   pointer to buffer for drive letter list
                        (1 byte per drive)
                return  Buffer filled with drive numbers (0=A:). Each 
                        byte corresponds to the drive in the same 
                        position for function 1501h. 

                0Eh     CDROM 2.00 - Get/Set Volume Descriptor 
                        Preference 
                BX      subfunction
                        00h     Get Preference
                        DX      0000h
                        return  DX      preference settings
                        01h     Set Preference
                        DH      volume descriptor preference
                                01h     primary volume descriptor
                                02h     supplementary volume descriptor
                        DL      Supplementary Volume Descriptor
                                Preference
                                01h     shift-Kanji
                        CX      drive number (0=A:)
                        return  CF      set on error
                                        AX      error code  (01h, 15h)

                0Fh     CD-ROM 2.00 - Get Directory Entry
                CX      drive number (0=A:)
                ES:BX   pointer to ASCIIZ pathname
                SI:DI   pointer to 255-byte buffer for directory entry
                return  CF      set on error
                                AX      error code
                        CF      clear if succesful
                                AX      disk format (0=High Sierra,
                                                     1=ISO 9660)
                note    Directory entry format:
                        byte    length of directory entry
                        byte    length of XAR in LBN's
                        dword   LBN of data, Intel (little-Endian) format
                        dword   LBN of data, Motorola (big-Endian) format
                        dword   length of file, Intel format
                        dword   length of file, Motorola format
               ---High Sierra---
                      6 bytes   date and time
                        byte    bit flags
                        byte    reserved
               ---ISO 9660---
                      7 bytes   data and time
                        byte    bit flags
               ---both formats---
                        byte    interleave size
                        byte    interleave skip factor
                        word    volume set sequence number, Intel format
                        word    volume set sequence number, Motorola
                                format
                        byte    length of file name
                      n bytes   file name
                        byte    (optional) padding if filename is odd
                                length
                      n bytes   system data

                Error codes:
                        01h     invalid function
                        15h     invalid drive
                        21h     not ready


Function   16h  MS-DOS Idle Call  (DOS 5.0+, OS/2 2.0, Windows 3.0+)
entry   AH      16h     idle call
        AL      80h     
return  AL      00h     idle call is supported
                nonzero idle call is not supported
note 1) When your program is waiting for user input or otherwise not 
        doing useful work, you can call this function in a loop.  
        Properly written background programs can monitor this call to 
        determine if it is safe to do processing.  This call 
        originated in Windows 3.0, then the OS/2 2.0 DOS box, and 
        finally in DOS 5, where DOSSHELL uses it so processes can tell 
        the shell when it is safe to swap tasks.  It's also used by 
        the Microsoft Laptop Power Management API.
     2) The MS 5.0 Technical Reference recommends making sure the int 
        2Fh vector is nonzero before calling this function.  This 
        would be to ensure you are running a DOS version that has 2Fh 
        support. 
     3) This call is nonblocking, that is, the system does not suspend 
        the program unless another program is ready to run.  Usually 
        the call returns immediately and the program continues 
        running. 
     4) Windows apps should NOT issue this interrupt.


Function   17h  MS Windows Clipboard API                            (3.0+)
no registers known
note    This is the interface to the Clipboard.  You can open the 
        Clipboard, determine the size of the data in the Clipboard, 
        read the Clipboard, write the Clipboard, clear the Clipboard, 
        and close the Clipboard. 


Function   19h  SHELLB.COM  (DOS 4.0+)
entry   AH      00h     SHELLB.COM - Installation Check
                return  AL      00h     not installed
                        0FFh    installed
                01h     SHELLC.EXE Interface
                        BL      00h     if SHELLC transient
                                01h     if SHELLC resident
                        DS:DX   pointer to far call entry point for
                                resident SHELLC.EXE
                return  ES:DI   ptr to SHELLC.EXE workspace within
                                SHELLB.COM
                note    SHELLB.COM and SHELLC.EXE are parts of the DOS
                        4.x shell
                02h     SHELLB.COM - COMMAND.COM Interface
                        ES:DI   pointer to ASCIIZ full filename of 
                                current batch file, with at least the 
                                final filename element uppercased 
                        DS:DX   pointer to buffer for results
                return  AL      00h     failed, either
                                        (a) final filename element 
                                            quoted at ES:DI does not 
                                            match identity of shell 
                                            batch file quoted as parm of 
                                            most recent call of SHELLB 
                                            command, 
                                        or
                                        (b) no more Program Start 
                                            Commands 
                                             available. 
                                0FFh    success, then:
                                        memory at DS:[DX+1] onwards 
                                        filled as: 
                                        DX+1:   byte  count of bytes of 
                                                      PSC 
                                        DX+2: n bytes Program Start 
                                                      Command text 
                                        byte    0Dh   terminator 
                note    COMMAND.COM executes the result of this call 
                        in preference to reading a command from a 
                        batch file. Thus the batch file does not 
                        advance in execution for so long as SHELLB 
                        provides PSCs from its workspace. The PSCs are 
                        planted in SHELLB workspace by SHELLC, the 
                        user menu interface. The final PSC of a 
                        sequence is finished with a GOTO COMMON, which 
                        causes a loop back in the batch file which 
                        called SHELLC so as to execute SHELLC again. 
                        The check on batch file name permits PSCs to 
                        CALL nested batch files while PSCs are still 
                        stacked up for subsequent execution. 
                03h     SHELLB.COM - COMMAND.COM Interface
                        ES:DI   pointer to ASCIIZ batch file name as
                                for fn 02h
                return  AL      00h     quoted batch files does not 
                                        match last SHELLB parameter 
                                0FFh    quoted batch file name matches 
                                        last SHELLB parameter 
                04h     SHELLB.COM - SHELLB.COM transient to TSR
                        interface
                return  ES:DI   pointer to name of current shell batch
                                file:
                                word    number of bytes of name 
                                        following 
                                bytes   (8 max) uppercase name of 
                                        shell batch file 


Function   1Ah  ANSI.SYS   (DOS 4.0+)
entry   AH      00h     Installation Check
                return  AL      00h     not installed
                                0FFh    if installed
                01h     Get/Set Display Information
                        CL      5Fh     set information
                                7Fh     get information
                                DS:DX   pointer to parameter block as
                                        for int 21h, AX=440Ch, CX=037Fh/
                                        035Fh respectively
                return  CF      set     on error
                                        AX      error code (unknown)
                                clear   if successful
                note 1) AX is destroyed.
                     2) May be the DOS IOCTL interface to ANSI.SYS.


Function   1Bh  XMA2EMS.SYS   (DOS 4.0+)
entry   AH      00h     Installation Check
                return  AL      0FFh    if installed
                01h     Get Hidden Frame Information
                        DI      hidden physical page number
                return  AX      0000h if successful
                                        ES      segment of page frame
                                        DI      physical page number
                                0FFFFh if failed (no such hidden page)
note 1) XMA2EMS.SYS extension is only installed if DOS has page frames 
        to hide.  This extension hooks onto int 67h fn 58h and returns 
        from that call data which excludes the physical pages being 
        used by DOS. 
     2) Function 02h corresponds to the data edited out of the int 
        67h/fn 58h call. 


Function  43h   Microsoft Extended Memory Specification (XMS)
                The XMS version 2.00 for MS-DOS allows DOS programs
                to utilize additional memory found in 80286 and 80386
                machines.  With some restrictions, XMS adds about 64K
                to the 640K which DOS programs can access directly.
                XMS also provides DOS programs with a standard method
                for storing data in extended memory.
                See Chapter 10 for API.


Function  48h   DOSKEY.COM (DOS 5.0+)
entry   AH      48h     DOSKEY.COM
        AL      00h     Get Installed State
return  AL      00h     not installed
                0FFh    installed

        AL      10h     Read Command Line
                DS:DX   pointer to buffer to take the command line
                        buffer:
                        offset  description
                        00h     buffer size (max 128 bytes)
                        01h     the number of characters, minus 1.  The
                                final CR is copied to the buffer but
                                not included in the byte count.
                        02h     the first byte of the input line.
return  AX      0000h
                DS:DX   filled with command line
note    AX=0 if the user types a macro name, and the buffer is not
        filled.  Your program must call the function a second time to
        expand the macro and copy the macro text to the buffer.


Function  4Ah   DOS 5.0 HMA Services (undocumented)
entry   AH      4Ah
        AL      01h     Get Size
return  BX      number of bytes (possibly 0) of available HMA
        ES:DI   start of the available HMA


Function  4Bh   Microsoft Task Switcher API (DOS 5.0+)
entry   AH      4Bh

entry   AL      01h     Build_Callout_Chain
        ES:BX   0:0
        CX:DX   switcher call-in address
return  ES:BX   address of the app's Switch_Call_Back_Info data
                structure
note    All other registers must be preserved.

entry   AL      02h     Detect Switcher

entry   AL      03h     Allocate Switcher ID

entry   AL      04h     Free Switcher ID

entry   AL      05h     Identify Instance Data




Function  64h   SCRNSAV2
entry   AH      64h
        AL      00h     installation check
return  AL      00h     not installed
                0FFh    installed
note    SCRNSAV2.COM is a screen blanker for PS/2s with VGA by Alan
        Ballard.


Function  7Ah   Novell NetWare
entry   AH      7Ah
        AL      00h     installation check
return  AL      00h     not installed
                0FFh    installed
        ES:DI   pointer to FAR entry point for routines otherwise
                accessed through int 21h
note 1) Returns address of entry point for IPX and SPX.
     2) Parameters are listed in Chapter 13.



Function  87h   APPEND
entry   AH      87h
        AL      00h     APPEND installation check
                return  AH <> 0 if installed
                01h     APPEND - unknown
                02h     APPEND - version check
return  unknown


Function  88h   Microsoft Networks
entry   AH      88h
        AL      00h     network program installation check
                return  AH <> 0 if installed
                        BX      installed component flags
                                (test in this order!)
                           bits 2       messenger
                                3       redirector
                                6       server
                                7       receiver
                                other bits not used, do not test
                01h     unknown
                02h     unknown
                03h     get current POST address
                        return  ES:BX   POST address
                04h     set new POST address
                        ES:BX   new POST address
                09h     network version check


Function  89h   WHOA!           (slows system down for games)
entry   AH      89h
        AL      00h     installation check
                return  AL      00h     not installed
                                0FFh    installed
                01h     uninstall
                return  AL      0FDh    successful
                                0FEh    error
                02h     set delay count
                BX = delay count (larger values slow system down more)
                return  AL      0FDh    successful
                                0FEh    error
note    WHOA!.COM is copyright COMPUTE! Publications and Brad Crandall.


Function  0AAh  VIDCLOCK.COM
entry   AH      0AAh
        AL      00h     installation check
return  AL      00h     not installed
                0FFh    installed
note    VIDCLOCK.COM is a memory-resident clock by Thomas G. Hanlin III.


Function  0ADh  KEYB.COM                                     (DOS 3.3+)
entry   AH      0ADh
        AL      80h     Get KEYB.COM Version Number
return
        BX      00h     not installed
                nonzero installed
                        BH      major version number
                        BL      minor version number
---
        AL      81h     Set KEYB.COM Active Code Page
        BX      code page ID
                437     USA
                850     Multilingual (Latin I)
                852     Multilingual (Latin II)
                860     Portuguese
                863     French-Canadian
                865     Nordic
return  CF      clear   successful
                set
                AX      0001h   if code page is not valid
---
        AL      82h     Set KEYB.COM Country Flag
        BL      00h     domestic (USA) keyboard
                0FFh    not USA keyboard
return  CF      clear   successful
                set     invalid value was passed in BL
---
        AL      83h     Get KEYB.COM Country Flag
return  BL      current country flag value (should be 00h or 0FFh)

note    Some of these functions are available in DOS 3.3 and 4.0, but
        were not documented.  These descriptions are for DOS 5.0.


Function  0AEh  DOS Installable Command                      (DOS 3.3+)
entry   AH      0AEh
        AL      00h     installation check
                DX      0FFFFh
                DS:BX   pointer to command line
                return  AL      00h     execute command normally
                                0FFh    command is TSR extension to
                                        COMMAND.COM
                01h     execute installed command
                DX      0FFFFh
                DS:SI   pointer to ?
                return  DS:SI   unknown
note 1) This apparently provides a mechanism for TSRs to install
        permanent extensions to COMMAND.COM.  It seems that
        COMMAND.COM makes this call before executing the current
        command line, and does not execute the command itself if the
        return is 0FFh.
     2) Fn 01h apparently requests execution of a previous command
        which a call to fn 01h indicated was resident.
     3) Format of command line:
        offset  size    description
        00h     byte    max length of command line?
        01h     byte    count of bytes to follow
        03h   n bytes   command line text, terminated by 0Dh


Function  0B0h  GRAFTABL.COM                                 (DOS 3.3+)
entry   AH      0B0h
        AL      00h     installation check
        return  AL      00h     not installed, OK to install
                        0FFh    installed
note 1) Also used by DISPLAY.SYS.

                                              
Function  0B7h  APPEND.EXE                                   (DOS 3.3+)
entry   AH      0B7h
        AL      00h     installation check
                return  AH      00h     not installed
                                nonzero installed (3.3-4.0)
                                0FFh    installed (5.0)

                01h     unknown

                02h     version check
                return  AH      minor version number, otherwise
                        AL      major version number
                note    The MS 5.0 TR reports AX should be 0FFFFh for
                        versions compatible with DOS 5.0.  However,
                        DOS 4.0 returns the same value.

                03h     unknown

                04h     get APPEND directory list address    (DOS 4.0+)
                return  ES:DI   pointer to active APPEND path (128
                                bytes max) in ASCIIZ format

                05h     unknown

                06h     get APPEND modes flag                (DOS 4.0+)
                return  BX      APPEND state
                           bits 0       set if APPEND enabled 
                                1-B     reserved, must be zero 
                                C       appends dirs to file requests 
                                        that already specify a drive 
                                D       applies dirs to file requests 
                                        that already specify a PATH.  
                                        Set if /PATH flag active 
                                E       stores the appended dirs in the 
                                        APPEND environment variable.  
                                        Set if /E flag active 
                                F       applies dirs to functions like 
                                        EXEC (21h/4B00h) or FIND FIRST 
                                        (21h/4Eh). Set if /X flag 
                                        active. 
                note    Returns the current operation modes for APPEND.

                07h     set APPEND modes flag                   (DOS 4.0+)
                        BX      APPEND state bits (see 06h)
                return  none

                08h     unknown
                09h     unknown
                0Ah     unknown
                10h     unknown

                11h     set TRUENAME flag                    (DOS 4.0+)
                note 1) This call has no parameters.
                     2) If the next int 21h call is function 3Dh, 43h, 
                        4Eh or 6Ch, the fully qualified filename is 
                        written over top of the filename passed to the 
                        int 21h call. The application must provide a 
                        sufficiently large buffer. This state is reset 
                        after APPEND processes the call. 

note 1) (4.0+) The full path name can be retrieved by doing a int 2Fh 
        fn 0B711h before an open (int 21h 3Dh or 6Ch).  The full path 
        is put in your ASCIIZ string when you do the open, so be sure 
        it is long enough. 
     2) The APPEND command apparently covers parts of int 21h/6Ch even 
        though Microsoft's 4.01 User's Reference says it covers only 
        0Fh, 23h, 2Dh, 11h, 4Eh & 4Bh, some of those do require 
        special switches.  For 6Ch, it may be a function of the DX 
        register.  If DX=xx1x it looks only in the current directory, 
        if DX=xx0x it will search the full append path.  DX is called 
        the open flag and gives what action to take if the file exits 
        or does not exist. 


Function  0BFh  PC-LAN Network
entry   AH      0BFh
        AL      00h     installation check        (REDIREFS.EXE)
        return  AL      0FFh    if installed
        AL      80h     set REDIRIFS entry point  (REDIR.SYS)
                ES:DI   pointer to FAR entry point to IFS handler in 
                        REDIRIFS 
        return  AL      0FFh    if installed
                ES:DI   pointer to internal workspace
note    All future IFS calls to REDIR.SYS are passed to the ES:DI entry
        point.


Function  0C7h  Artisoft LANtastic AI-LANBIOS
note    This is the default entry point for the LANtastic NOS serial 
        and parallel port drivers. 


Function 0D44Dh 4DOS v3.01,+ Command Interpreter  (COMMAND.COM replacement)
entry   AX      0D44Dh  4DOS installation check
return  If 4DOS is present in memory the following values will be 
        returned: 
        AX      44DDh
        BH      minor 4DOS version number
        BL      major 4DOS version number (same format as DOS int 
                21h/fn 30h) 
        CX      4DOS PSP segment address
        DL      4DOS shell number (0 for the first shell, 1 for the 
                second, etc.; incremented each time a new copy of 4DOS 
                is loaded over a root copy, either in a different 
                multitasker window or via nested shells) 
note 1) (excerpted from 4DOS 3.01 manual) 4DOS now generates two 
        different INT 2F calls to allow TSRs to tell when 4DOS is back 
        at the prompt.  These calls have AX = D44Eh.  The first occurs 
        immediately before displaying the prompt, with BX = 0; the 
        second occurs after displaying the prompt and immediately 
        before accepting keyboard input, with BX = 1.  Any routine 
        intercepting these calls should preserve at least the SI, DI, 
        BP, SP, DS, ES, and SS registers. 
     2) This function (440Dh) is only available in swapping mode.  It 
        tells you if 4DOS is loaded in memory, but not whether it is 
        the parent process of your program.  You can determine if 4DOS 
        is the parent process by comparing the PSP value returned in 
        CX to the PSP chain pointer at offset 16h in your program's 
        PSP. 


Function  0E3h  AnarKey    (keyboard command stack and alias program)
entry   AH      0E3h
        AL      00h     installation check
        return  AL      00h     not installed
                        0FFh    installed
note    (excerpted from the AnarKey documentation)
        Upon installation, ANARKEY hooks into two interrupts:
        1) Interrupt used to install program signature
                -DOS versions before 3.1 use one interrupt between 60h-67h
                -DOS 3.1 and later use interrupt 2Fh
        2) Interrupt 21h, function 0Ah
        Upon initial program execution, a program "signature" is 
        installed which is used by ANARKEY to prevent itself from 
        being installed more than once. Depending upon the DOS 
        version, a different method of signature installation is 
        performed. 
         Under DOS 2.x thru 3.0, ANARKEY scans interrupt vectors 60h 
        thru 67h searching for an unused vector (signified by a null 
        value).  If an unused vector is found, ANARKEY takes it and 
        installs its program signature there. If all the vectors are 
        in use, ANARKEY does not install a program signature. 
         Running DOS 3.1 and later, ANARKEY chains into interrupt 2Fh. 
        By default, ANARKEY appropriates process number 0E3h. 


Function  0F7h  AUTOPARK.COM  (PD TSR hard disk parking utility)
entry   AH      0F7h
        AL      00h     installation check
                return  AL      00h     not installed
                                0FFh    installed
        01h     set parking delay
                BX:CX   32 bit count of 55ms timer ticks
note    AUTOPARK is a TSR HD parker by Alan D. Jones.


Function        Intel Communicating Applications Standard (CAS 1.01A)
entry   AH              (default; CAS multiplex number can be user-adjusted)
        AL      00h     Get Installed State
                        return  AL      00h     not installed
                                        01h     not installed, not
                                                OK to install
                                        0FFh    installed
                        note    No errors are returned.
                01h     Submit a Task
                        DS:DX   ptr to ASCIIZ path and name of Task 
                                Control File 
                        return  AX      positive event handle or neg. 
                                        error code 
                        note    Files associated with a task must stay 
                                in existence until the task is complete 
                                or an error will result. 
                02h     Abort the Current Event
                        return  AX      event handle of aborted event or
                                        negative error code
                        note    Terminating an event is not 
                                instantaneous. It might take up to 30 
                                seconds. 
                03h     reserved
                04h     reserved
                05h     Find First Entry in Queue
                        CX      Status of the event you are seeking. 
                                This value is compared with the field 
                                at offset 2 of the Control File 
                                0 - event has successfully completed
                                1 - event is waiting to be processed
                                2 - number has been dialed
                                3 - connection has been made (sending)
                                4 - connection has been made (receiving)
                                5 - event was aborted
                               -1 - chooses an event without regard to 
                                    status This value will probably be 
                                    used most often 
                                Other negative values match error codes 
                                in Control File. 
                        DH      direction:
                                0 - Search forward chronologically 
                                    (from the first to the last 
                                    occurring event) 
                                1 - Search backward chronologically 
                                    (from the last to the first 
                                    occurring event) 
                        DL      queue to search:
                                0 - Find first control file in Task 
                                    Queue 
                                1 - Find first control file in Receive 
                                    Queue 
                                2 - Find first control file in Log 
                                    Queue 
                        return  AX      0 if successful, or negative
                                        error code
                                BX      event handle for this file
                06h     Find Next Entry in Queue
                        DL      queue to search:
                                0 - Find next control file in Task 
                                    Queue 
                                1 - Find next control file in Receive 
                                    Queue 
                                2 - Find next control file in Log Queue 
                        return  AX      0 if successful, or negative
                                        error code
                                BX      event handle for this file
                07h     Open a File
                        BX      event handle
                        CX      receive file number
                                0 - the Receive Control File
                                1 - first received file
                                2 - second received file
                                3 - third received file
                                n - nth received file
                        DL      queue:
                                0 - open control file in Task Queue 
                                1 - open control file in Receive Queue 
                                    or the received data 
                 file specified in the CX register.
                                2 - Open control file in Log Queue.
                        return  AX      0 if successful, or negative
                                        error code
                                BX      DOS file handle for the requested
                                        file
                08h     Delete a File
                        BX      event handle
                        CX      receive file number
                                0 - delete all files associated with a 
                                    specific Receive Control File 
                                    (including the RCF) 
                                1 - delete first received file 
                                    associated with the event handle 
                                2 - delete the second received file 
                                    associated with the event handle. 
                                n - delete the nth received file 
                                    associated with the event handle 
                        DL      queue:
                                0 - delete control file in Task Queue 
                                1 - delete a file or files associated 
                                    with an event in the Receive Queue. 
                                2 - delete control file in Log Queue 
                                    note   It is strongly recommended 
                                    that this function NOT be used to 
                                    delete individual Log Control Files 
                                    to maintain the integrity of the 
                                    log. 
                        return  AX      0 if successful, or negative
                                        error code
                09h     Delete All Files (in a queue)
                        DL      queue:
                                0 - delete all control files in the 
                                    Task Queue 
                                1 - delete all control files in the 
                                    Receive Queue and all received 
                                    files 
                                2 - delete all control files in the Log 
                                    Queue 
                        return  AX      0 if successful or negative
                                        error code
                0Ah     Get Event Date
                        BX      event handle of event whose date you 
                                want to get 
                        DL      queue:
                                0 - task queue
                                1 - receive queue
                                2 - log queue
                        return  AX      0 if successful or negative
                                        error code
                                CX      year  (1980-2099)
                                DH      month (1-12)
                                DL      day   (1-31)
                0Bh     Set Task Date
                        BX      event handle
                        CX      year  (1980-2099)
                        DH      month (1-12)
                        DL      day   (1-31)
                        return  AX      0 if successful or negative
                                        error code
                0CH     Get Event Time
                        BX      event handle
                        DL      queue:
                                0 - task queue
                                1 - receive queue
                                2 - log queue
                        return  AX      0 if successful or negative
                                        error code
                                CH      hour    (0-23)
                                CL      minutes (0-59)
                                DH      seconds (0-59)
                                DL      0
                0DH     Set Task Time
                        BX      event handle
                        CH      hour    (0-23)
                        CL      minutes (0-59)
                        DH      seconds (0-59)
                        DL      unused
                        return  AX      0 if successful or negative
                                        error code
                0EH     Get External Data Block
                        DS:DX points to a 256-byte EDB area
                        return  AX      0 if successful or negative
                                        error code
                        note    EDB area is filled with the External 
                                Data Block 
                                block format: (values in decimal)
                              Offset Length        Description
                                 0    1    CAS major version number 
                                 1    1    CAS minor version number 
                                 2    68   ASCIIZ path to directory 
                                           containing Resident Manager 
                                           and CAS software. The path 
                                           must end with a backslash 
                                 70   13   ASCIIZ name of current 
                                           phonebook (the CAS 
                                           subdirectory is assumed) 
                                 83   13   AZCIIZ name of current logo 
                                           file (the CAS subdirectory is 
                                           assumed) 
                                 96   32   ASCIIZ default sender name 
                                 128  21   ASCIIZ CSID (CCITT fax device 
                                           ID) 
                                 149  107  Reserved 
                0Fh     Get/Set Autoreceive State
                        DL      function code:
                                0 - get current autoreceive state 
                                1 - set current state to value in DH 
                                DH      # rings before answer or 0 to
                                        disable
                        return  AX      current state or negative error
                                        code
                                        0 - Autoreceive disabled
                                        positive # - # rings before hdw
                                                     answers
                10h     Get Current Event Status
                        DS:DX   pointer to a 444 byte status area
                        return  AX      0 if successful or negative
                                        error code
                                BX      number of the current event (AX=0)
                11h     Get Queue Status
                        DL      queue:
                                0 - find status of Task Queue
                                1 - find status of Receive Queue
                                2 - find status of Log Queue
                        return  AX      # changes to queue since 
                                        Resident Manager started or 
                                        negative error code If changes 
                                        exceeds 7FFFH, the count begins 
                                        again at 0. 
                                BX      current # of Control Files in 
                                        queue 
                                CX      current # of received files 
                12h     Get Hardware Status
                        DS:DX   pointer to a 128-byte status area
                        return  AX      0 if successful, negative if not
                        DS:DX   pointer to filled 128-byte status area
                13h     Run Diagnostics
                        DL      Mode
                                0 - report progress of diagnostics
                                1 - start running diagnostics
                        return  if DL=1, AX=0 or a negative error code.
                                if DL=0, AX=40h or positive number 
                                indicating diagnostics passed. A 
                                negative value indicates failure and 
                                contains the error code 
                14h     Move Received File
                        BX      event handle
                        CX      receive file number
                                (must be nonzero to specify a received 
                                file) 
                                1 - first received file
                                2 - second received file
                                3 - third received file
                                n - nth received file
                        DS:DX   pointer to new ASCIIZ pathname and 
                                filename.  This file must not exist 
                                already 
                        return  AX      0 if successful or negative
                                        error code
                        note    The path to the new directory must 
                                exist.  This function cannot create 
                                directories. 
                15h     Submit a Single File to Send
                        DS:DX   pointer to variable-length data area
                        return  AX      positive event handle or 
                                        negative error code
                        note 1) variable-length data area format:
                             Offset Length    Description
                                0    1    Transfer type:
                                          0 - 200x200 dpi, facsimile mode
                                          1 - 100x200 dpi, facsimile mode
                                          2 - file transfer mode
                                          3-127 - Reserved.
                                1    1    Text size (if ASCII file, fax
                                          mode)
                                          0 - 80-column
                                          1 - 132-column
                                          2-127 - reserved
                                2    2    time to send, in DOS file time 
                                          format 
                                4    2    date to send, in DOS file time 
                                          format note: Setting both the 
                                          time and date fields to 0 
                                          schedules the file to be sent 
                                          immediately 
                                6    32   ASCIIZ Destination Name  (To: 
                                          field) 
                                38   80   ASCIIZ pathname of the file to 
                                          send 
                                118  47   ASCIIZ phone number to call 
                                165  64   ASCIIZ application-specific 
                                          tag field 
                                229  1    reserved; set to zero
                                230  1    cover page flag:
                                          0 - don't send cover page
                                          1 - send cover page
                                          2-127 - Reserved
                                231  23   reserved; set to zero
                                254  var  ASCIIZ cover text (if offset
                                          230=1)
                             2) The individual fields have the same 
                                meaning as in a Task Control File 
                             3) You must set all fields, except for the 
                                Appli-cation-Specific Tag field, before 
                                calling this function. However, you can 
                                set the Destination Name and Cover Text 
                                fields to an empty string 
                16h-80h Reserved by Intel for future expansion



DOS 2Fh functions 01h (PRINT), 02h (ASSIGN), 10h (SHARE):
return  AX      Error
                Codes       Description
                01h     invalid function number
                02h     file not found
                03h     path not found
                04h     too many open files
                05h     access denied
                06h     invalid handle
                08h     queue full
                09h     busy
                0Ch     name too long
                0Fh     invalid drive was specified
        CF      clear (0) if OK
                set   (1) if error - error returned in AX
note 1) The multiplex numbers AH=0h through AH=7Fh are reserved for 
        DOS. Applications should use multiplex numbers 80h through 
        0FFh. 
     2) When in the chain for int 2Fh, if your code calls DOS or if 
        you execute with interrupts enabled, your code must be 
        reentrant or recursive. 
     3) Important!  In versions of DOS prior to 3.0, the int 2Fh 
        vector was initialized to zero rather than being pointed into 
        the DOS service area.  You must initialize this vector 
        manually under DOS 2.x. 



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Miscellaneous Interrupts - in numeric order                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 30h   FAR jump instruction for CP/M-style calls ..... 5**15³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) The CALL 5 entry point does a FAR jump to here  (not a vector!)
     2) PC-Tools PC-Cache 5.1 hooks this vector on XTs but not on ATs.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 31h   Unknown ....................................... 5**16³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    PC-Tools PC-Cache 5.1 hooks this vector on ATs but not on XTs.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 32h   Unknown ....................................... 5**17³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 33h   Used by Microsoft Mouse Driver Function Calls . 5**18³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    See Chapter 14 for mouse programming.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 34h   Turbo/Microsoft langs - Floating Point emul. .. 5**19³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0D8h.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 35h   Turbo/Microsoft langs - Floating Point emul. .. 5**20³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0D9h.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 36h   Turbo/Microsoft langs - Floating Point emul. .. 5**21³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0DAh.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 37h   Turbo/Microsoft langs - Floating Point emul. .. 5**22³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0DBh.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 38h   Turbo/Microsoft langs - Floating Point emul. .. 5**23³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) This interrupt emulates opcode 0DCh.
     2) PC-MOS/386 versions prior to 4.00 use this interrupt to 
        interface with the PC-MOS API.  Version 4.00 and later use int 
        0D4h for the API.  See the Chapter 13 for the PC-MOS API. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 39h   Turbo/Microsoft langs - Floating Point emul. .. 5**24³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0DDh.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Ah   Turbo/Microsoft langs - Floating Point emul. .. 5**25³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0DEh.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Bh   Turbo/Microsoft langs - Floating Point emul. .. 5**26³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates opcode 0DFh.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Ch   Turbo/Microsoft langs - Floating Point emul. .. 5**27³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates instructions with an ES segment
        override.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Dh   Turbo/Microsoft langs - Floating Point emul. .. 5**28³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt emulates a standalone FWAIT instruction


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Eh   Turbo/Microsoft langs - Floating Point emul. .. 5**29³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Unknown.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Fh   Overlay Manager Interrupt (Microsoft LINK.EXE)  5**30³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Default overlay manager interrupt; may be changed with LINK 
        command line switch. (Microsoft/IBM LINK.EXE) 
     2) The Microsoft Dynamic Link Library manager uses this 
        interrupt. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 40h   Hard Disk BIOS ................................ 5**31³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                Pointer to disk BIOS entry when a hard disk controller
                is installed.  The BIOS routines use int 30h to
                revector the diskette handler (original int 13h) here
                so int 40h may be used for hard disk control.
note 1) Keyboard interrupt for DEC Rainbow.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 41h   Hard Disk Parameters .......................... 5**32³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                Pointer to first Hard Disk Parameter Block, normally
                located in the controller card's ROM.  This table may
                be copied to RAM and changed, and this pointer
                revectored to the new table.
note 1) XT, AT,XT/2, XT/286, PS/2 except ESDI disks
     2) format of parameter table is:
        word    cylinders
        byte    heads
        word    starting reduced write current cylinder
                (XT only, 0 for others)
        word    starting write pre-comp cylinder
        byte    maximum ECC burst length
        byte    control byte
           bits 0-2     drive option (XT only, 0 for others)
                3       set if more than 8 heads
                4       always 0
                5       set if manufacturer's defect map on
                        max cylinder+1
                6       disable ECC retries
                7       disable access retries
        byte    standard timeout (XT only, 0 for others)
        byte    formatting timeout (XT only, 0 for others)
        byte    timeout for checking drive (XT only, 0 for others)
        word    landing zone    (AT, PS/2)
        byte    sectors/track   (AT, PS/2)
        byte    0  (zeroes)
     3) normally vectored to ROM table when system is initialized.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 42h   Pointer to screen BIOS entry .................. 5**33³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                Used by EGA, VGA, PS/2.
                Relocated (by EGA, etc.) video handler (original int 10h).
                Revectors int 10 (BIOS video) calls to EGA BIOS.
                Also used by Zenith Z-100.
                MCT (Modular Circuit Technology, Taiwan) 4-drive floppy
                  controller revectors int 13h to here.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 43h   Pointer to EGA Graphics Character Table ....... 5**34³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) The POST initializes this vector pointing to the default table 
        located in the EGA ROM BIOS.  (PC-2 and up).  Not initialized
        if EGA is not present. 
     2) This vector was referred to (mistakenly) as the Video
        Parameters table in the original EGA BIOS listings. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 44h   Pointer to graphics character table ........... 5**35³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0110h)       This table contains the dot patterns for the first 128
                characters in video modes 4,5, and 6, and all 256
                characters in all additional graphics modes.  Not
                initialized if EGA is not present.
note 1) EGA/VGA/CONV/PS - EGA/PCjr fonts, characters 00h to 7Fh.
     2) Novell NetWare - High-Level Language API.
     3) Also used by Zenith Z-100.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 45h   Reserved by IBM  (not initialized) ............ 5**36³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Also used by Zenith Z-100, purpose unknown.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 46h   Pointer to second hard disk parameter block ... 5**37³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) AT, XT/286, PS/2.
     2) (see int 41h) (except ESDI hard disks) (not initialized unless
        specific user software calls for it)
     3) Also used by Zenith Z-100.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 47h   Reserved by IBM  (not initialized) ............ 5**38³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 48h   Cordless Keyboard Translation ................. 5**39³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0120h)
This vector points to code to translate the cordless keyboard 
scancodes into normal 83-key values.  The translated scancodes are 
then passed to int 9.  (not initialized on PC or AT) This is valid on 
the IBM PCjr only.  IBM built a number of prototype XT/2 machines with 
infrared keyboards which were later sold through salvage outlets, but 
this was never a production option. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 49h   Non-kbd Scan Code Translation Table Addr (PCjr) 5**40³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0124h)       PCjr translate table, TI Pro video

    1)  This interrupt is used for operation of non-keyboard devices 
        on the PCjr, such as the Keytronic Numeric Keypad. This 
        interrupt has the address of a table used to translate non-
        keyboard scancodes (greater than 85 excepting 255). This 
        interrupt can be revectored by a user application. IBM 
        recommends that the default table be stored at the beginning 
        of an application that required revectoring this interrupt, 
        and that the default table be restored when the application 
        terminates. (not initialized on PC or AT) 

        The PCjr BIOS can interpret scancodes other than those 
        generated by the keyboard to allow for expansion. The keyboard 
        generates scancodes from 01h to 055h, including 0FFh. Any 
        scancodes above 55h (56h through 7Eh for make codes and 0D6h 
        through 0FEh for break codes) are processed in the following 
        manner: 
          1) if the incoming make code falls within the range of the 
             translate table whose address is pointed to by int 49h, 
             it is translated into the corresponding scancode. Any 
             incoming break codes above 0D5h are ignored. 
          2) if the new translated scancode is less than 56h, it is 
             processed by the BIOS as a keyboard scancode and the same 
             data is placed in the BIOS keyboard buffer. 
          3) if the translated scancode is higher than 55h or the 
             incoming scancode is outside the range of the translate 
             table, 40h is added creating a new extended scancode. The 
             extended scancode is placed in the BIOS keyboard buffer 
             with the character code of 00h (NUL). This utilitizes the 
             range of 96h through 0BEh for scancodes 56h through 7Eh. 

             The default translate-table maps scancodes 56h through 
             6Ah to existing keyboard values. Codes 6Bh theough 0BEh 
             are mapped (by adding 40h) to extended codes 0ABh through 
             0FEh since they are outside the range of the default 
             translate table. 

             The format of the translate table is:

             0       length - the number of nonkeyboard scancodes that 
                     are mapped within the table (from 1 to n). 
             1 to n  word  high byte 00h (NUL) byte scancode with low 
                     order byte representing the scancode mapped 
                     values relative to their input values within the 
                     range of 56h through 7Eh. 

             With this layout, all keyboard scancodes can be intercepted
             through int 9h and and nonkeyboard scancodes can be
             intercepted through int 48h.

    2)  On the TI Professional, this interrupt is used for some video 
        services. 
        entry   AH      17h     Get Display Offset
        return  ES:DI   segment/offset of current display buffer
        note    The TI Pro has only 2048 bytes of character RAM, but it
                is followed by another 2048 bytes of "phantom" RAM
                (i.e. the same 2048 bytes are available at two
                different addresses) so that wraparound checks need not
                be made when writing to the screen. The attribute RAM
                is "shadowed" behind the character RAM through the
                attribute register.

    3)  Most of the TI Pro functions are identical to the IBM int 16h 
        functions, particularly 0 through 0Eh, although 6 and 7 
        (scroll) are quite different and all cursor addressing has the 
        rows and columns flipped (i.e. IBM uses DH for row, but TI 
        uses DH for column). 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Ah   Real-Time Clock Alarm (Convertible, PS/2, EISA) 5**41³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
1)   Not initialized on PC or AT. 
2)   Invoked by PS/2 and Convertible BIOS when real-time clock alarm 
     occurs. 
3)   Used by TI Professional PC for keyboard DSR interface (keyboard 
     BIOS interrupt)  Functions for AH=0, 1, 2 and 5 are identical to 
     IBM's int 16h. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Bh   Reserved by IBM  (not initialized) ............ 5**42³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Used by IBM Micro Channel SCSI hard disk controllers.
     2) Used by Virtual DMA Services Specification  (see Chapter 21 for
        VDS programming information)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Ch   Reserved by IBM  (not initialized) ............ 5**43³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Dh   Reserved by IBM  (not initialized) ............ 5**44³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Eh   Reserved by IBM  (not initialized) ............ 5**45³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Used instead of int 13h for disk I/O on TI Professional PC.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Fh   Reserved by IBM  (not initialized) ............ 5**46³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 50-57 IRQ0-IRQ7 Relocation .......................... 5**47³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Normally not initialized.
     2) IRQ0-IRQ7 relocated by DesQview.
     3) IRQ0-IRQ7 relocated by IBM 3278 Emulation Control Program.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 58h   Reserved by IBM  (not initialized) ............ 5**48³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 59h   Reserved by IBM  (not initialized) ............ 5**49³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        GSS Computer Graphics Interface (GSS*CGI)
entry   DS:DX   pointer to block of 5 array pointers
return  CF      clear
                AX      return code
        CF      set
                AX      error code
note 1) Int 59h is the means by which GSS*CGI language bindings
        communicate with GSS*CGI device drivers and the GSS*CGI device
        driver controller.
     2) Also used by the IBM Graphic Development Toolkit.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Ah   Reserved by IBM  (not initialized)  ........... 5**50³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    IBM Cluster Adapter BIOS entry address.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Bh   Reserved by IBM  (not initialized) ............ 5**51³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Used by IBM Cluster Adapter.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Ah   Cluster Adapter BIOS entry address ............ 5**52³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Normally not initialized.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Bh   Reserved by IBM  (not initialized) ............ 5**53³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Used by cluster adapter?


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Ch   NETBIOS interface entry port, TOPS ............ 5**54³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) See Chapter 13 for information on network programming. 
     2) The Texas Instruments Professional PC (TI Pro) uses 5Ch for 
        the Pause key on the keyboard.  The TI BIOS allows any user 
        routine to execute from the Pause interrupt as long as it 
        eventually returns. 
     3) Used by Windows/386 by Virtual Machine routines. 
     4) Used by Novell Netware 2.0. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Dh   Reserved by IBM  (not initialized) ............ 5**55³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    The Texas Instruments Professional PC (TI Pro) uses 5Ch for the
        keyboard services.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Eh   Reserved by IBM  (not initialized) ............ 5**56³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    TI Professional PC - Program Break.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Fh   Reserved by IBM  (not initialized) ............ 5**57³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    TI Professional PC - Keyboard queueing.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 60h-67h  User Program Interrupts .................... 5**58³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Available for general use. 
     2) Some Adaptec hard disk controllers used these interrupts.  
        Models and usages unknown. 
     3) Various major programs make standardized use of this group of 
        interrupts.  Details of common use follows: 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 60h   User Program Interrupt ........................ 5**59³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Used by 10-Net Network OS Interface. 
     2) Used by FTP Driver - PC/TCP Packet Driver Specification. 
     3) See Chapter 13 for network programming calls. 
     4) Used by TOPS netork (TTALK.EXE). 
     5) The 2-The-Max VGA-16 board TSR zoom utility uses this 
        interrupt by default.  (see int 61h for details) 
     6) Versa-Spool print spooler revectors int 17h to here when 
        installing its own 17h handler.  (see int 61h also) 
     7) Some older OMTI and Adaptec hard disk controllers used the 
        interrupts from 60h to 63h as 16 bytes of scratch RAM. 
     8) Used by GDOSMEM Windows TSR skeleton. 
        entry   AX      GTSR Identification #
                BX      00h     GTSR Installation Check
        return  BX      GTSR Identification #

        entry   AX      GTSR Identification #
                BX      01h     GTSR Increment WORD in CX:DX
                CX      Segment => WORD
                DX      Offset  => WORD
        return  none
     9) Used by TDOSMEM Windows TSR skeleton.
        entry   AX      TTSR Identification #
                BX      00h     GTSR Installation Check
        return  BX      GTSR Identification #
                CX      Segment => local WORD
                DX      Offset  => local WORD

        entry   AX      TTSR Identification #
                BX      01h     GTSR Increment WORD in CX:DX
        return  none


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 61h  User Interrupt ................................. 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
     1) Default interrupt used by Chris Dunford's PCED 2.0 API.
     2) Used by Mike Geary's DENYNONE.ASM SHARE.EXE controller.

        Function  00h   Get Current Mode Value
        entry   AH      00h
        return  AL      current mode value

        Function  01h   Set New Open-Mode Value
        entry   AH      01h
                AL      new value to set
        return  none

     3) The 2-The-Max VGA-16 board TSR zoom utility uses this interrupt
        by default.

        Function  00h   Zoom
        entry   AX      0000h
                BX      zoom factor (0-7x)
        return  none

        Function  01h   Center Zoomed Window
        entry   AX      0001h
                BX      x coordinate to center
                CX      y coordinate to center
        return  none
        note    'x' and 'y' will be positioned as close to the center of
                the display as possible.

        Function  02h   End Zoom
        entry   AX      0002h
        return  none
        note    Restores screen to original state.

        Function  03h   Report Zoom
        entry   AX      0003h
        return  AX      zoom factor (0-7)

        Function  04h   Enter Specify Mode
        entry   AX      0004h
        return  none
        note    This mode is entered whenever the predefined hotkey is
                pressed.

        Function  05h   Query Zoom Window
        entry   AX      0005h
                BX      segment address of return argument array
                CX      offset address of return argument array
        return  BX:CX   14 byte array
                        offset[0]  x start of zoom window
                              [1]  y start of zoom window
                              [2]  x end of zoom window
                              [3]  y end of zoom window
                              [4]  current zoom factor
                              [5]  zoom offset start x
                              [6]  zoom offset start y

        Function  06h   Set Zoom Window
        entry   AX      0006h
                BX      segment address of window coordinate array
                CX      offset address of window coordinate array
        return  BX:CX   array
                        offset[0]  x start of zoom window
                              [1]  y start of zoom window
                              [2]  x end of zoom window
                              [3]  y end of zoom window
     4) Versa-Spool print spooler revectors int 1Ch to here when
        installing its own 1Ch handler.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 63h  User Program Interrupt                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
This interrupt is used by Novell NetWare v2.0.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 64h  User Program Interrupt                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
This interrupt is used by Novell NetWare IPX versions 1.02-2.0 TBMI.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 65h  User Program Interrupt                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
This interrupt is used by Novell NetWare v2.0.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 67h   User Program Interrupt ........................ 5**60³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Used by Lotus-Intel-Microsoft Expanded Memory Specification 
        3.1 and higher.  (EMS and LIM) 
     2) Used by Ashton-Tate/Quadram/AST Enhanced Expanded Memory 
        Specification 3.1 and higher.  (EEMS) 
     3) Used by Phar Lap/Quarterdeck VCPI v1.0. 
     4) See Chapter 10 for EMS/EEMS programming information. 
     5) The Advanced Digital PC Slave board (also marketed by Alloy) 
        contains its own 8mHz 8086, up to 768K of on-card memory and a 
        built-in monochrome monitor adapter, communicating with an 
        RS232 terminal at 19.2KBaud.  Their operating system is an 
        adaptation of MSDOS 2.11 called RTNX or ATNX.  ?TNX uses 
        interrupt 67h for record locking, using an "interrupt 67h 
        semaphore" system in which a data record access must be 
        preceded by a call to int 67h with a string that contains a 
        filename and a record number to lock. 
     6) Some Adaptec hard disk controllers have problems related to 
        their use of int 67h.  Supposedly the Adaptec can be made to 
        use a driver instead of ROM.  The driver is generated by 
        running the ROM program at C800:5 and this fixes the problem.  
        Apparently this driver is called ADAPTEC.DRV.  Check with 
        Adaptec if you suspect a problem. 
     7) IBM issued a known bug report listing a fault in DOS 4.0's 
        network handling within IBMBIO.COM.  The exact wording of the 
        report is: 
        IR79404   WAIT   IBMBIO   INT 2FH for INT 67H causes hang
     8) Used by PC-Net semaphore calls.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 68h   Not Used  (not initialized) ................... 5**61³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) APPC/PC Network Interface. See Chapter 13.
     2) Some Toshiba laptop hard disk controllers use this interrupt.
     3) Used by HDTest to communicate with BIOS entry point.
     4) Used by Mike Geary's EGA720.ASM (forces EGA into 720x348 mode)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 69h   Not Used  (not initialized) ................... 5**62³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Ah   Not Used  (not initialized) ................... 5**63³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Used by SLR System's OPTHELP.COM, a TSR help system for their 
        OPTASM assembler.  OPTHELP may be configured to interrupts 
        from 60h to 7Fh. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Bh   Not Used  (not initialized) ................... 5**64³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Ch   System Resume Vector (Convertible) ............ 5**65³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) This vector is not initialized on the PC, XT, or PCJr.
     2) DOS 3.2 Realtime Clock update uses this interrupt.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Dh   Not Used  (not initialized) ................... 5**66³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Used internally by VGA adapter -  IBM, Paradise, Video 7, NCR


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Eh   Not Used  (not initialized) ................... 5**67³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Fh   10-Net API..................................... 5**68³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) See Chapter 13 for information on the 10-Net API.
     2) HP ES-12 Extended BIOS
        a) Read CMOS Memory
        entry   AH      22h
                BL      address of CMOS byte to read
                BP      0012h
        return  AH      status
                AL      byte read
                BP, DS  destroyed
        b) Write CMOS Memory
        entry   AH      24h
                AL      new value
                BL      address of CMOS byte to write
                BP      0012h
        return  AH      status
                BP, DS  destroyed
     3) Novell NetWare - PCOX API (3270 PC terminal interface).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 70h   IRQ 8, Real Time Clock Int (AT, XT/286, PS/2) . 5**69³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

        This interrupt services the real-time clock hardware.  The 
        hardware supports 2 modes of operation, an interrupt at a 
        specific 24 hour interval (i.e 9:42 am), or repeatedly every 
        0.976 ms (1,024 kHz). Both modes can operate at the same time 
        if needed. 

        In the 24 hour alarm mode, the interrupt is vectored here by 
        hardware and interrupt 4Ah is called to alert the application 
        program of the alarm.  Int 4Ah is not handled by the BIOS 
        other than to return, and is normally revectored by a 
        particular application using the alarm. 

        When repeating interrupt mode is active, the 32-bit 
        microsecond counter consisting of timer_clk_low and 
        timer_clk_hi is decremented by 976 us on every interrupt.  
        When the timer reaches zero, the byte pointed to by the offset 
        @timer_wait_off and and segment @timer_wait_seg is set to 80h 
        (this pointer is set by an application program through int 1Ah 
        function ah=6). 

        The Motorola MC146818A real time clock chip, or its 
        equivalent, can be programmed to generate the real time clock 
        interrupt (int 70h) approximately 1024 times per second.  The 
        BIOS Real Time Clock ISR is invoked on each real time clock 
        interrupt.  Only AT BIOSs support the Real Time Clock ISR. 

        The BIOS initializes the int 70h vector to address F000:5124h. 

        Three AT BIOS functions interface with the int 70h Real Time
        Clock ISR.  These are:
                int 15h, AH 83h   Event Wait Interval
                int 15h, AH 86h   Wait
                int 1Ah, AH 06h   Set User Alarm


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 71h   IRQ 9, Redirected to IRQ 8 (AT, XT/286, PS/2) . 5**70³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    LAN Adapter 1 (rerouted to int 0Ah [IRQ2] by BIOS).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 72h   IRQ 10  (AT, XT/286, PS/2)  Reserved .......... 5**71³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Hardware servicer (called by hardware 8259-2, IRQ 10).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 73h   IRQ 11  (AT, XT/286, PS/2)  Reserved .......... 5**72³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Hardware servicer (called by hardware 8259-2, IRQ 11).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 74h   IRQ 12  Mouse Interrupt (PS/2) ................ 5**73³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Hardware servicer (called by hardware 8259-2, IRQ 12).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 75h   IRQ 13, Coprocessor Error (AT) ................ 5**74³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) BIOS redirects math coprocessor errors to int 2 (NMI). 
     2) The math co-processor 80287 invokes this interrupt.  Int 75h 
        calls the non-maskable interrupt int 2 to halt the system. 
        (80287 is not used if this vector is left pointing here). 
        Programs which use the 80287 must re-vector this interrupt to 
        use the 80287. 
     3) Under DOS 3.2, this interrupt is routed through the DOS 
        interrupt stack pool like device interrupts.  However, 
        coprocessor exceptions generally do not resume via IRET and 
        this fill the interrupt pool (stacks allocated and never 
        deallocated) on exceptions.  Microsoft has a patch available 
        for DOS 3.2. 
     4) Weitek ABACUS x167 math coprocessor exception handler shares 
        this interrupt with Intel 80x87 if present. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 76h   IRQ 14, Hard Disk Controller (AT, XT/286, PS/2) 5**75³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Called by hardware 8259-2 IRQ 14.
     2) When the hard disk controller has completed its task, it 
        signals completion though hardware activation of int 76h. The 
        status in hdsk_int_flags is set to "done", a value of 0FFh. 
        Int 15/fn91h may also be called to signal the interrupt is 
        done. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 77h   IRQ 15 (AT, XT/286, PS/2)  Reserved ........... 5**76³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Future services (called by hardware 8259-2 IRQ 15).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 78h   Not Used ...................................... 5**77³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Used by Novell Netware 2.0 - non-dedicated shell. 
     2) DESQview uses ints 78h-7Fh for itself to revector the 8259 
        interrupt controllers. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 79h   Not Used ...................................... 5**78³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

note 1) Used by LAN:Datacore runtimes for BASIC and C by Lanquest 
        Group in releases after late '86. 
     2) Used by AutoCAD 2.5/2.6 ADI Digitizer interface (default). 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Ah   Reserved ...................................... 5**79³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Novell NetWare - Low-Level API APX, versions 2.0a+.  See 
        Chapter 13. 
     2) AutoCAD Device Interface, used by various video boards. 
     3) IBM 3270 Emulator program. 
     4) Also used by early versions of "File Access Utility" by 
        Automated Insurance Resource Systems.  AIRS changed to a 
        different interrupt in late '86 to eliminate conflict with 
        Novell. 
     5) Used by LAN:Datacore runtimes for BASIC and C by Lanquest 
        Group in versions 2.5 and higher before late '86.  Lanquest 
        changed to int 79h to prevent Novell conflict. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Bh-7Eh  Not Used by IBM ............................ 5**80³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        Btrieve API
entry   register unknown
        functions:
        00h     open
        01h     close
        02h     insert
        03h     update
        04h     delete
        05h     get_equal
        06h     get_next
        07h     get_prev
        08h     get_greater
        09h     get_gr_eql
        0Ah     get_less
        0Bh     get_less_eq
        0Ch     get_first
        0Dh     get_last
        0Eh     create
        0Fh     stat
        10h     extend
        11h     set_dir: set directory information
        12h     get_dir: get directory information
        13h     begin_trans
        14h     end_trans
        15h     abort_trans
        16h     get_pos: get record position number
        17h     get_direct: get data by sending record position
        18h     step_direct
        19h     stop
        1Ah     version
        1Bh     unlock
        1Ch     reset
return  unknown
note    Btrieve sets low byte of vector to 33h; this serves as the 
        installation check. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Bh   Novell ........................................ 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) BTRIEVE from Softcraft, Inc.
     2) IPX on Proteon networks with ANW 2.0 or greater.
     3) Air File by Automated Insurance Resource Systems.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Ch   REXX-PC API ................................... 5**81³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        IBM REXX-PC macro language
entry   AX      0000h   Initialize
        DS:SI   pointer to null terminated name of program to be 
                executed 
        EB:BX   pointer to null terminated argument string to be passed 
                to the program 
        DX:DI   pointer to an environment control block in the format:
                dword   offset in segment to signature string The 
                        segment is that contained in DX and the 
                        signature is the uppercase ASCIIZ string 
                        "REXX". 
                dword   offset in DX to environment name ASCIIZ string 
                        note: The environment name will be truncated if
                              longer than 32 characters.
                dword   offset in DX to the file extension ASCIIZ 
                        string 
                dword   path search - word value of 0 or non-zero. This 
                        controls the searching of the path for commands 
                        that might be REXX programs. 0 means no search 
                        made, non-zero means search first. 
                dword   x'AAAA'
                        This is a signature that allows REXXPC88 to 
                        call your own defined routine when a command 
                        expression needs to be processed. 
                DD      Segment:offset (standard INTEL format) of 
                        environment work buffer, the first double word 
                        of the buffer MUST be the entry point address 
                        of the environment service routine to be 
                        called.  The rest of the buffer may be used in 
                        any way you choose and will NOT be examined or 
                        modified by REXXPC88. 
return  none 
note 1) The only way to tell if the program exists and can be executed 
        is by examining a value returned by the program in the next 
        call described below.  If the program returns an end of 
        program indication and a string was expected instead, it means 
        that the program was not found or could not be executed for 
        some reason. 
     2) All registers except SS and SP are destroyed.  The caller must 
        save any other registers of interest. 


Function 01h Interpret REXX Command
        This call tells REXXPC88 to interpret the REXXPC88 program 
        until a value is produced. 
entry   AX      0001h 
return  DS:DX   points to a result string, terminated by a CR + LF + 
                NULL. The final result string (which marks the end of 
                the program) consists of nothing but EOF + NULL. 
                REXXPC88 will continue to return this "end of program" 
                string until reinitialized via an AX=01h call as 
                described above. 
note    All registers except SS and SP are destroyed.  The caller must 
        save any other registers of interest. 


Function 02h  Termination
        This call allows resident REXXPC88 extensions to terminate 
        execution of a REXXPC88 program, typically after detecting an 
        error. 
entry   AX      0002h
        DS:SI   points to null terminated string to be displayed as an 
                error message before terminating the REXXPC88 program. 
return  none 
note    Terminates the REXXPC88 program and returns control to DOS.


Function 03h  Load
        This call tells REXXPC88 to look up a program variable and 
        return its current value (if any). 
entry   AX      0003h
        DS:SI   points to null terminated name of REXXPC88 program 
                variable. 
        DS:DX   points to the null terminated string value of the 
                program variable. DX is zero if the program variable is 
                currently undefined. This string is in REXXPC88's data 
                area and must be treated as read-only. 
return  none
note 1) All registers except SS and SP are destroyed. The caller must 
        save any other registers of interest. 


Function 04h  Store
        This call tells REXXPC88 to store a null terminated string as 
        the value of a program variable. 
entry   AX      0004h
        DS:SI   points to null terminated name of REXXPC88 program 
                variable 
        ES:BX   points to null terminated string to be assigned to the 
                variable 
return  none 
note 1) The string is copied into REXXPC88's data dictionary.  If 
        there is insufficient storage to store the string, REXXPC88 
        terminates execution of the program with an error message and 
        returns to DOS. 
     2) Registers: all registers except SS and SP are destroyed.  The 
        caller must save any other registers of interest. 


Function 05h  User-Written Extensions
entry   AX       0005h
        SS:BP   points to a C stack frame containing a two-byte pointer 
                to the null terminated function name, a two-byte integer 
                specifying the number of arguments, and a two-byte 
                pointer to an array of pointers (each two bytes) to the 
                arguments (each argument is a null terminated string). 
return  DS:SI   must point to a null terminated result string. A pointer 
                of NIL (DS = 0, SI = 0) is reserved by REXXPC88 and 
                indicates that "no REXXPC88 extensions answered the 
                function". 
note 1) Registers: all registers except SS, SP, and BP are available 
        for use. 
     2) Stack: Since the amount of REXXPC88 stack space remaining for 
        growth can't be ascertained by the user extension program, the 
        user may wish to switch to a local stack if he requires more 
        than about 128 bytes of stack growth. 


Function 06h Queue
        This call tells REXXPC88 to place data on the data or external 
        interrupt queue either FIFO or LIFO. 
entry   AX      06h
        BH      00h     Internal data queue accessible via PULL and 
                        PARSE PULL 
                01h     External interrupt queue accessible via 
                        LINEIN(EXQUE) 
        BL      00h     Queue data FIFO on selected queue 
                01h     Queue data LIFO on selected queue 
        DS:SI   points to null terminated string to be queued. 
return  AX      0000h   Message queued successfully. 
                0001h   No REXXPC88 program running at current time. 
                        Message not queued. 
                0002h   Not enough storage available for message.  
                        Message not queued. 
                0003h   Either BH (queue number) or BL (FIFO/LIFO flag) 
                        out of range. Message not queued. 
note 1) For the Internal data queue a string may not exceed 127 
        characters. 
     2) For the External int. queue a string may not exceed available 
        storage. 
     3) Registers: all registers except SS and SP are destroyed.  The 
        caller must save any other registers of interest. 


Function 07h  Check for Loaded Extension
        This call provides a way for a REXXPC88 extension to find out 
        if a copy is already loaded, and to exchange information with 
        a resident version. 
entry   AX      0007h
        SS:BP   points to a C stack frame containing a two-byte pointer 
                to the null terminated name of the REXXPC88 extension. 
return  If the extension is already loaded, then DS:SI points to an 
        ASCIIZ string '1', and other registers are used as desired by 
        the extension to communicate with its non-resident copy. 
        (Generally, this involves pointing ES:BX to the resident 
        portion's entry point).  If the extension is not yet resident, 
        then DS:SI points to an ASCIIZ '0'. 
note    Registers: all registers except SS, SP and BP are available 
        for use. 


Function 08h Reserved
        This call is reserved for communication between REXXSYS.SYS 
        and REXXIBMR. 
entry   AX      0008h
return  none


Function 09h Check for REXX Installed
        This call provides external applications a way to determine if 
        REXXIBMR is installed. 
entry   AX      09h
return  AX      0FFFFh  REXXIBMR is not installed
        AX      0AAAAh  REXXIBMR is installed
note    It is assumed that your application will inspect the value of 
        the 7Ch interrupt vector prior to issuing this interrupt.  If 
        the vector is 0000:0000 then REXXIBMR is not installed and 
        this function will cause the system to crash. 


Function 0Ah  Uninstall resident version of REXX
        This call is used to uninstall a resident version
entry   AX      000Ah
        BX      0AAAAh
return  AX      0000h   Resident version uninstalled 
                0001h   Resident version cannot uninstall, as one 
                        interrupt vector has been modified by some 
                        other program in a non-conforming manner. 
                0FFFFh  The installed resident version does NOT support 
                        the uninstall request code (i.e., it is pre 
                        0.55 level). 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Fh   IBM 8514/A Graphics Adapter API ............... 5**82³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) 59 8514/A API functions available (HDILOAD.EXE) parameters 
        unknown. 
     2) Used by second copy of COMMAND set with SHELL=. 
     3) Not used by COMMAND /C at DOS prompt. 
     4) The IBM RTIC (Real Time Interface Coprocessor) Multiport (and 
        Multiport/2) use int 7Fh as a method of communication between 
        the system-unit resident interrupt handler and the RTIC card's 
        operating system.  There is a convention for using it in which 
        register AX contains the signature of the handler that should 
        handle the interrupt. Some signatures are: 
                AX    0200h    is a call to the current task dispatcher 
                               (from the BTRIEVE application 
                               interface). 
                AX    0101h    is a call from an application to the 
                               RTIC function request mechanism. 
                AX    0FEEDh   is a call from the ICAINTH.SYS interrupt 
                               handler. 
     5) MultiLink Advanced (a custom version of PC-MOS/386), versions 
        3.03 and higher, from The Software Link, Inc. 
        Function  02h   Invoke user interface (multitasking DOS shell)
        entry   AH      02h
                AL      00h
        return  unknown
        Function  0Dh   Set new spooler parameters
        entry   AH      0Dh
                AL      ASCII code for disposition (D,S,H,N)
                BH      ASCII code for priority    (0-9)
                BL      ASCII code for class       (A-Z)
        return  AL      Error
                        00h     OK
                        01h     no spooler installed
                        02h     invalid request
        Function  0Eh   Get spooler parameters
        entry   AH      0Eh
        return  AL      01h     if no spooler installed, otherwise:
                AL      ASCII code for disposition (D,S,H,N)
                BH      ASCII code for priority    (0-9)
                BL      ASCII code for class       (A-Z)
     6) There have been mentions of assorted other little-known 
        programs using this interrupt.  In view of its use by DOS and 
        the increasingly-popular 8514/A adapter, it would probably be 
        wise to avoid int 7Fh for aftermarket application software. 
     7) Also used by IBM HLLAPI. 
     8) Used internally by later versions of Tom Mack's RBBS-PC BBS 
        system. 
     9) Used by Novell Netware 2.0+ to switch non-dedicated shell to 
        console mode. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 80h-85h  Reserved by BASIC .......................... 5**83³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Interrupts 80h through 0ECh are apparently unused and not
        initialized in most clone systems.  Not known if GWBASIC or
        MBASIC use any of these interrupts.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 80h   Novell Netware 2.0 ............................ 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 81h   Novell Netware 2.0 ............................ 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 82h   Reserved by BASIC ............................. 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Used in some early versions of NEC Multispeed laptop for ROM
        application management.
     2) Used by Pecan Software's Pascal compiler (P-system).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 81h   Used by Proteon Network ....................... 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 86h   Int 18 when relocated by NETBIOS .............. 5**84³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 86h-0F0h  Used by BASIC when interpreter is running . 5**85³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0A0h-0D0h  TI Professional - free interrupt pool .... 5**  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0A4h  Right Hand Man API ............................ 5**86³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
entry   AH      RHM function  (unknown)
return  unknown
note    Right-Hand Man is a shareware TSR desktop utility similar
        to SideKick.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0D4h PC-MOS/386 API ................................ 5**87³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This interrupt is used for access to the PC-MOS/386 4.x
        operating system's user API.  Previous versions of the OS
        used interrupt 38h.  See Chapter 13 for MOS API programming
        information.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0E0h Digital Research CP/M-86 function calls ....... 5**88³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) Lotus 123 Release 2 reportedly alters the int 0E0h vector
        during operation and leaves it pointing somewhere in the TPA
        on exit.  Perhaps used by the mysterious Lotus add-on program
        hook?
     2) Used by Digital Research CP/M-86, Concurrent CP/M and
        Concurrent DOS API entry points.  Values are typically passed
        in the DX register and returned in the AX register.
     3) Used by Larry Himes' PD TBACK background timeslicer for DOS.
        (very old)
     4) Used by American Data Technology SmartFAX products.
entry   AH      20h     Send FAX
        AL      02h     for FAX format file
                03h     for ASCII format file
        CH      number of redials (0-9). Defaults to 9 if input out of 
                range. 
        CL      backoff time (1-99). 1 unit is 15 sec, value is set to 
                99 if out of range 
        DS:DX   input filename (ASCII). 20 bytes max.
        DX:BX   dial number. Speed dial number is allowed
return  AL      (if bit 7 set)  number of files transmitted
                (bit 7 not set) 0FFh    file not found
                                0FEh    no dial tone
                                0FDh    line busy or non-FAX tone
                                0FCh    other error
entry   AH      21h     reserved

entry   AH      22h     Auto/Manual Transmission Toggle
        AL      00h     switch to Auto mode (default)
                01h     switch to Manual mode
return  none

entry   AH      23h     Set Manual Receive Mode
        AL      00h     switch to Auto mode (default)
                01h     switch to Manual mode.  SmartFAX will not
                        answer phone
return  none

entry   AH      24h     Send FAX Handshake to Remote
note    No other parameters are necessary. No returns.

entry   AH      25h     Enable/Disable Background Task for Spooling 
        AL      00h     enabled background operation. Program will put 
                        the received data in the 80188 to spool. 
                01h     disables background operation. Does not spool 
                        data. Data can be recovered by fns 26h and 27h. 
return  none 

entry   AH      26h     Check 80188 Buffer
        AX      data length
        BL      00h     some data of the same page appears in the next 
                        buffer 
                01h     end of page, more to follow 
                02h     end of page, last page 

entry   AH      27h     Get Data from 80188 Buffer
        DS:DX   pointer to buffer to be saved, minimum size 12Kb.
return  AX      data length
        BL      00h     some data of the same page appears in the next 
                        buffer 
                01h     end of page, more to follow 
                02h     end of page, last page 

entry   AH      28h     Reset After Receive
note    Resets SmartFAX for next call. No other parameters.

entry   AH      29h     Enable/Disable Communication Function
        AL      00h     enable communication
                01h     disable communication
note    In disable mode, SmartFAX will not send or receive.

                                                              
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0E1h PC Cluster Program ............................ 5**89³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    This is a pointer to the disk server data table.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0E2h PC Cluster Program ............................ 5**90³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Interrupt 1Ch is revectored to here.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E4h  Logitech Modula-2 v2.0   Monitor Entry ........ 5**91³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
entry   AX      05h     monitor entry
                06h     monitor exit
        BX      priority
return  unknown


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E5h  Not Used ...................................... 5**92³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E6h  Not Used ...................................... 5**93³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Used by PKzip file compressor.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E7h  Not Used ...................................... 5**94³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E8h  Not Used ...................................... 5**95³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E9h  Not Used ...................................... 5**96³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0EAh  Not Used ...................................... 5**97³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0EBh  Not Used ...................................... 5**98³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0ECh  Not Used ...................................... 5**99³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0EDh  Not Used ..................................... 5**100³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0EEh  Not Used ..................................... 5**101³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0EFh  GEM interface (Digital Research) ............. 5**102³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
entry   CX      0473h
        DS:DX   pointer to GEM parameter block
note    no other parameters are known


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F0h  unknown ...................................... 5**103³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    1) Used by secondary copy of COMMAND when SHELL= set.
        2) Not used by COMMAND /C at DOS prompt.
        3) Used by BASIC while in interpreter.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupts 0F1h-0FFh  (absolute addresses 3C4h-3FFh) ......... 5**104³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    Location of Interprocess Communications Area.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F4h  Not Used ............ ........................ 5**105³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F5h  Not Used ............ ........................ 5**106³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F8h  Set Shell Interrupt (OEM) .................... 5**107³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
     Set OEM handler for int 21h calls from 0F9h through 0FFh
entry   AH      0F8h
        DS:DX   pointer to handler for Functions 0F9h thru 0FFh
note 1) To reset these calls, pass DS and DX with 0FFFFh.  DOS is set 
        up to allow ONE handler for all 7 of these calls.  Any call to 
        these handlers will result in the carry bit being set and AX 
        will contain 1 if they are not initialized.  The handling 
        routine is passed all registers just as the user set them.  
        The OEM handler routine should be exited through an IRET. 
     2) 10 ms interval timer (Tandy?) 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F9h  Reserved ..................................... 5**108³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    First of 8 SHELL service codes, reserved for OEM shell
        (WINDOW); use like HP Vectra user interface?


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FAh  USART ready (RS-232C) ........................ 5**109³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FBh  USART RS ready (keyboard) .................... 5**110³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FCh  Unknown .......................................5**111³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FDh  reserved for user interrupt .................. 5**112³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FEh  reserved by IBM .............................. 5**113³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note    AT/XT286/PS50+ - vector destroyed by return from protected
        mode.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FFh  reserved by IBM .............................. 5**114³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note 1) AT/XT286/PS50+ - vector destroyed by return from protected 
        mode. 
     2) Zenith Z-100 (S-100 bus MSDOS) warm boot. 



       **  Programmer's Technical Reference for MSDOS and the IBM PC **
                USA copyright TXG 392-616  ALL RIGHTS RESERVED
     ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ISBN 1-878830-02-3 (disk-based text)
                    Copyright (c) 1987, 1994 Dave Williams
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³ Shareware Version, 01/20/94 ³
                        ³  Please Register Your Copy  ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                             C H A P T E R   S I X

                       DOS CONTROL BLOCKS AND WORK AREAS


 Contrary to popular belief, DOS is not limited to 640k of work space. This 
constraint is enforced by the mapping of ROM and video RAM into the default 1 
megabyte CPU address space. Some MSDOS compatible machines, such as the Sanyo 
55x series, can have as much as 768k of contiguous DOS workspace with the 
appropriate option boards. Since DOS has no real memory management, it cannot 
deal with a fragmented workspace. Fragmented RAM (such as RAM mapped into the 
option ROM address space) can be dealt with as a RAMdisk or other storage area 
by using a device driver or other software.

 The 80386 CPU and appropriate control software can create a DOS workspace of 
more than one megabyte. Certain add-on boards can also add more than a 
megabyte of workspace, but only for specially written software. Since these 
are all proprietary schemes, little information is availible at present.

 When DOS loads a program, it first sets aside a section of memory for the 
program called the program segment, or code segment. Then it constructs a 
control block called the program segment prefix, or PSP, in the first 256 
(100h) bytes. Usually, the program is loaded directly after the PSP at 100h.
 The PSP contains various information used by DOS to help run the program.  
The PSP is always located at offset 0 within the code segment. When a program 
recieves control certain registers are set to point to the PSP. For a COM 
file, all registers are set to point to the beginning of the PSP and the 
program begins at 100h. For the more complex EXE file structures, only DS and 
ES registers are set to point to the PSP. The linker passes the settings for 
the DS, IP, SS, and SP registers and may set the starting location in CS:IP to 
a location other than 100h.

 IBMBIO provides an IRET instruction at absolute address 847h for use as a 
dummy routine for interrupts that are not used by DOS. This lets the interrupts
do nothing until their vectors are rerouted to their appropriate handlers.

 A storage block is used by DOS to record the amount and location of allocated 
memory within the machine's address space.
 A storage block, a Program Segment Prefix, and an environment area are built 
by DOS for each program currently resident in the address space. The storage 
block is used by DOS to record the address range of memory allocated to a 
program. It is used by DOS to find the next availible area to load a program 
and to determine if there is enough memory to run that porogram. When a 
memory area is in use, it is said to be allocated. Then the program ends, or 
releases memory, it is said to be deallocated. 
 A storage block contains a pointer to the Program Segment Prefix associated 
with each program. This control block is constructed by IBMDOS for the purpose 
of providing standardized areas for DOS/program communication. Within the 
PSP are areas which  are used to save interrupt vectors, pass parameters to 
the program, record disk directory information, and to buffer disk reads and 
writes. This control block is 100h bytes in length and is followed by the 
program module loaded by DOS. 
 The PSP contains a pointer to the environment area for that program. This 
area contains a copy of the current DOS SET, PROMPT, COMSPEC, and PATH values 
as well as any user-set variables. The program may examine and modify this 
information as desired. 
 Each storage block is 10h bytes long, although only 5 bytes are currently 
used by DOS. The first byte contains 4Dh (a capital M) to indicate that it 
contains a pointer to the next storage block. A 5Ah (a capital Z) in the 
first byte of a storage block indicatres there are no more storage blocks 
following this one (it is the end of the chain). The identifier byte is 
followed by a 2 byte segment number for the associated PSP for that program. 
The next 2 bytes contain the number of segments what are allocated to the 
program. If this is not the last storage block, then another storage block 
follows the allocated memory area.
 When the storage block contains zero for the number of allocated segments, 
then no storage is allocated to this block and the next storage block 
immediately follows this one. This can happen when memory is allocated and 
then deallocated repeatedly.
 IBMDOS constructs a storage block and PSP before loading the command 
interpreter (default is COMMAND.COM).

 If the copy of COMMAND.COM is a secondary copy, it will lack an environment 
address at PSP+2Ch.
 


THE DISK TRANSFER AREA (DTA)ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 DOS uses an area in memory to contain the data for all file reads and writes 
that are performed with FCB function calls. This are is known as the disk 
transfer area. This disk transfer area (DTA) is sometimes called a buffer. 
It can be located anywhere in the data area of your application program and 
should be set by your program.

 Only one DTA can be in effect at a time, so your program must tell DOS what 
memory location to use before using any disk read or write functions. Use 
function call 1Ah (Set Disk Transfer Address) to set the disk transfer address.
Use function call 2Fh (Get Disk Transfer Address) to get the disk transfer 
address. Once set, DOS continues to use that area for all disk operations until
another function call 1Ah is issued to define a new DTA. When a program is given
control by COMMAND.COM, a default DTA large enough to hold 128 bytes is 
established at 80h into the program's Program Segment Prefix.

 For file reads and writes that are performed with the extended function calls,
there is no need to set a DTA address. Instead, specify a buffer address when 
you issue the read or write call.


DOS PROGRAM SEGMENTÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 When you enter an external command or call a program through the EXEC function 
call, DOS determines the lowest availible address space to use as the start of 
available memory for the program being started. This area is called the Program
Segment.
 At offset 0 within the program segment, DOS builds the Program Segment Prefix 
control block. EXEC loads the program after the Program Segment Prefix (at
offset 100h) and gives it control.
 The program returns from EXEC by a jump to offset 0 in the Program Segment 
Prefix, by issuing an int 20h, or by issuing an int 21h with register AH=00h or 
4Ch, or by calling location 50h in the PSP with AH=00h or 4Ch.
 It is the responsibility of all programs to ensure that the CS register 
contains the segment address of the Program Segment Prefix when terminating by
any of these methods except call 4Ch.

 All of these methods result in returning to the program that issued the EXEC. 
During this returning process, interrupt vectors 22h, 23h, and 24h (Terminate, 
Ctrl-Break, and Critical Error Exit addresses) are restored from the values 
saved in the PSP of the terminating program. Control is then given to the 
terminate address.


When a program receives control, the following conditions are in effect:

For all programs:

1) The segment address of the passed environment is contained at offset 2Ch in 
   the Program Segment Prefix.

2) The environment is a series of ASCII strings totalling less than 32k bytes
   in the form:       NAME=value      The default environment is 160 bytes.
    Each string is a maximum of 127 bytes terminated by a byte of zeroes for a 
   total of 128 bytes, and the entire set of strings is terminated by another
   byte of zeroes. Following the byte of zeroes that terminates the set of
   environment string is a set of initial arguments passed to a program that
   contains a word count followed by an ASCIIZ string. The ASCIIZ string
   contains the drive, path, and filename.ext of the executable program.
   Programs may use this area to determine where the program was loaded from.
   The environment built by the command processor (and passed to all programs
   it invokes) contains a COMSPEC=string at a minimum (the parameter on COMSPEC
   is the path used by DOS to locate COMMAND.COM on disk). The last PATH and
   PROMPT commands issued will also be in the environment, along with any 
   environment strings entered through the SET command. 
    The environment that you are passed is actually a copy of the invoking 
   process's environment. If your application terminates and stays resident 
   through int 27h, you should be aware that the copy of the environment passed 
   to you is static. That is, it will not change even if subsequent PATH,
   PROMPT, or SET commands are issued.
    The size of the environment may be changed from its default of 160 bytes
   by using the SHELL= command in the config.sys from in DOS version 3.1 up,
   or COMMAND.COM may be patched in earlier versions.
 
   The environment can be used to transfer information between processes or to
   store strings for later use by application programs. The environment is
   always located on a paragraph boundary. This is its format:
        byte    ASCIIZ string 1
        byte    ASCIIZ string 2
            ....
        byte    ASCIIZ string n
        byte    of zeros (0)
   Typically the environment strings have the form:
        NAME = VALUE
   The length of NAME or VALUE can be anything desired as long as it still fits
   into the 123 byte space (4 bytes are used by "SET ").
   Following the byte of zeros in the environment, a WORD indicates the number 
   of other strings following. 

   If the environment is part of an EXECed command interpreter, it is followed 
   by a copy of the DS:DX filename passed to the child process. A zero value 
   causes the newly created process to inherit the parent's environment.

3) Offset 80h in the PSP contains code to invoke the DOS function dispatcher.
   Thus, by placing the desired function number in AH, a program can issue a
   long call to PSP+50h to invoke a DOS function rather than issuing an int 21h.

4) The disk transfer address (DTA) is set to 80h (default DTA in PSP).

5) File Control Blocks 5Ch and 6Ch are formatted from the first two parameters 
   entered when the command was invoked. Note that if either parameter contained
   a path name, then the corresponding FCB will contain only a valid drive
   number. The filename field will not be valid.

6) An unformatted parameter area at 81h contains all the characters entered
   after the command name (including leading and imbedded delimiters), with 80h
   set to the number of characters. If the <, >, or | parameters were entered
   on the command line, they (and the filenames associated with them) will not
   appear in this area, because redirection of standard input and output is
   transparent to applications.

(For EXE files only)
7) DS and ES registers are set to point to the PSP.

8) CS, IP, SS, and SP registers are set to the values passed by the linker.

(For COM files only)
9) For COM files, offset 6 (one word) contains the number of bytes availible in 
   the segment.

10) Register AX reflects the validity of drive specifiers entered with the
    first two parameters as follows:
        AL=0FFh is the first parameter contained an invalid drive specifier,
                otherwise AL=00h.
        AL=0FFh if the second parameter contained an invalid drive specifier, 
                otherwise AL=00h.

11) All four segment registers contain the segment address of the inital 
    allocation block, that starts within the PSP control block. All of user
    memory is allocated to the program. If the program needs to invoke another
    program through the EXEC function call (4Bh), it must first free some memory
    through the SETBLOCK function call to provide space for the program being
    invoked.

12) The Instruction Pointer (IP) is set to 100h.

13) The SP register is set to the end of the program's segment. The segment size
    at offset 6 is rounded down to the paragraph size.

14) A word of zeroes is placed on top of the stack.


 The PSP (with offsets in hexadecimal) is formatted as follows:
 (* = undocumented)

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³     P  R  O  G  R  A  M       S  E  G  M  E  N  T       P  R  E  F  I  X     ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ offset³   size   ³                     C O N T E N T S                       ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0000h ³ 2 bytes  ³ int 20h                                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0002h ³ 2 bytes  ³ segment address, end of allocation block                  ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0004h ³ 1 byte   ³ reserved, normally 0                                      ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0005h ³ 5 bytes  ³ FAR call to MSDOS function dispatcher (int 21h)           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 000Ah ³ 4 bytes  ³ previous termination handler interrupt vector (int 22h)   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 000Eh ³ 4 bytes  ³ previous contents of ctrl-C interrupt vector (int 23h)    ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0012h ³ 4 bytes  ³ prev. critical error handler interrupt vector (int 24h)   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0016h ³ 22 bytes ³ reserved for DOS                                          ³
ÀÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
      * ³ 2 bytes  ³ (16) parent process' PSP                                  ³
      * ³ 20 bytes ³ (18) "handle table" used for redirection of files         ³
ÚÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 002Ch ³ 2 bytes  ³ segment address of the program's environment block        ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 002Eh ³ 34 bytes ³ reserved, DOS work area                                   ³
ÀÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
      * ³  4 bytes ³ (2E) stores the calling process's stack pointer when      ³
        ³          ³      switching to DOS's internal stack.                   ³
      * ³          ³ (32) DOS 3.x max open files                               ³
      * ³  2 bytes ³ (3A) size of handle table   |these functions are in here  ³
      * ³  4 bytes ³ (3C) handle table address   |but reported addresses vary  ³
ÚÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0050h ³  3 bytes ³ int 21h, RETF instruction                                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0053h ³  2 bytes ³ reserved - unused?                                        ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0055h ³  7 bytes ³ reserved, or FCB#1 extension                              ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 005Ch ³ 16 bytes ³ default unopened File Control Block #1                    ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 006Ch ³ 16 bytes ³ default unopened FCB #2 (overlaid if FCB #1 opened)       ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0080h ³  1 byte  ³ parameter length (number of chars entered after filename) ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0081h ³   ...    ³ parameters                                                ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 00FFh ³ 128 bytes³ command tail and default Disk Transfer Area (DTA)         ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


1. The first segment of availible memory is in segment (paragraph) form. For 
   example, 1000h would respresent 64k.

2. Offset 2Ch contains the segment address of the environment.

3. Programs must not alter any part of the PSP below offset 5Ch.


PSP (comments):

offset 00h  contains hex bytes CD 20, the int 20h opcode. A program can end
            by making a jump to this location when the CS points to the PSP.
            For normal cases, int 21, function 4Ch should be used.

offset 02h  contains the segment-paragraph address of the end of memory as 
            reported by DOS. (which may not be the same as the real end of RAM).
            Multiply this number by 10h or 16 to get the amount of memory
            availible. ex. 1000h would be 64k.

offset 04h  "reserved or used by DOS" according to Microsoft

offset 05h  contains a long call to the DOS function dispatcher. Programs may 
            jump to this address instead of calling int 21 if they wish. 
            Used by Basic and other CPM object-code translated programs. It is
            slower than standard int 21h.

offset 0Ah, 0Eh, 12h
            vectors (IP, CS)

offset 16h  PSP:16h is the segment address of the invoking program's PSP, which
        *   will most often be COMMAND.COM but perhaps may be a secondary
            non-permanent COMMAND or a multitasking shell, etc. At any rate,
            the resident shell version of COMMAND.COM has PSP:16H = PSP, which
            indicates "don't look any lower in memory" for the command
            interpreter. To find the beginning of the allocation chain, look
            backwards through the PSP link addresses until the link address is
            equal to the PSP segment address that it resides in. This should
            be COMMAND.COM. To find COMMAND.COM's environment, look at the word
            stored at offset 0BD3h (PC-DOS 3.1 only). This is a segment
            address, so look there at offset 0.

       18h  handle alias table (networking). Also you can make PRN go to CON,
        *   CON go to PRN, ERR go to PRN, etc. 0FFh = availible.

offset 2Ch  is the segment:offset address of the environment for the program 
            using this particular PSP. This pointer does not point to
            COMMAND.COM's environment unless it is a second copy of COMMAND.

offset 2Eh  the DWORD at PSP+2Eh is used by DOS to store the calling process's
        *   stack pointer when switching to DOS's own private stack - at the end
            of a DOS function call, SS:SP is restored from this address.

       32h, 34h
        *   table of number of file handles (to 64k of handles!)

offset 40h  2 byte field points to the segment address of COMMAND.COM's PSP in
        *   "weird" EXE files produced by Digital Research RASMPC/LINKPC.
            EXE files created with these tools can cause all sorts of problems
            with standard MSDOS debugging tools.

offset 50h  contains a long call to the DOS int 21 function dispatcher.

offset 5Ch, 65h, 6Ch
            contain FCB information for use with FCB function calls. The first
            FCB may overlay the second if it is an extended call; your program
            should revector these areas to a safe place if you intend to use
            them.

offset 5Ch  16 bytes first command-line argument (formatted as uppercase 11
            character filename)

offset 6Ch  16 bytes second command-line argument (formatted as uppercase 11
            character filename)

offset 7Ch-7Fh
           "reserved or used by DOS"
offset 80h  1 byte number of bytes in command line argument

offset 80h, 81h
            contain the length and value of parameters passed on the command
            line. 

offset 81h  97 bytes unformatted command line and/or default DTA

offset 0FFh contains the DTA
          

 The PSP is created by DOS for all programs and contains most of the information
you need to know about a program running. You can change the environment for
the current process, however, but for the parent process, DOS in this case, you
need to literally backtrack to DOS or COMMAND.COM's PSP. In order to get there
you must look at the current PSP. At offset 16h of the current PSP segment,
there a 2 byte segment address to the parent or previous process PSP.
 From there you can manipulate the enviroment by looking at offset 2Ch. As you
know, at offset 2Ch, there is 2 byte segment address to the environment block.

Try this under debug and explore the addresses located at these offsets;

      offset  length                description
     ------------------------------------------------------------
        16h     2       segment address of parent process PSP
        2Ch     2       segment address of environment block.

Remember under debug you will have to backtrack two times.

        Programs        Parent
      --------------------------
        command.com     none
        debug.com       command.com
        program         debug.com




MEMORY CONTROL BLOCKSÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 DOS keeps track of allocated and availible memory blocks, and provides four
function calls for application programs to communicate their memory needs to 
DOS. These calls are:
              48h --- allocate memory                 (MALLOC)
              49h --- free allocated memory
              4Ah --- modify allocated memory blocks  (SETBLOCK)
              4Bh --- load or execute program         (EXEC)

DOS manages memory as follows:

 DOS build a control block for each block of memory, whether free or allocated.
For example, if a program issues an "allocate" (48h), DOS locates a block of
free memory that satisfies the request, and then "carves" the requested memory 
out of that block. The requesting program is passed the location of the first 
byte of the block that was allocated for it - a memory management control block,
describing the allocated block, has been built for the allocated block and a 
second memory management control block describes the amount of space left in the
original free block of memory. When you do a SETBLOCK to shrink an allocated 
block, DOS builds a memory management control block for the area being freed and
adds it to the chain of control blocks. Thus, any program that changed memory 
that is not allocated to it stands a chance of destroying a DOS memory 
management control block. This causes unpredictable results that don't show up 
until an activity is performed where DOS uses its chain of control blocks. The 
normal result is a memory allocation error, which means a system reset will be 
required.

 When a program (command or application program) is to be loaded, DOS uses the 
EXEC function call 4Bh to perform the loading.

 This is the same function call that is availible to applications programs for 
loading other programs. This function call has two options:

      Function 00h, to load and execute a program (this is what the command
                    processor uses to load and execute external commands)

      Function 03h, to load an overlay (program) without executing it.

 Although both functions perform their loading in the same way (relocation is 
performed for EXE files) their handling of memory management is different.

FUNCTION 0: For function 0 to load and execute a program, EXEC first allocates 
the largest availible block of memory (the new program's PSP will be at offset 
0 in that block). Then EXEC loads the program. Thus, in most cases, the new 
program owns all the memory from its PSP to the end of memory, including memory
occupied by the transient parent of COMMAND.COM. If the program were to issue 
its own EXEC function call to load and execute another program, the request 
would fail because no availible memory exists to load the new program into.

NOTE: For EXE programs, the amount of memory allocated is the size of the 
      program's memory image plus the value in the MAX_ALLOC field of the file's
      header (offset 0Ch, if that much memory is availible. If not, EXEC 
      allocates the size of the program's memory image plus the value in the 
      MIN_ALLOC field in the header (offset 0Ah). These fields are set by the 
      Linker).

 A well-behaved program uses the SETBLOCK function call when it receives 
control, to shrink its allocated memory block down to the size it really needs.
A COM program should remember to set up its own stack before doing the SETBLOCK,
since it is likely that the default stack supplied by DOS lies in the area of 
memory being used. This frees unneeded memory, which can be used for loading 
other programs.

 If the program requires additional memory during processing, it can obtain 
the memory using the allocate function call and later free it using the free 
memory function call.

 When a program is loaded using EXEC function call 00h exits, its initial 
allocation block (the block beginning with its PSP) is automatically freed 
before the calling program regains control. It is the responsibility of all 
programs to free any memory they allocate before exiting to the calling 
program.

 FUNCTION 3: For function 3, to load an overlay, no PSP is built and EXEC 
assumes the calling program has already allocated memory to load the new program
into - it will NOT allocate memory for it. Thus the calling program should 
either allow for the loading of overlays when it determines the amount of memory
to keep when issuing the SETBLOCK call, or should initially free as much memory 
as possible. The calling program should then allocate a block (based on the size
of the program to be loaded) to hold the program that will be loaded using the 
"load overlay" call. Note that "load overlay" does not check to see if the 
calling program actually owns the memory block it has been instructed to load 
into - it assumes the calling program has followed the rules. If the calling 
program does not own the memory into which the overlay is being loaded, there is
a chance the program being loaded will overlay one of the control blocks that 
DOS uses to keep track of memory blocks.

 Programs loaded using function 3 should not issue any SETBLOCK calls since
they don't own the memory they are operating in. (This memory is owned by the
calling program)

 Because programs loaded using function 3 are given control directly by (and 
return contrrol directly to) the calling program, no memory is automatically 
freed when the called program exits. It is up to the calling program to 
determine the disposition of the memory that had been occupied by the exiting 
program. Note that if the exiting program had itself allocated any memory, it 
is responsible for freeing that memory before exiting.

 Memory control blocks, sometimes called "arena headers" after their UNIX 
counterpart, are 16 bytes long. Only the first 5 bytes are used. 16 bytes are
used for the memory control block, which always starts at a paragraph boundary.
When DOS call 48h is made to allocate "x" many paragraphs of memory, the amount
used up is actually one more than the figure in the BX register to provide
space for the associated memory control block. The location of the memory
control block is at the paragraph immediately before the segment value returned
in AX by the DOS function 48h call i.e. ((AX-1):0).

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³               M E M O R Y      C O N T R O L       B L O C K                 ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Bytes ³                           Function                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   0   ³ ASCII M or Z                                                         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  1-2  ³ PSP segment address of the program that owns this block of memory    ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  3-4  ³ Size of next MCB in 16-byte paragraphs                               ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  5-F  ³ unused                                                               ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

byte 1    will always have the value of 4Dh or 5Ah. The value 5Ah (Z) indicates
          the block is the last in a chain, all memory above it is unused. 4Dh
          (M) means that the block is intermediate in a chain, the memory above
          it belongs to the next program or to DOS.

byte 2,3  hold the PSP segment address of the program that owns the
          corresponding block of memory. A value of 0 means the block is free
          to be claimed, any other value represents a segment address.

byte 3, 4 indicate the size in paragraphs of the memory block. If you know the
          address of the first block, you can find the next block by adding the
          length of the memory block plus 1 to the segment address of the
          control block. Finding the first block can be difficult, as this
          varies according to the DOS version and the configuration. 

 The remaining 11 bytes are not currently used by DOS, and may contain "trash" 
characters left in memory from previous applications.

 If DOS determines that the allocation chain of memory control blocks has been 
corrupted, it will halt the system and display the message "Memory Allocation 
Error", and the system will halt, requiring a reboot.

 Each memory block consists of a signature byte (4Dh or 5Ah) then a word which
is the PSP value of the owner of the block (which allocated it), followed by a 
word which is the size in paragraphs of the block. The last block has a 
signature of 5Ah. All others have 4Dh. If the owner is 0000 then the block is 
free.

 Once a memory control block has been created it should only be manipulated
with the appropriate DOS function calls. Accidentally writing over any of the
first 5 bytes of a memory control block can cause a memory allocation error 
and cause the system to lock up. If the first byte is overwritten with
something other than an 'M' or a 'Z' then DOS will complain with an error
return code of 7 signifying "Memory Control Blocks destroyed". However, should
you change the ownership or block size bytes, you've had it.

 When a .COM program is first loaded by DOS and given control, the memory
control block immediately preceding the Program Segment Prefix contains the
following data:

          ID    = 'Z'
          Owner = segment address of PSP (= CS register of .COM program)
          Size  = number of available paragraphs in DOS memory pool

  An .EXE file will have the following data in the memory control block for
the program (just prior to the PSP):

          ID    = 'M'
          Owner = segment address of PSP (= DS register of program)
          Size  = the number of paragraphs allocated to the program according
                  to the information in the .EXE program header

 In the case of an .EXE program file the amount of memory allocated depends
on the contents of the program header which informs the DOS loader how much to
allocate for each of the segments in the program. With an .EXE program file
there will always be a 'Z' memory control block created in memory immediately
after the end of the space allocated to the program itself.

 One important fact to remember about DOS memory allocation is that blocks of
RAM allocated by different calls to DOS function 48H will NOT be contiguous. At
the very best, they will be separated by the 16 bytes of the memory control
block, and at worst they could be anywhere in RAM that DOS manages to find a
existing memory control block of sufficient size to accomodate the memory
request.

 DOS treats the memory control blocks as a kind of linked list (term used
loosely). It uses the earlier MCBs to find the later ones by calculating the
location of the next one from the size of the prior one. As such, erasing any
of the MCB data in the chain of MCBs will upset DOS severely, as each call for
a new memory allocation causes DOS to scan the whole chain of MCBs looking for
a free one that is large enough to fulfill the request.

 A separate MCB is created for the DOS environment strings at each program
load, so there will be many copies of the environment strewn through memory
when you have a lot of memory resident programs loaded. The memory control
blocks for the DOS environment strings are not returned to the DOS memory pool
if the program goes resident, as DOS will need to copy this enviroment for the
next program loaded.


   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                      C H A P T E R    S E V E N

                          DOS FILE STRUCTURE

                            C O N T E N T S

File Management Functions ....................................... 7**1
FCB Function Calls .............................................. 7**2
Handle Function Calls ........................................... 7**3
Special File Handles ............................................ 7**4
Raw and Cooked File I/O ......................................... 7**5
Number of Open Files Allowed  ................................... 7**6
Restrictions on FCB Usage ....................................... 7**7
Restrictions on Handle usage .................................... 7**8
Allocating Space to a File ...................................... 7**9
MSDOS / PCDOS Differences ....................................... 7**10
.COM File Structure ............................................. 7**11
.EXE File Structure ............................................. 7**12
The Relocation Table ............................................ 7**13
"NEW" .EXE Format (Microsoft Windows and OS/2) .................. 7**14
Standard File Control Block ..................................... 7**15
Extended File Control Block ..................................... 7**16
Disk Transfer Area .............................................. 7**17



File Management Functions ....................................... 7**1

  Use DOS function calls to create, open, close, read, write, rename, 
find, and erase files.  There are two sets of function calls that DOS 
provides for support of file management. They are: 

   * File Control Block function calls   (0Fh-24h)
   * Handle function calls               (39h-69h)

  Handle function calls are easier to use and are more powerful than 
FCB calls. Microsoft recommends that the handle function calls be used 
when writing new programs.  DOS 3.0 up have been curtailing use of FCB 
function calls; it is possible that future versions of DOS may not 
support FCB function calls. 

  The following table compares the use of FCB calls to Handle function 
calls: 

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³           FCB Calls         ³               Handle Calls              ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  Access files in current    ³  Access files in ANY directory          ³
³  directory only.            ³                                         ³
³                             ³                                         ³
³  Requires the application   ³  Does not require use of an FCB.        ³
³  program to maintain a file ³  Requires a string with the drive,      ³
³  control block to open,     ³  path, and filename to open, create,    ³
³  create, rename or delete   ³  rename, or delete a file. For file     ³
³  a file. For I/O requests,  ³  I/O requests, the application program  ³
³  the application program    ³  must maintain a 16 bit file handle     ³
³  also needs an FCB          ³  that is supplied by DOS.               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

  The only reason an application should use FCB function calls is to 
maintain the ability to run under DOS 1.x.  To to this, the program 
may use only function calls 00h-2Eh.  Though the FCB function calls 
are frowned upon, many of the introductory assembly language 
programming texts use the FCB calls as examples. 

  PC-MOS/386 supports the FCB calls but recommends using the handle 
calls. 



FCB Function Calls .............................................. 7**2

  FCB function calls require the use of one File Control Block per 
open file, which is maintained by the application program and DOS.  
The application program supplies a pointer to the FCB and fills in the 
appropriate fields required by the specific function call.  An FCB 
function call can perform file management on any valid drive, but only 
in the current logged directory.  By using the current block, current 
record, and record length fields of the FCB, you can perform 
sequential I/O by using the sequential read or write function calls.  
Random I/O can be performed by filling in the random record and record 
length fields. 

  Several possible uses of FCB type calls are considered programming 
errors and should not be done under any circumstances to avoid 
problems with file sharing and compatibility with later versions of 
DOS. 

 Some errors are:

1) If program uses the same FCB structure to access more than one open 
   file. By opening a file using an FCB, doing I/O, and then replacing 
   the filename field in the file control block with a new filename, a 
   program can open a second file using the same FCB. This is invalid 
   because DOS writes control information about the file into the 
   reserved fields of the FCB. If the program replaces the filename 
   field with the original filename and then tries to perform I/O on 
   this file, DOS may become confused because the control information 
   has been changed. An FCB should never be used to open a second file 
   without closing the one that is currently open. If more than one 
   File Control Block is to be open concurrently, separate FCBs should 
   be used. 

2) A program should never try to use the reserved fields in the FCB, 
   as the function of the fields may change with different versions of 
   DOS. 

3) A delete or a rename on a file that is currently open is considered 
   an error and should not be attempted by an application program. 

  It is also good programming practice to close all files when I/O is 
done. This avoids potential file sharing problems that require a limit 
on the number of files concurrently open using FCB function calls. 



Handle Function Calls ........................................... 7**3

  The recommended method of file management is by using the extended 
"handle" set of function calls.  These calls are not restricted to the 
current directory.  Also, the handle calls allow the application 
program to define the type of access that other processes can have 
concurrently with the same file if the file is being shared. 

  To create or open a file, the application supplies a pointer to an 
ASCIIZ string giving the name and location of the file.  The ASCIIZ 
string contains an optional drive letter, optional path, mandatory 
file specification, and a terminal byte of 00h.  The following is an 
example of an ASCIIZ string: 

     format:          [drive][path] FILENAME.EXT,0

     in MASM:         db "A:\PATH\FILENAME.EXT",0

  If the file is being created, the application program also supplies 
the attribute of the file.  This is a set of values that defines the 
file read-only, hidden, system, directory, or volume label. 

  If the file is being opened, the program can define the sharing and 
access modes that the file is opened in.  The access mode informs DOS 
what operations your program will perform on this file (read-only, 
write-only, or read/write).  The sharing mode controls the type of 
operations other processes may perform concurrently on the file.  A 
program can also control if a child process inherits the open files of 
the parent.  The sharing mode has meaning only if file sharing is 
loaded when the file is opened. 

  To rename or delete a file, the appplication program simply needs to 
provide a pointer to the ASCIIZ string containing the name and 
location of the file and another string with the new name if the file 
is being renamed. 

  The open or create function calls return a 16-bit value referred to 
as the file handle.  To do any I/O to a file, the program uses the 
handle to reference the file.  Once a file is opened, a program no 
longer needs to maintain the ASCIIZ string pointing to the file, nor 
is there any need to stay in the same directory.  DOS keeps track of 
the location of the file regardless of what directory is current. 

  Sequential I/O can be performed using the handle read (3Fh) or write 
(40h) function calls.  The offset in the file that I/O is performed to 
is automatically moved to the end of what was just read or written.  
If random I/O is desired, the LSEEK (42h) function call can be used to 
set the offset into the file where I/O is to be performed. 



Special File Handles ............................................ 7**4

  DOS reserves five special file handles for use by itself and 
applications programs. They are: 

ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ 0000h ³ STDIN  ³ standard input device   (input can be redirected)    ³
³ 0001h ³ STDOUT ³ standard output device  (output can be redirected)   ³
³ 0002h ³ STDERR ³ standard error output device (output cannot be       ³
³       ³        ³                               redirected)            ³
³       ³        ³ NOTE: DOS opens STDERR for both writing and reading. ³
³       ³        ³  Since STDIN can be redirected, using STDERR to read ³
³       ³        ³  the keyboard is a reliable way to ensure that your  ³
³       ³        ³  program is actually                                 ³
³       ³        ³ reading the keyboard, if that's what you want to do. ³
³ 0004h ³ STDAUX ³ standard auxiliary device                            ³
³ 0005h ³ STDPRN ³ standard printer device (PRN, normally LPT1)         ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

  These handles are predefined by DOS and can be used by an 
application program.  They do not need to be opened by a program, 
although a program can close these handles.  STDIN should be treated 
as a read-only file, and STDOUT and STDERR should be treated as write-
only files.  STDIN and STDOUT can be redirected.  All handles 
inherited by a process can be redirected, but not at the command line. 

  These handles are very useful for doing I/O to and from the console 
device.  For example, you could read input from the keyboard using the 
read (3Fh) function call and file handle 0000h (STDIN), and write 
output to the console screen with the write function call (40h) and 
file handle 0001h (STDOUT).  If you wanted an output that could not be 
redirected, you could output it using file handle 0002h (STDERR).  
This is very useful for error messages that must be seen by a user. 

  File handles 0003h (STDAUX) and 0004h (STDPRN) can be both read from 
and written to.  STDAUX is typically a serial device and STDPRN is 
usually a parallel device. 

  DOS 2.0 through 3.21 were limited to 20 file handles.  This limited 
application programs to 15 simultaneous handles.  DOS 3.3 and higher 
added the int 21h/ Set Handle Count function to give up to 65,535 file 
handles per application.  PC-MOS/386 can have more than 65,535 
handles. 


Raw and Cooked File I/O ......................................... 7**5

  Raw and cooked modes originated in the Unix world and were provided 
with DOS 2.x+.  They apply only to character I/O (including the 
keyboard, screen, printer and serial ports - but not block devices 
like disk drives), and only to the "new" 2.x file handle I/O functions 
(not the old FCB file I/O functions).  Raw mode is called "binary" 
mode in DOS 3.x+, and cooked mode is called "ASCII."  The common raw-
cooked convention is from DOS 2.x and other operating systems. 

  The five predefined DOS file handles are all devices, so the mode 
can be changed from raw to cooked via IOCTL.  These handles are in 
cooked mode when initialized by DOS.  Regular file handles that are 
not devices are always in raw mode and cannot be changed to cooked 
mode. 

  The predefined file handles STDIN (0000h) and STDOUT (0001h) and 
STDERR (0002h) are all duplicate handles.  If the IOCTL function call 
is used to change the mode of any of these three handles, the mode of 
all three handles is changed.  For example, if IOCTL was used to 
change STDOUT to raw, then STDIN and STDERR would also be changed to 
raw mode. 

  In the default cooked mode, DOS examines the character I/O data 
stream for certain special control characters, and takes specific 
actions if they are found.  For example, Ctrl-C is treated as a Break 
interrupt, Ctrl-S pauses the screen display, and Ctrl-Z is treated as 
end-of-file. (If you try to send Ctrl-Z to a printer through a DOS 
file handle in cooked mode, DOS closes the printer file!)  Also, input 
is buffered within DOS until a CR is detected - so you can't process 
each key as it is pressed. 

  In raw mode, DOS ignores special characters, passing them through 
without any special processing, and does not buffer input lines.  So 
to use file handle I/O to send bit-mapped graphics to a printer 
through DOS, or process individual keystrokes immediately, or bypass 
Ctrl-C checking, you need to switch the file handle to raw mode.  Raw 
mode is not automatically reset to cooked mode by DOS when a program 
terminates, so it is a good idea to reset the file into cooked mode 
before your program exits if the system was in cooked mode to begin 
with. I/O to files is done in raw mode. 

  To set a file handle into raw mode or back into cooked mode, use DOS 
IOCTL (int 21h Fn 44h, Chapter 4): 

   1.  Get the current mode bits (Subfunction 0).
   2.  Check that the file is a character file.  (If not, exit.)
   3.  Switch the cooked mode bit to raw or vice versa.
   4.  Set the mode bits (Subfunction 1).

  Microsoft C v4 and later do NOT set raw mode for binary files.  When 
running with the CON driver set to raw mode (to enhance display speed) 
programs compiled in MSC will crash the computer.  A letter to 
Microsoft reporting this odd behavior got the somewhat bizarre reply 
that "Microsoft does not support the use of any TSRs" from their 
techs.  Raw mode is clearly documented by both IBM and Microsoft, and 
their own tools should take it into account. 



FILE I/O IN BINARY (RAW) MODE

The following is true when a file is read in binary mode:

1)  The characters ^S (scroll lock), ^P (print screen), ^C (control
    break) are not checked for during the read.  Therefore, no printer
    echo occurs if ^S or ^P are read.
2)  There is no echo to STDOUT (0001h).
3)  Read the number of specified bytes and returns immediately when the
    last byte is received or the end of file reached.
4)  Allows no editing of the input using the function keys if the input
    is from STDIN (0000h).


The following is true when a file is written to in binary mode:

1)  The characters ^S (scroll lock), ^P (print screen), ^C (control
    break) are not checked for during the write.  Therefore, no printer
    echo occurs.
2)  There is no echo to STDOUT (0001h).
3)  The exact number of bytes specified are written.
4)  Does not caret (^) control characters. For example, Ctrl-D is sent
    out as byte 04h instead of the two bytes ^ and D.
5)  Does not expand tabs into spaces.


FILE I/O IN ASCII (COOKED) MODE

The following is true when a file is read in ASCII mode:

1)  Checks for the characters ^C,^S, and ^P.
2)  Returns as many characters as there are in the device input buffer,
    or the number of characters requested, whichever is less.  If the
    number of characters requested was less than the number of
    characters in the device buffer, then the next read will address
    the remaining characters in the buffer.
3)  If there are no more bytes remaining in the device input buffer,
    read a line (terminated by a CR) into the buffer.  This line may
    be edited with the function keys.  The characters return terminated
    with a sequence of 0Dh, 0Ah (CR, LF) if the number of characters
    requested is sufficient to include them.  For example, if 5
    characters were requested, and only 3 were entered before the
    carriage return (0Dh or ^M) was presented to DOS from the console
    device, then the 3 characters entered and 0Dh and 0Ah would be
    returned.  However, if 5 characters were requested and 7 were
    entered before the carriage return, only the first 5 characters
    would be returned.  No 0Dh, 0Ah sequence would be returned in this
    case.  If less than the number of characters requested are entered
    when the carriage return is received, the characters received and
    0Dh, 0Ah would be returned.  The reason the 0Ah (linefeed or ^J)
    is added to the returned characters is to make the devices look
    like text files.
4)  If a 1Ah (^Z) is found, the input is terminated at that point.
    No 0Dh, 0Ah (CR,LF) sequence is added to the string.
5)  Echoing is performed.
6)  Tabs are expanded.


The following is true when a file is written to in ASCII mode:

1)  The characters ^S,^P,and ^C are checked for during the write
    operation.
2)  Expands tabs to 8-character boundaries and fills with spaces
    (20h).
3)  Carets indicate control chars, for example, ^D is written as
    two bytes, '^' and 'D'.
4)  Bytes are output until the number specified is output or a ^Z is
    encountered.  The number actually output is returned to the user.



Number of Open Files Allowed  ................................... 7**6

  The number of files that can be open concurrently is restricted by 
DOS.  This number is determined by how the file is opened or created 
(FCB or handle function call) and the number specified by the FCBS and 
FILES commands in the CONFIG.SYS file.  The number of files allowed 
open by FCB function calls and the number of files that can be opened 
by handle type calls are independent of one another. 



Restrictions on FCB Usage ....................................... 7**7

  If file sharing is not loaded using the SHARE command, there is no 
restriction on the number of files concurrently open using FCB 
function calls. 

  However, when file sharing is loaded, the maximum number of FCBs 
open is set by the the FCBS command in the CONFIG.SYS file. 

  The FCBS command has two values you can specify, 'm' and 'n'.  The 
value for 'm' specifies the number of files that can be opened by 
FCBs, and the value 'n' specifies the number of FCBs that are 
protected from being closed. 

  When the maximum number of FCB opens is exceeded, DOS automatically 
closes the least recently used file.  Any attempt to access this file 
results in an int 24h critical error message "FCB not available".  If 
this occurs while an application program is running, the value 
specified for 'm' in the FCBS command should be increased. 

  When DOS determines the least recently used file to close, it does 
not include the first 'n' files opened, therefore the first 'n' files 
are protected from being closed. 



Restrictions on Handle usage .................................... 7**8

  The number of files that can be open simultaneously by all processes 
is determined by the FILES command in the CONFIG.SYS file.  The number 
of files a single process can open depends on the value specified for 
the FILES command.  If FILES is greater than or equal to 20, a single 
process can open 20 files.  If FILES is less than 20, the process can 
open less than 20 files. This value includes the three predefined 
handles STDIN, STDOUT, and STDERR.  This means only 17 additional 
handles can be added. DOS 3.3+ includes a function to use more than 20 
files per application. 



Allocating Space to a File ...................................... 7**9

  Files are not necessarily written sequentially on a disk.  Space is 
allocated as needed and the next location available on the disk is 
allocated as space for the next file being written.  Therefore, if 
considerable file generation has taken place, newly created files will 
not be written in sequential sectors. However, due to the mapping 
(chaining) of file space via the File Allocation Table (FAT) and the 
function calls available, any file may be used in either a sequential 
or random manner. 

  Space is allocated in increments called clusters.  Cluster size 
varies according to the media type.  An application program should not 
concern itself with the way that DOS allocates space to a file.  The 
size of a cluster is only important in that it determines the smallest 
amount of space that can be allocated to a file.  A disk is considered 
full when all clusters have been allocated to files. 

  A DOS file can be up to (2^32)-1 (4,294,967,295) bytes long.  This 
is the maximum value that can be put in the dword in the FAT which 
holds the file size information, less one byte for the end of file 
marker. 



MSDOS / PCDOS Differences ....................................... 7**10
                                                
  There is a problem of compatibility between MS-DOS and IBM PC-DOS 
having to do with FCB Open and Create.  The IBM 1.0, 1.1, and 2.0 
documentation of OPEN (call 0Fh) contains the following statement: 

  "The current block field (FCB bytes C-D) is set to zero [when an FCB 
is opened]." 

  This statement is NOT true of MS-DOS 1.25 or MS-DOS 2.00.  The 
difference is intentional, and the reason is CP/M 1.4 compatibility.  
Zeroing that field is not CP/M compatible.  Some CP/M programs will 
not run when machine translated if that field is zeroed.  The reason 
it is zeroed in the IBM versions is that IBM specifically requested 
that it be zeroed.  This was the reason for the complaints from some 
vendors about the fact that IBM MultiPlan would not run under MS-DOS. 
It is probably the reason that some other very old IBM programs didn't
run under MS-DOS. 

NOTE: Do what all MS/PC-DOS systems programs do: Set every single FCB 
field you want to use regardless of what the documentation says is 
initialized. 



.COM File Structure ............................................. 7**11

  The COM file structure was designed for DOS 1.0 and maximum 
compatibility with programs ported from the CP/M operating system.  
COM files normally comprise one segment only.  A COM file is loaded as 
a memory image of the disk file and the Instruction Pointer is set to 
offset 100h within the program. 

  The BIN files generated by EXE2BIN are COM files.



.EXE File Structure ............................................. 7**12

  The EXE file is the native mode for DOS.  EXE files may make use of 
multiple segments for code, stack, and data.  The design of the EXE 
file reflects the segmented design of the Intel 80x86 CPU 
architecture.  EXE files may be as large as available memory and may 
make references to specific segment addresses. 

  The EXE files produced by the Microsoft linker program consist of 
two parts, control and relocation information and the load module 
itself. 

  The control and relocation information, which is described below, is 
at the beginning of the file in an area known as the header.  The load 
module immediately follows the header.  The load module begins in the 
memory image of the module contructed by the Microsoft linker. 

  When you are loading a file with the name *.EXE, DOS does NOT assume 
that it is an EXE format file.  It looks at the first two bytes for a 
signature (the letters MZ) telling it that it is an EXE file.  If it 
has the proper signature, then the load proceeds.  Otherwise, it 
presumes the file to be a .COM format file. 

  If the file has the EXE signature, then the internal consistency is 
checked.  Pre-2.0 versions of MSDOS did not check the signature byte 
for EXE files. 

  The .EXE format can support programs larger than 64K.  It does this 
by allowing separate segments to be defined for code, data, and the 
stack, each of which can be up to 64K long.  Programs in EXE format 
may contain explicit references to segment addresses.  A header in the 
EXE file has information for DOS to resolve these references. 

  EXE file size does not reflect the amount of RAM an EXE file might 
use, since stack space or extra RAM may be allocated by the EXE loader 
at init.  Some programs may also store their overlay files in the main 
EXE file. 

  EXE files produced by the Microsoft linker are considered to be 
standard EXEs.  Digital Research's RASM86 linker produces quite 
different EXE files, as do the linkers from SLR Systems and Phoenix.  
Intel's original linker for their 8086 compiler is much more 
sophisticated than the Microsoft linker, which originally was a simple 
subset of the Intel linker.  Unfortunately the new fields added by 
OS/2, Windows, and CodeView make the newer Microsoft linkers somewhat 
different from the original Intel linker. 


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                     E X E   F I L E   H E A D E R                     ³
ÃÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Offset  ³ Size ³                 C O N T E N T S                      ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   00h   ³ BYTE ³ 4Dh ³ The Linker's signature to mark the file as a   ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄ´ valid .EXE file (ASCII letters M and Z, for    ³
³   01h   ³ BYTE ³ 5Ah ³ Mark Zbikowski, one of the major DOS           ³
³         ³      ³     ³ programmers at Microsoft)                      ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 02h-03h ³ WORD ³ Length of the image mod 512 (remainder after dividing³
³         ³      ³ the load module image size by 512) (including header)³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 04h-05h ³ WORD ³ Size of the file in 512 byte pages including the     ³
³         ³      ³ header.                                              ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 06h-07h ³ WORD ³ Number of relocation table items following the header³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 08h-09h ³ WORD ³ Size of the header in 16 byte (paragraphs).  This is ³
³         ³      ³ used to locate the beginning of the load module in   ³
³         ³      ³ the file.  Although the DOS loader will allow the    ³
³         ³      ³ actual program to begin at any location specified by ³
³         ³      ³ this value some debuggers, including Microsoft's,    ³
³         ³      ³ need the program to be aligned on a 512-byte boundary³
³         ³      ³ in the .EXE file.                                    ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0Ah-0Bh ³ WORD ³ Minimum number of 16 byte paragraphs required above  ³
³         ³      ³ the end of the loaded program.                       ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0Ch-0Dh ³ WORD ³ Max number of 16 byte paragraphs required above the  ³
³         ³      ³ end of the loaded program. If the minimum and maximum³
³         ³      ³ number of paragraphs are both zero, the program will ³
³         ³      ³ be loaded as high in memory as possible.             ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 0Eh-0Fh ³ WORD ³ Displacement in paragraphs of stack segment within   ³
³         ³      ³ load module.  This size must be adjusted by          ³
³         ³      ³ relocation.                                          ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 10h-11h ³ WORD ³Offset to be in SP register when the module is given  ³
³         ³      ³ control  (stack offset)                              ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 12h-13h ³ WORD ³ Checksum - 16-bit negative sum of all the words in   ³
³         ³      ³ the file, ignoring overflow.                         ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 14h-15h ³ WORD ³ Offset for the IP register when the module is given  ³
³         ³      ³ control  (initial instruction pointer)               ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 16h-17h ³ WORD ³ Offset in paragraphs of code segment (CS) within load³
³         ³      ³ module.  This size must be adjusted by relocation.   ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 18h-19h ³ WORD ³ Offset in bytes of the relocation pointer table.     ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 1Ah-1Bh ³ WORD ³ Overlay number (0 for the resident part of the       ³
³         ³      ³ program)                                             ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   1Ch   ³ BYTE ³ (undocumented) Microsoft compilers put 01h here,     ³
³         ³      ³ which may indicate the version of .EXE header        ³
³         ³      ³ structure for later changes.  Normally the relocation³
³         ³      ³ table begins at 1Eh, but that can be changed to a    ³
³         ³      ³ different location if the word at 18-19h is adjusted ³
³         ³      ³ to match.                                            ³
ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



The Relocation Table ............................................ 7**13

  The word at 18h locates the first entry in the relocation table.  
The relocation table is made up of a variable number of relocation 
items.  The number of items is contained at offset 06h.  The 
relocation item contains two fields - a 2 byte offset value, followed 
by a 2 byte segment value.  These two fields represent the 
displacement into the load module before the module is given control.  
The process is called relocation and is accomplished as follows: 

1. The formatted part of the header is read into memory.  Its size
   is 1Bh.

2. A portion of memory is allocated depending on the size of the load 
   module and the allocation numbers in offsets 0Ah and 0Ch. DOS 
   always tries to allocate 0FFFFh paragraphs. Since this call will 
   always fail, the function returns the amount of free memory. If 
   this block is larger than the minimum specified at offset 0Ah and 
   the loaded program size, DOS will allocate the size specified at 
   offset 0Ch or the largest free memory space, whichever is less. 

3. A Program Segment Prefix is built following the resident portion of 
   the program that is performing the load operation. 

4. The formatted part of the header is read into memory (its size is 
   at offset 08h) 

5. The load module size is determined by subtracting the header size 
   from the file size. Offsets 04h and 08h can be used for this 
   calculation. The actual size is downward adjusted based on the 
   contents of offset 02h. Note that all files created by the Linker 
   programs prior to version 1.10 always placed a value of 4 at this 
   location, regardless of the actual program size. Therefore, 
   Microsoft recommends that this field be ignored if it contains a 
   value of 4. Based on the setting of the high/low loader switch, an 
   appropriate segment is determined for loading the load module. This 
   segment is called the start segment. 

6. The load module is read into memory beginning at the start segment. 
   The relocation table is an ordered list of relocation items. The 
   first relocation item is the one that has the lowest offset in the 
   file. 

7. The relocation table items are read into a work area one or more at 
   a time. 

8. Each relocation table item segment value is added to the start 
   segment value. The calculated segment, in conjunction with the 
   relocation item offset value, points to a word in the load module 
   to which is added the start segment value. The result is placed 
   back into the word in the load module. 

9. Once all the relocation items have been processed, the SS and SP 
   registers are set from the values in the header and the start 
   segment value is added to SS. The ES and DS registers are set to 
   the segment address of the program segment prefix. The start 
   segment value is added to the header CS register value. The result, 
   along with the header IP value, is used to give the module control. 



"NEW" .EXE Format (Microsoft Windows and OS/2) .................. 7**14

  The "old" EXE format is documented here.  The "new" EXE format puts 
more information into the header section and is currently used in 
applications that run under Microsoft Windows.  The linker that 
creates these files comes with the Microsoft Windows Software 
Development Kit and is called LINK4.  If you try to run a Windows-
linked program under DOS, you will get the error message "This program 
requires Microsoft Windows".  The OS/2 1.x file format is essentially 
the same as the Windows format. 

  Windows executables have dynamic linking and all of the code/data 
inside an EXE file is not necessarily loaded at run time. 

  Offset 3Ch dword: offset of new .EXE header (for Microsoft Windows & 
OS/2) 



Standard File Control Block ..................................... 7**15

  The standard file control block is defined as follows, with offsets 
in hex: 

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³              F I L E      C O N T R O L      B L O C K                ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³offset ³  size   ³                      Function                       ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   0   ³ 1 byte  ³ Drive number. For example:                          ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ Before open:    00h = default drive                           ³
³       ³                 01h = drive A:                                ³
³       ³                 02h = drive B: etc.                           ³
³       ³ After open:     00h = drive C:                                ³
³       ³                 01h = drive A:                                ³
³       ³                 02h = drive B: etc.                           ³
³       ³ A zero is replaced by the actual drive number during opening. ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  1-8  ³ 8 bytes ³ Filename, left justified with blanks.               ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ If a reserved device name is placed here (such as PRN) do not ³
³       ³ include the optional colon.                                   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  9-B  ³ 3 bytes ³ Filename extension, left justified with trailing    ³
³       ³         ³ blanks.                                             ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  C-D  ³ 2 bytes ³ Current block # relative to start of file, starting ³
³       ³         ³ with 0                                              ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ (set to 0 by the OPEN function call).  A block consists of    ³
³       ³ 128 records, each of the size specified in the logical record ³
³       ³ size field.  The current block number is used with the current³
³       ³ record field (below) for sequential reads and writes.         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  E-F  ³ 2 bytes ³ Logical record size in bytes.                       ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ Set to 80h by OPEN function.  If this is not correct, you     ³
³       ³ must set the value because DOS uses it to determine the       ³
³       ³ proper locations in the file for all disk reads and writes.   ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 10-13 ³ 4 bytes ³ File size in bytes.                                 ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ In this field, the first word is the low-order part of the    ³
³       ³ size.                                                         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 14-15 ³ 2 bytes ³Date file was created or last updated.               ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ MM/DD/YY are mapped as follows:                               ³
³       ³         15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0  ³
³       ³         y   y   y   y   y   y   y  m  m  m  m  d  d  d  d  d  ³
³       ³ where:            mm is 1-12                                  ³
³       ³                   dd is 1-31                                  ³
³       ³                   yy is 0-119 (1980-2099)                     ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 16-17 ³ 2 bytes³ Time file was created or last updated.               ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ These bytes contain the time when the file was created or     ³
³       ³ last updated.  The time is mapped in the bits as follows:     ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³         B Y T E   16h         ³         B Y T E   17h         ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ F   E   D   C   B   A   9   8 ³ 7   6   5   4   3   2   1   0 ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ H   H   H   H   H ³ M   M   M   M   M   M ³ D   D   D   D   D ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ binary # hrs 0-23 ³ binary # minutes 0-59 ³ bin. # 2-sec incr ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ note: The time is stored with the least significant byte first³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 18-19 ³ 2 bytes³ Reserved for DOS.                                    ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  20   ³ 1 byte ³ Current relative record number.                      ³
³       ÃÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ (0-127) within the current block.  This field and the Current ³
³       ³ Block field at offset 0Ch make up the record pointer.  This   ³
³       ³ field is not initialized by the OPEN (0Fh) function call.     ³
³       ³ You must set this field before doing sequential read-write    ³
³       ³ operations to the diskette.  To read the first record of a    ³
³       ³ file, set this value to zero.                                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 21-25 ³ 4 bytes ³ Relative Record.                                    ³
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ Points to the currently selected record, counting from the    ³
³       ³ beginning of the file starting with 0.  This field is not     ³
³       ³ initialized by the OPEN system call.  You must set this field ³
³       ³ before doing a random read or write to the file.              ³
³       ³  If the record size is less than 64 bytes, both words are     ³
³       ³ used.  Otherwise, only the first 3 bytes are used.  Note that ³
³       ³ if you use the File Control Block at 5Ch in the program       ³
³       ³ segment, the last byte of the FCB overlaps the first byte of  ³
³       ³ the unformatted parameter area.                               ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        
note 1) An unopened FCB consists of the FCB prefix (if used), drive 
        number, and filename.ext properly filled in. An open FCB is 
        one in which the remaining fields have been filled in by the 
        CREAT or OPEN function calls. 
     2) Bytes 0-5 and 32-36 must be set by the user program. Bytes 16-
        31 are set by DOS and must not be changed by user programs. 
     3) All word fields are stored with the least significant byte 
        first. For example, a record length of 128 is stored as 80h at 
        offset 14, and 00h at offset 15. 

  Oddly, when Microsoft added the handle calls to DOS they still left 
the old FCB calls with a few advantages.  Handle calls still can't 
read volume labels or directory files and don't support wild card 
deletions.  Microsoft has always claimed that they would eventually 
fix these weaknesses, but we're up to DOS 6.0 and it isn't soup yet. 

  Microsoft has always hinted that they would eventually drop FCB 
support from DOS.  Since many compiler runtime libraries depend on FCB 
calls since they are the only ones portable across all DOS versions, a 
lot of existing (expensive) commercial software would no longer run.  
Also note that even the OS/2 Compatibility Box supports FCB calls. 

  Many of the handle calls are simply "front ends" for the existing 
FCB code anyway.  It's unlikely the FCB calls will ever vanish from 
DOS. 


Extended File Control Block ..................................... 7**16

  The extended file control block is used to create or search for 
files in the disk directory that have special attributes. 

  It adds a 7 byte prefix to the FCB, formatted as follows:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³    E X T E N D E D     F I L E      C O N T R O L      B L O C K       ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Offset ³   Size  ³                      Function                        ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  00h  ³ 1 byte  ³ Flag byte containing 0FFh to indicate an extended FCB³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  01h  ³ 4 bytes ³ Reserved by Microsoft                                ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  06h  ³ 2 bytes ³ Attribute byte                                       ³
³       ÃÄÄÄÄÄÂÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ hex ³bit³                       meaning                        ³
³       ÃÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ 00h ³   ³ (no bits set) normal; can be read or written without ³
³       ³     ³   ³ restriction                                          ³
³       ³ 01h ³ 0 ³ file is marked read-only.  An attempt to open the    ³
³       ³     ³   ³ file for output using int 21h/fn 3Dh will fail and   ³
³       ³     ³   ³ an error code will be returned.  This value can be   ³
³       ³     ³   ³ used with other values below.                        ³
³       ³ 02h ³ 1 ³ indicates a hidden file.  The file is excluded from  ³
³       ³     ³   ³ normal directory searches.                           ³
³       ³ 04h ³ 2 ³ indicates a system file.  The file is excluded from  ³
³       ³     ³   ³ normal directory searches.                           ³
³       ³ 08h ³ 3 ³ indicates that the entry contains the volume label   ³
³       ³     ³   ³ in the first 11 bytes.  The entry has no other       ³
³       ³     ³   ³ usable information and may exist only in the root    ³
³       ³     ³   ³ directory.                                           ³
³       ³ 10h ³ 4 ³ indicates that the file is a subdirectory            ³
³       ³ 20h ³ 5 ³ indicates an archive bit.  This bit is set to on     ³
³       ³     ³   ³ whenever the file is written to and closed.  Used by ³
³       ³     ³   ³ BACKUP and RESTORE.                                  ³
³       ³     ³ 6 ³ reserved, set to 0                                   ³
³       ³     ³ 7 ³ reserved, set to 0                                   ³
³       ÃÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ note 1) Bits 6 and 7 may be used in OS/2.                      ³
³       ³ note 2) Attributes 08h and 10h cannot be changed using         ³
³       ³         int21/43h.    ³                                        ³
³       ³ note 3) The system files IBMBIO.COM and IBMDOS.COM (or         ³
³       ³         customized equivalent) are marked as read-only, hidden,³
³       ³         and system  files.  Files can be marked hidden when    ³
³       ³         they are created.                                      ³
³       ³ note 4) Read-only, hidden, system and archive attributes may   ³
³       ³         be changed with int21h/fn43h.                          ³
³       ³                                                                ³
³       ³ Refer to int 21h/fn11h (Search First) for details on using the ³
³       ³ attribute bits during directory searches.  This function is    ³
³       ³ present to allow applications to define their own files as     ³
³       ³ hidden (and thereby excluded from normal directory searches)   ³
³       ³ and to allow selective directory searches                      ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

  Any reference in the DOS function calls to an FCB, whether opened or 
unopened, may use either a normal or extended FCB.  If you are using 
an extended FCB, the appropriate register should be set to the first 
byte of the prefix, rather than the drive-number field. 

  Common practice is to refer to the extended FCB as a negative offset 
from the first byte of a standard File Control Block. 


Disk Transfer Area .............................................. 7**17

  The old-style (DOS 1.x compatible) FCB-oriented function calls use a 
buffer called the Disk Transfer Area (DTA) for disk access.  Use of 
the DTA is documented in Chapter 6, "DOS Memory Control Blocks and 
Work Areas." 



       **  Programmer's Technical Reference for MSDOS and the IBM PC **
                USA copyright TXG 392-616  ALL RIGHTS RESERVED
     ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ISBN 1-878830-02-3 (disk-based text)
                    Copyright (c) 1987, 1994 Dave Williams
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³ Shareware Version, 01/20/94 ³
                        ³  Please Register Your Copy  ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                           C H A P T E R   E I G H T


                             DOS DISK INFORMATION


                                C O N T E N T S

The DOS Area .......................................................... 8**1
The Boot Record ....................................................... 8**2
DOS File Allocation Table (FAT) ....................................... 8**3
        Media Descriptor Byte ......................................... 8**4
        12 Bit FATs ................................................... 8**5
        16 Bit FATs ................................................... 8**6
DOS Disk Directory .................................................... 8**8
The Data Area ......................................................... 8**9
Floppy Disk Types ..................................................... 8**10
Hard Disk Layout ...................................................... 8**11
System Initialization ................................................. 8**12
Boot Record/Partition Table ........................................... 8**13
Hard Disk Technical Information ....................................... 8**14
Determining Hard Disk File Allocation ................................. 8**15
BIOS Disk Functions ................................................... 8**16
        00h  Reset
        01h  Get Status
        02h  Read Sectors
        03h  Write Sectors
        04h  Verify
        05h  Format Track (floppy disk)
        06h  Hard Disk - format track
        07h  Hard Disk - format drive
        08h  Read Drive Parameters
        09h  Initialize Two Fixed Disk Base Tables
        0Ah  Read Long (Hard disk)
        0Bh  Write Long (Hard disk)
        0Ch  Seek To Cylinder
        0Dh  Alternate Hard Disk Reset
        0Eh  Read Sector Buffer
        0Fh  Write sector buffer
        10h  Test For Drive Ready
        11h  Recalibrate Drive
        12h  Controller RAM Diagnostic
        13h  Controller Drive Diagnostic
        14h  Controller Internal Diagnostic
        15h  Get Disk Type
        16h  Get Disk Change Status (diskette)
        17h  Set Disk Type for Format (diskette)
        18h  Set Media Type For Format (diskette)
        19h  Park Hard Disk Heads
        1Ah  ESDI Hard Disk - Low Level Format
        1Bh  ESDI Hard Disk - Get Manufacturing Header
        1Ch  ESDI Hard Disk - Get Configuration




THE DOS AREAÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 8**1

 All disks and diskettes formatted by DOS are created with a sector size of 512
bytes. The DOS area (entire area for a diskette, DOS partition for hard disks)
is formatted as follows:

        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        ³                       D O S   A R E A                      ³
        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³ partition table          - variable size (hard disk only)  ³
        ³ boot record              - 1 sector                        ³
        ³ first copy of the FAT    - variable size                   ³
        ³ second copy of the FAT   - same size as first copy         ³
        ³ root directory           - variable size                   ³
        ³ data area                - variable depending on disk size ³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

The following sections describe each of the allocated areas:



THE BOOT RECORDÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 8**2

 The boot record resides on track 0, sector 1, side 0 of every diskette
formatted by the DOS FORMAT program. For hard disks the boot record resides on
the first sector of the DOS partition. It is put on all disks to provide an
error message if you try to start up with a nonsystem disk in drive A:. If the
disk is a system disk, the boot record contains a JMP instruction pointing to
the first byte of the operating system.

 If the device is IBM compatible the first sector of the first FAT must be
located at the same sector for all disk types. This is because the FAT sector
is read before the disk type is actually determined.

 The information relating to the BPB for a particular media is kept in the 
disk's boot sector.  The format of the boot sector is:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                        D O S   B O O T   R E C O R D                         ³
ÃÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³00h³3 bytes³  JMP to executable code. For DOS 2.x, 3 byte near jump (0E9h).   ³
³   ³       ³  For DOS 3.x, 2 byte near jump (0EBh) followed by a NOP (90h)    ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³03h³8 bytes³  optional OEM name and version  (such as IBM 2.1)                ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0Bh³2 bytes³  bytes per sector                                                ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0Dh³ byte  ³     ³  sectors per allocation unit (must be a power of 2)        ³
ÃÄÄÄÅÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0Eh³2 bytes³  B  ³  reserved sectors (starting at logical sector 0)           ³
³   ³       ³     ³  01 for 1.x-3.31, 02 for 4.0+                              ³
ÃÄÄÄÅÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³10h³ byte  ³     ³  number of FATs                                            ³
ÃÄÄÄÅÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³11h³2 bytes³     ³  maximum number of root directory entries                  ³
ÃÄÄÄÅÄÄÄÄÄÄÄ´  P  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³13h³2 bytes³     ³  number of sectors in logical image (total number of       ³
³   ³       ³     ³  sectors in media, including boot sector directories, etc.)³
³   ³       ³     ³  If logical disk size is geater than 32Mb, this value is 0 ³
³   ³       ³     ³  and the actual size is reported at offset 26h (DOS 4.0+)  ³
ÃÄÄÄÅÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³15h³ byte  ³  B  ³  media descriptor byte                                     ³
ÃÄÄÄÅÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³16h³2 bytes³     ³  number of sectors occupied by a single FAT                ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³18h³2 bytes³  sectors per track                                               ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1Ah³2 bytes³  number of heads                                                 ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1Ch³2 bytes³  # of hidden sectors  (sectors before this volume) (1st part)    ³
ÀÄÄÄÁÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ³                EXTENDED BOOT RECORD (DOS 4.0+)                   ³
ÚÄÄÄÂÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1Eh³2 bytes³  # of hidden sectors  (sectors before this volume) (2nd part)    ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³20h³4 bytes³  # sectors in this disk (see offset 13h, if 0)                   ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³24h³2 bytes³  physical drive number (max 2 for DOS 4, max 8 for DOS 5)        ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³26h³ byte  ³  extended boot record signature  (29h)                           ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³27h³4 bytes³  volume serial number (assigned with a random function)          ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2Bh³11 byte³  volume label                                                    ³
ÃÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³36h³7 bytes³  file system ID   (FAT12   ), (FAT16   ) etc.     ("reserved")   ³
ÀÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 The three words at the end return information about the media. The number of
heads is useful for supporting different multihead drives that have the same
storage capacity but a different number of surfaces. The number of hidden
sectors is useful for drive partitioning schemes.

 DOS 3.2 uses a table called the BIOS Parameter Block (BPB) to determine if a
disk has a valid File Allocation Table. The BPB is located in the first sector
of a floppy disk. Although the BPB is supposed to be on every formatted floppy
disk, some earlier versions of DOS did not create a BPB and instead assumed that
the FAT begins at the second sector of the disk and that the first FAT byte
(Media Descriptor Byte) describes the disk format.
 DOS 3.2 reads in the whole of the BPB and tries to use it - although strangely
enough, it seems as if DOS is prepared to cope with a BPB that is more or less
totally blank (it seems to ignore the descriptor byte and treat it as a DSDD
9-sector disk).
 DOS 3.2 determines if a disk has a valid boot sector by examining the first
byte of logical sector 0. If that byte it a jump instruction 0E9h, DOS 3.2
assumes the rest of the sector is a valid boot sector with a BPB. If the first
byte is not 0E9h DOS 3.2 behaves like previous versions, assumes the boot sector
is invalid and uses the first byte of the FAT to determine the media type.
 If the first byte on the disk happens to be 0E9h, but the disk does not have a
BPB, DOS 3.2 will return a disk error message.
 The real problems occur if some of the BPB data is valid and some isn't.
Apparently some OEMs have assumed that DOS would continue to ignore the
formatting data on the disk, and have failed to write much there during FORMAT
except the media descriptor byte (or, worse, have allowed random junk to be
written there). While this error is understandable, and perhaps even
forgiveable, it remains their problem, not IBM's, since the BPB area has always
been documented as containing the format information that IBM DOS 3.2 now
requires to be there.

 When the BPB problems first became evident with DOS 3.2 a number of reports
circulated claiming DOS looked for the letters "IBM" in the OEM ID field. This 
was incorrect. IBM DOS 4.0 *did* check for the letters "IBM" and would refuse
to recognize hard drives formatted under MSDOS 4.0. IBM corrected this with
their 4.01 revision.



THE DOS FILE ALLOCATION TABLE (FAT)ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ 8**3

 The File Allocation Table, or FAT, has three main purposes:
        1) to mark bad sectors on the media
        2) to determine which sectors are free for use
        3) to determine the physical location(s) of a file on the media.

 DOS uses one of two schemes for defining the File Allocation Table:
        1) a 12-bit FAT, for DOS 1.x, 2.x, all floppies, and small hard disks
        2) a 16-bit FAT, for DOS 3.x+ hard disks from 16.8 to 32Mb

 This section explains how DOS uses the FAT to convert the clusters of a file
into logical sector numbers. It is recommended that system utilities use the
DOS handle calls rather than interpreting the FAT, particularly since
aftermarket disk partitioning or formatting software may have been used.

 The FAT is used by DOS to allocate disk space for files, one cluster at a time.
In DOS 4.0, clusters are referred to as "allocation units." It means the same
things; the smallest logical portion of a drive.

 The FAT consists of a 12 bit entry (1.5 bytes) for each cluster on the disk or
a 16 bit (2 bytes) entry when a hard disk has more than 20740 sectors as is the
case with fixed disks larger than 10Mb.

 The first two FAT entries map a portion of the directory; these FAT entries
contain indicators of the size and format of the disk. The FAT can be in a 12
or 16 bit format. DOS determines whether a disk has a 12 or 16 bit FAT by
looking at the total number of allocation units on a disk. For all diskettes
and hard disks with DOS partitions less than 20,740 sectors, the FAT uses a 12
bit value to map a cluster. For larger partitions, DOS uses a 16 bit value.

 The second, third, and fourth bit applicable for 16 bit FAT bytes always
contains 0FFFFh. The first byte is used as follows:


Media Descriptor Byte ................................................. 8**4

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                 M E D I A    D E S C R I P T O R    B Y T E                  ³
ÃÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³hex value ³              meaning             ³         normally used          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    00    ³ hard disk                        ³ 3.3+ extended DOS partition    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    ED    ³ double sided  9 sector 80 track  ³ Tandy 2000 720k         (5¬)   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    F0    ³ double sided  18 sector diskette ³ PS/2 1.44 meg DSHD             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    F8    ³ hard disk                        ³ bootable hard disk at C:800    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    F8    ³ 720k floppy, 9 sector 80 track   ³ Sanyo 55x, DS-DOS 2.11  (5¬)   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    F9    ³ double sided  15 sector diskette ³ AT 1.2 meg DSHD                ³
³          ³ double sided  9  sector diskette ³ Convertible 720k DSQD          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    FA    ³ IBM Displaywriter System disk    ³ 287k                           ³
³          ³ Kodak "4 meg"  (Pelican)         ³ 4.4 meg                 (5¬)   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    FB    ³ IBM Displaywriter System disk    ³ 1 meg                   (5¬)   ³
³          ³ Kodak "6 meg"  (Pelican)         ³ 5.5 meg                 (5¬)   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    FC    ³ single sided  9  sector diskette ³ DOS 2.0, 180k SSDD      (5¬)   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    FD    ³ double sided  9  sector diskette ³ DOS 2.0, 360k DSDD      (5¬)   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    FF    ³ double sided 36  sector diskette ³ Practidisk 2.88mb DSED  (3«)   ³
³          ³ single sided  8  sector diskette ³ DOS 1.0, 160k SSDD      (5¬)   ³
³          ³ double sided  8  sector diskette ³ DOS 1.1, 320k SSDD      (5¬)   ³
³          ³ hard disk                        ³ Sanyo 55x with DS-DOS 2.11     ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
³for 8 inch diskettes: ³
ÃÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³    FD    ³ double sided  26 sector diskette ³ IBM 3740 format DSSD           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    FE    ³ single sided  26 sector diskette ³ IBM 3740 format SSSD           ³
³          ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³          ³ double sided  8  sector diskette ³ IBM 3740 format DSDD           ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



The third FAT entry begins mapping the data area (cluster 002).

NOTE: These values are provided as a reference. Therefore, programs should not
      make use of these values.

 Each entry contains three hexadecimal characters for 12-bit FATs or four for
16-bit FATs.

The possible entries are:

   12-bit   |   16-bit
            |
      000h  |        0000h   if the cluster is unused and available

      0FF7h |        0FFF7h  bad cluster (if not part of the allocation chain)
            |
0FF0h-0FF7h | 0FFF0h-0FFF7h  to indicate reserved clusters
            |
0FF8h-0FFFh | 0FFF8h-0FFFFh  to indicate the last cluster of a file (EOF)
            |
       xxxH |         xxxxH  any other hexadecimal numbers are the cluster
            |                number of the next cluster in the file. The
            |                cluster number is the first cluster in the file
            |                that is kept in the file's directory entry.

 The file allocation table always occupies the sector or sectors immediately
following the boot record. If the FAT is larger than 1 sector, the sectors
occupy consecutive sector numbers. Two copies of the FAT are written, one
following the other, for integrity. The FAT is read into one of the DOS buffers
whenever needed (open, allocate more space, etc).



12 Bit File Allocation Table .......................................... 8**5

Obtain the starting cluster of the file from the directory entry.

Now, to locate each subsequent sector of the file:

1. Multiply the cluster number just used by 1.5 (each FAT entry is 1.5
   bytes long).
2. The whole part of the product is offset into the FAT, pointing to the entry
   that maps the cluster just used. That entry contains the cluster number of
   the next cluster in the file.
3. Use a MOV instruction to move the word at the calculated FAT into a register.
4. If the last cluster used was an even number, keep the low order 12 bits of
   the register, otherwise, keep the high order 12 bits.
5. If the resultant 12 bits are (0FF8h-0FFFh) no more clusters are in the file.
   Otherwise, the next 12 bits contain the cluster number of the next cluster in
   the file.

  To convert the cluster to a logical sector number (relative sector, such as
that used by int 25h and 26h and DEBUG):

1. Subtract 2 from the cluster number
2. Multiply the result by the number of sectors per cluster.
3. Add the logical sector number of the beginning of the data area.

12-bit FAT if DOS partition is smaller than 32,680 sectors (16.340 MB).



16 Bit File Allocation Table .......................................... 8**6

 Obtain the starting cluster of the file from the directory entry. Now to
locate each subsequent cluster of the file:

1.  Multiply the cluster number used by 2 (each FAT entry is 2 bytes long).
2.  Use the MOV word instruction to move the word at the calculated FAT offset
    into a register.
3.  If the resultant 16 bits are (0FF8h-0FFFFh) no more clusters are in the
    file. Otherwise, the 16 bits contain the cluster number of the next cluster
    in the file.




DOS Disk Directory .................................................... 8**8

 The FORMAT command initially builds the root directory for all disks. Its
location (logical sector number) and the maximum number of entries are
available through the device driver interfaces.

 Since directories other than the root directory are actually files, there is
no limit to the number of entries that they may contain.

 All directory entries are 32 bytes long, and are in the following format:
ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³offset ³  size   ³                  DISK DIRECTORY ENTRY
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  00h  ³ 8 bytes ³ Filename
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ The first byte of the filename indicates the file status.
³       ³ The file status byte may contain the following values:
³       ÃÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³  00h ³ Directory entry has never been used. This is used to limit
³       ³      ³ the length of directory searches, for performance reasons.
³       ³  05h ³ Indicates that the first character of the filename actually
³       ³      ³ has an 0EDh character.
³       ³ 0E5h ³ Filename has been used but the file has been erased.
³       ³  2Eh ³ This entry is for a directory. If the second byte is also
³       ³      ³ 2Eh, the cluster field contains the cluster number of this
³       ³      ³ directory's parent directory. (0000h if the parent directory
³       ³      ³ is the root directory). Otherwise, bytes 00h-0Ah are all
³       ³      ³ spaces and the cluster field contains the cluster number of
³       ³      ³ the directory.
³       ÃÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ Any other character is the first character of a filename. Filenames
³       ³ are left-aligned and if necessary padded with blanks.
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  08h  ³ 3 bytes ³ Filename extension if any
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ Three characters, left-aligned and padded with blanks if necessary.
³       ³ If there is no file extension, this field contains all blanks
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  0Bh  ³ 1 byte  ³ File attributes
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³          The attribute byte is mapped as follows:
³       ÃÄÄÄÄÄÂÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ hex ³bit³                    meaning
³       ÃÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ 00h ³   ³ (no bits set) normal; can be read or written without
³       ³     ³   ³ restriction
³       ³ 01h ³ 0 ³ file is marked read-only. An attempt to open the file for
³       ³     ³   ³ output using int 21h/fn 3Dh will fail and an error code
³       ³     ³   ³ will be returned. This value can be used with other values
³       ³     ³   ³ below.
³       ³ 02h ³ 1 ³ indicates a hidden file. The file is excluded from normal
³       ³     ³   ³ directory searches.
³       ³ 04h ³ 2 ³ indicates a system file. The file is excluded from normal
³       ³     ³   ³ directory searches.
³       ³ 08h ³ 3 ³ indicates that the entry contains the volume label in the
³       ³     ³   ³ first 11 bytes. The entry has no other usable information
³       ³     ³   ³ and may exist only in the root directory.
³       ³ 10h ³ 4 ³ indicates that the file is a subdirectory
³       ³ 20h ³ 5 ³ indicates an archive bit. This bit is set to on whenever
³       ³     ³   ³ the file is written to and closed. Used by BACKUP and
³       ³     ³   ³ RESTORE.
³       ³     ³ 6 ³ reserved, set to 0
³       ³     ³ 7 ³ reserved, set to 0
³       ÃÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ note 1) Bits 6 and 7 may be used in OS/2.
³       ³ note 2) Attributes 08h and 10h cannot be changed using int21/43h.
³       ³ note 3) The system files IBMBIO.COM and IBMDOS.COM (or customized
³       ³         equivalent) are marked as read-only, hidden, and system
³       ³         files. Files can be marked hidden when they are created.
³       ³ note 4) Read-only, hidden, system and archive attributes may be
³       ³         changed with int21h/fn43h.
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  0Ch  ³ 10 bytes³ Reserved by DOS; value unknown
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  16h  ³ 2 bytes ³ File timestamp
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ These bytes contain the time when the file was created or last
³       ³  updated. The time is mapped in the bits as follows:
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³       ³         B Y T E   16h         ³         B Y T E   17h         ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ F   E   D   C   B   A   9   8 ³ 7   6   5   4   3   2   1   0 ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ H   H   H   H   H ³ M   M   M   M   M   M ³ D   D   D   D   D ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ binary # hrs 0-23 ³ binary # minutes 0-59 ³ bin. # 2-sec incr ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
³       ³ note: The time is stored with the least significant byte first.
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  18h  ³ 2 bytes ³ File datestamp
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ This area contains the date when the file was created or last
³       ³ updated. The mm/dd/yy are mapped in the bits as follows:
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³       ³         B Y T E   18h         ³         B Y T E   19h         ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ F   E   D   C   B   A   9   8 ³ 7   6   5   4   3   2   1   0 ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ Y   Y   Y   Y   Y   Y   Y ³ M   M   M   M ³ D   D   D   D   D ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³     0-119 (1980-2099)     ³     1-12      ³       1-31        ³
³       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
³       ³ note: The date is stored with the least significant byte first.
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  1Ah  ³ 2 bytes ³ First file cluster number
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ * (reserved in DOS 2, documented in DOS 3+)
³       ³ This area contains the starting cluster number of the first cluster
³       ³ in the file. The first cluster for data space on all fixed disks and
³       ³ floppy disks is always cluster 002. The cluster number is stored
³       ³ with the least significant byte first.
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  1Ch  ³ 4 bytes ³ File size
³       ÃÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³       ³ This area contains the file size in bytes. The first word contains
³       ³ the low order part of the size. Both words are stored with the least
³       ³ significant byte first.
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



The Data Area ......................................................... 8**9

 Allocation of space for a file (in the data area) is done only when needed
(it is not preallocated). The space is allocated one cluser (unit allocation)
at a time. A cluster is always one or more consecutive sector numbers, and all
of the clusters in a file are "chained" together in the FAT.

 The clusters are arranged on disk to minimize head movement for multisided
media. All of the space on a track (or cylinder) is allocated before moving
on to the next track. This is accomplished by using the sequential sector
numbers on the lowest-numbered head, then all the sector numbers on the next
head, and so on until all sectors of all heads of the track are used. Then the
next sector used will be sector 1 of head 0 on the next track.

 An interesting innovation that was introduced in MS-DOS 3.0: disk space that
is freed by erasing a file is not re-used immediately, unlike earlier versions
of DOS. Instead, free space is obtained from the area not yet used during the
current session, until all of it is used up. Only then will space that is freed
during the current session be re-used.

 This feature minimizes fragmentation of files, since never-before-used space
is always contiguous. However, once any space has been freed by deleting a file,
that advantage vanishes at the next system boot. The feature also greatly
simplifies un-erasing files, provided that the need to do an un-erase is found
during the same session and also provided that the file occupies contiguous
clusters.

 However, when one is using programs which make extensive use of temporary
files, each of which may be created and erased many times during a session,
the feature becomes a nuisance; it forces the permanent files to move farther
and farther into the inner tracks of the disk, thus increasing rather than
decreasing the amount of fragmentation which occurs.

 The feature is implemented in DOS by means of a single 16-bit "last cluster
used" (LCU) pointer for each physical disk drive; this pointer is a part of
the physical drive table maintained by DOS. At boot time, the LCU pointer is
zeroed. Each time another cluster is obtained from the free-space pool (the
FAT), its number is written into the LCU pointer. Each time a fresh cluster
is required, the FAT is searched to locate a free one; in older versions of
DOS this search always began at Cluster 0000, but in 3.x it begins at the
cluster pointed to by the LCU pointer.

 For hard disks, the size of the file allocation table and directory are
determined when FORMAT initializes it and are based on the size of the DOS
partition.



Floppy Disk Types ..................................................... 8**10

The following tables give the specifications for floppy disk formats:

IBM PC-DOS disk formats:
                 # of      FAT size   DIR     total
                 sides    (sectors)(entries) sectors
                   ³  sectors  ³  DIR  ³ sectors³
                   ³  /track   ³sectors³/cluster³
                   ³     ³     ³   ³   ³   ³    ³
ÚÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÁÄÂÄÄÄÁÄÄÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÄÁÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ 160k³5¬³DOS 1.0³ 1 ³ 8 (40)³ 1 ³ 4 ³ 64³ 1 ³ 320³Original PC-0, 16k mbd
³ 320k³5¬³DOS 1.1³ 2 ³ 8 (40)³ 1 ³ 7 ³112³ 2 ³ 360³PC-1, 64k mbd
³ 180k³5¬³DOS 2.0³ 1 ³ 9 (40)³ 2 ³ 4 ³ 64³ 1 ³ 640³PC-2, 256k mbd
³ 360k³5¬³DOS 2.0³ 2 ³ 9 (40)³ 2 ³ 7 ³112³ 2 ³ 720³PC/XT
³ 1.2M³5¬³DOS 3.0³ 2 ³15 (80)³ 7 ³14 ³224³ 1 ³2400³PC/AT, PC/RT, XT/286
³ 720k³3«³DOS 3.2³ 2 ³ 9 (80)³ 3 ³ 7 ³112³ 2 ³1440³Convertible, PS/2 25+
³1.44M³3«³DOS 3.3³ 2 ³18 (80)³ 9 ³14 ³224³ 1 ³2880³PS/2 50+
ÀÄÄÄÄÄÁÄÄÁÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
various MS-DOS disk formats:
ÚÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÁÄÂÄÄÄÁÄÄÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÄÁÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ 200k³5¬³  *    ³ 1 ³10 (40)³   ³   ³   ³   ³    ³
³ 400k³5¬³  * ** ³ 2 ³10 (40)³   ³   ³   ³   ³    ³
³ 800k³5¬³  *    ³ 2 ³10 (80)³   ³   ³   ³   ³    ³
³ 720k³2 ³       ³   ³       ³   ³   ³   ³   ³    ³Zenith SuperSport 2-inch
³ 720k³5¬³DOS2.11³ 2 ³ 9 (80)³ 3 ³ 7 ³112³ 2 ³1440³Tandy 2000 (discontinued)
³2.88M³3«³       ³ 2 ³36 (80)³   ³   ³   ³   ³5760³Practidisk 2.88mb floppy
³2720k³5¬³  ***  ³ 2 ³17(192)³ 8 ³   ³272³ 4 ³5440³Pelican (Kodak 3.3Mb)(disc.)
³5570k³5¬³  ***  ³ 2 ³17(384)³ 8 ³   ³272³ 4 ³10880Pelican (Kodak 6.6Mb)(disc.)
ÀÄÄÄÄÄÁÄÄÁÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
*   Michtron DS-DOS 2.11 Plus and one version of MS-DOS 3.11 (vendor unknown)
**  TallTree JFormat program
*** Pelican driver source calls for 2 sectors/cluster, Norton Utils reports 4.
ÚÄÄÄÄÄÂÄÄÂÄÄÄÄÄÄÄÂÄÁÄÂÄÄÄÁÄÄÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÄÁÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³ 400k³5¬³DOS2.11³ 1 ³10 (80)³   ³   ³   ³   ³ 800³DEC Rainbow  SS/HD   (disc.)
³ 720k³5¬³DOS2.11³ 2 ³variable number of sectors  ³Victor 9000 PC   (discont'd)
ÀÄÄÄÄÄÁÄÄÁÄÄÄÄÄÄÄÁÄÄÄ´per track, more sectors on  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ³outer tracks than inner     ³
                     ³tracks. Special DSDD drive. ³
                     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 Some oddball DOS versions specify "zero" heads in their data area. HP's
single-sided disk format (16 256-byte sectors/track, model unknown) uses a
zero-based parameter for the number of heads. Without special device driver
software to "fix" this, these disks are basically unusable by normal DOS.

 A couple of people have reported that the IBM "Gearbox" industrial PC uses
an 800k 3.5 inch floppy with 10 sectors and 80 tracks. I've been unable to
confirm this.

 Files in the data area are not necessarily written sequentially. The data area
space is allocated one cluster at a time, skipping over clusters already
allocated. The first free cluster found is the next cluster allocated,
regardless of its physical location on the disk. This permits the most efficient
utilization of disk space because clusters freed by erasing files can be
allocated for new files. Refer back to the description of the DOS FAT in this
chapter for more information.

        SSDD    single sided, double density     (160-180k)     5¬
        DSDD    double sided, double density     (320-360k)     5¬
        DSQD    double sided, quad density       (720k)         5¬, 3«, 2
        DSHD    double sided, high density       (1.2-1.44M)    5¬, 3«
        DSED    double sided, extra high density (2.88M)        3«

 Much of the trouble with AT 1.2 meg drives has been through the inadverdent
use of quad density disks in the high density drives. The high density disks
use a higher-coercivity media than the quads, and quads are not completely
reliable as 1.2Mb. Make sure you have the correct disk for your application.


ROTATION SPEEDS:

        720k,   3«"    (unknown)  note: Zenith has discontinued 2" floppies

        720k,   3«"    300 RPM
        1.44Mb, 3«"    300 RPM

        360k,   5¬"    300 RPM
        720k,   5¬"    300 RPM
        1.2mb,  5¬"    360 RPM   (even when reading 360k diskettes)

        all      8"    360 RPM

 The Victor 9000's 5¬" floppies could vary their rotational speed as required. 
This allowed them to put 720k on a standard 360k floppy, using a constant 
density throughout.

 The Central Point CopyIIPC Option Board emulates the Macintosh GCR recording 
format by varying the data rate instead of the rotational speed.

 


HARD DISK LAYOUT ...................................................... 8**11

 The DOS hard disk routines perform the following services:

1) Allow multiple operating systems to be installed on the hard disk at the
   same time.

2) Allow a user-selected operating system to be started from the hard disk.

   I) In order to share the hard disk among operating systems, the disk may be
      logically divided into 1 to 4 partitions. The space within a given
      partition is contiguous, and can be dedicated to a specific operating
      system. Each operating system may "own" only one partition in DOS versions
      2.0 through 3.2. DOS 3.3 introduced the "Extended DOS Partition" which
      allows multiple DOS partitions on the same hard disk. FDISK (or a
      similar program from other DOS vendors) utility allows the user to select
      the number, type, and size of each partition. The partition information is
      kept in a partition table that is embedded in the master hard disk boot
      record on the first sector of the disk. The format of this table varies
      from version to version of DOS.

  II) An operating system must consider its partition to be the entire disk,
      and must ensure that its functions and utilities do not access other
      partitions on the disk.

 III) Each partition may contain a boot record on its first sector, and any
      other programs or data that you choose, including a different operating
      system. For example, the DOS FORMAT command may be used to format and
      place a copy of DOS in the DOS partition in the same manner that a
      diskette is formatted. You can use FDISK to designate a partition as
      "active" (bootable). The master hard disk boot record causes that
      partition's boot record to receive control when the system is
      initialized. Additional disk partitions could be FORTH, UNIX, Pick,
      CP/M-86, OS/2 HPFS, Concurrent DOS, Xenix, or the UCSD p-System.



SYSTEM INITIALIZATION ................................................. 8**12

The boot sequence is as follows:

1. System initialization first attempts to load an operating system from
   diskette drive A. If the drive is not ready or a read error occurs, it then
   attempts to read a master hard disk boot record on the first sector of the
   first hard disk in the system. If unsuccessful, or if no hard disk is
   present, it invokes ROM BASIC in an IBM PC or displays a disk error
   message on most compatibles.

2. If initialization is successful, the master hard disk boot record is given
   control and it examines the partition table embedded within it. If one of
   the entries indicates an active (bootable) partition, its boot record is
   read from the partition's first sector and given control.

3. If none of the partitions is bootable, ROM BASIC is invoked on an IBM PC or
    a disk error on most compatibles.

4. If any of the boot indicators are invalid, or if more than one indicator is
   marked as bootable, the message "INVALID PARTITION TABLE "is displayed and
   the system stops.

5. If the partition's boot record cannot be successfully read within five
   retries due to read errors, the message "ERROR LOADING OPERATING SYSTEM"
   appears and the system stops.

6. If the partition's boot record does not contain a valid "signature", the
   message "MISSING OPERATING SYSTEM" appears, and the system stops.

NOTE: When changing the size or location of any partition, you must ensure that
      all existing data on the disk has been backed up. The partitioning program
      will destroy the data on the disk.

 System programmers designing a utility to initialize/manage a hard disk must
provide the following functions at a minimum:

1. Write the master disk boot record/partition table to the disk's first
   sector to initialize it.

2. Perform partitioning of the disk - that is, create or update the partition
   table information (all fields for the partition) when the user wishes
   to create a partition. This may be limited to creating a partition for only
   one type of operating system, but must allow repartitoning the entire disk,
   or adding a partition without interfering with existing partitions (user's
   choice).

3. Provide a means for marking a user-specified partition as bootable and
   resetting the bootable indicator bytes for all other partitions at the same
   time.

4. Such utilities should not change or move any partition information that
   belongs to another operating system.




BOOT RECORD/PARTITION TABLE ........................................... 8**13

 A boot record must be written on the first sector of all hard disks, and
must contain the following:

1. Code to load and give control to the boot record for one of four possible
   operating systems.

2. A partition table at the end of the boot record. Each table entry is 16
   bytes long, and contains the starting and ending cylinder, sector, and head
   for each of four possible partitions, as well as the number of sectors
   preceding the partition and the number of sectors occupied by the partition.
   The "boot indicator" byte is used by the boot record to determine if one of
   the partitions contains a loadable operating system. FDISK initialization
   utilities mark a user-selected partition as "bootable" by placing a value
   of 80h in the corresponding partition's boot indicator (setting all other
   partitions' indicators to 0 at the same time). The presence of the 80h tells
   the standard boot routine to load the sector whose location is contained in
   the following three bytes. That sector is the actual boot record for the
   selected operating system, and it is responsible for the remainder of the
   system's loading process (as it is from the diskette). All boot records are
   loaded at absolute address 0:7C00.

The partition table with its offsets into the boot record is:
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³  Offset  ³  Offset  ³  Offset  ³        ³
³from Start³from Start³from Start³  Size  ³ Description
³ of Disk  ³ of Entry ³ of Disk  ³        ³                                   
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³          ³    00h   ³   0BEh   ³ 1 byte ³ boot indicator
³          ³    01h   ³   0BFh   ³ 1 byte ³ beginning head
³   1BEh   ³    02h   ³   0C0h   ³ 1 byte ³ beginning sector
³ (part 1) ³    03h   ³   0C1h   ³ 1 byte ³ beginning cylinder
³ 16 bytes ³    04h   ³   0C2h   ³ 1 byte ³ system indicator
³          ³    05h   ³   0C3h   ³ 1 byte ³ ending head
³          ³    06h   ³   0C4h   ³ 1 byte ³ ending sector
³          ³    07h   ³   0C5h   ³ 1 byte ³ ending cylinder
³          ³    08h   ³   0C6h   ³ 4 bytes³ relative (starting) sector       
³          ³    0Ch   ³   0DAh   ³ 4 bytes³ number of sectors       
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³          ³    00h   ³   0DEh   ³ 1 byte ³ boot indicator
³          ³    01h   ³   0DFh   ³ 1 byte ³ beginning head
³   1CEh   ³    02h   ³   0E0h   ³ 1 byte ³ beginning sector
³ (part 2) ³    03h   ³   0E1h   ³ 1 byte ³ beginning cylinder
³ 16 bytes ³    04h   ³   0E2h   ³ 1 byte ³ system indicator
³          ³    05h   ³   0E3h   ³ 1 byte ³ ending head
³          ³    06h   ³   0E4h   ³ 1 byte ³ ending sector
³          ³    07h   ³   0E5h   ³ 1 byte ³ ending cylinder
³          ³    08h   ³   0E6h   ³ 4 bytes³ relative (starting) sector       
³          ³    0Ch   ³   0EAh   ³ 4 bytes³ number of sectors       
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³          ³    00h   ³   0FEh   ³ 1 byte ³ boot indicator
³          ³    01h   ³   0FFh   ³ 1 byte ³ beginning head
³   1DEh   ³    02h   ³   0100h  ³ 1 byte ³ beginning sector
³ (part 3) ³    03h   ³   0101h  ³ 1 byte ³ beginning cylinder
³ 16 bytes ³    04h   ³   0102h  ³ 1 byte ³ system indicator
³          ³    05h   ³   0103h  ³ 1 byte ³ ending head
³          ³    06h   ³   0104h  ³ 1 byte ³ ending sector
³          ³    07h   ³   0105h  ³ 1 byte ³ ending cylinder
³          ³    08h   ³   0106h  ³ 4 bytes³ relative (starting) sector       
³          ³    0Ch   ³   010Ah  ³ 4 bytes³ number of sectors       
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³          ³    00h   ³   010Eh  ³ 1 byte ³ boot indicator
³          ³    01h   ³   011Fh  ³ 1 byte ³ beginning head
³   1EEh   ³    02h   ³   0110h  ³ 1 byte ³ beginning sector
³ (part 4) ³    03h   ³   0111h  ³ 1 byte ³ beginning cylinder
³ 16 bytes ³    04h   ³   0112h  ³ 1 byte ³ system indicator
³          ³    05h   ³   0113h  ³ 1 byte ³ ending head
³          ³    06h   ³   0114h  ³ 1 byte ³ ending sector
³          ³    07h   ³   0115h  ³ 1 byte ³ ending cylinder
³          ³    08h   ³   0116h  ³ 4 bytes³ relative (starting) sector       
³          ³    0Ch   ³   011Ah  ³ 4 bytes³ number of sectors       
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
³   1FEh   ³                     ³ 2 bytes³ 055AAh signature
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 Boot indicator (boot ind): The boot indicator byte must contain 0 for a non-
bootable partition or 80h for a bootable partition. Only one partition can be
marked as bootable at a time.

 System Indicator (sys ind): The sys ind field contains an indicator of the
operating system that "owns" the partition. IBM PC-DOS can only "own" one
partition, though some versions of MSDOS allow all four partitions to be used
by DOS.

 The system indicators are:

        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        ³                 System Indicator  (sys ind)                 ³
        ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  00h  ³  unknown or no partition defined                    ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  01h  ³  DOS 12 bit FAT  (DOS 2.x all and 3.x+ under 16 Mb) ³
        ³       ³                  less than 4086 clusters            ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  02h  ³  Xenix                                              ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  03h  ³  Xenix                                              ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  04h  ³  DOS 16 bit FAT  (DOS 3.0+. Not recognized by 2.x)  ³
        ³       ³                  less than 65,536 sectors           ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  05h  ³  extended DOS partition, some 3.2 and all 3.3+      ³
        ³       ³  (pointer to further partition table)               ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  06h  ³  Compaq DOS 3.31, DOS 4.0+ partitions over 32 megs  ³
        ³       ³  Digital Research DRDOS 3.4, 3.41 over 32 megs      ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  06h  ³  PC-MOS/386 partitions over 32 megs (NOT compatible ³
        ³       ³  with the DR, Compaq, and MSDOS big partitions!     ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  07h  ³  OS/2 High Performance File System                  ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  051h ³  Ontrack Disk Manager "read/write" partitions       ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  0DBh ³  DRI Concurrent DOS              (>32mb partitions?)³
        ³       ³  DRI Concurrent CP/M?                               ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  0E4h ³  Speedstor, small partitions (?) (under 1024cyl?)   ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  0F2h ³  2nd DOS partition, some OEM customized DOS 3.2     ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  0F4h ³  Speedstor, large partitions (?)                    ³
        ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
        ³  0FEh ³  Speedstor, partitions >1024 cylinders              ³
        ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 There are ID bytes for proprietary formatting schemes. Some manufacturers
(such as Zenith, Wyse, and Tandon) diddle with these system bytes to implement
more than one DOS partition per disk.

note 1) Xenix doesn't like extended DOS partitions a'la DOS 3.3, limiting you
        to a DOS partition of 32Mb. Xenix doesn't recognize DOS 4.0x at all,
        so to use it you need to boot from a floppy. Early versions of OS/2
        also have this problem.
    2)  I have found one source listing Minix partitions as "40" and some
        Unix partitions as "63".  I don't know if these are decimal or
        hexadecimal figures.

 Cylinder (CYL) and Sector (S): The 1 byte fields labelled CYL contain the low
order 8 bits of the cylinder number - the high order 2 bits are in the high
order 2 bits of the sector (S) field. This corresponds with the ROM BIOS
interrupt 13h (disk I/O) requirements, to allow for a 10 bit cylinder number.

 The fields are ordered in such a manner that only two MOV instructions are
required to properly set up the DX and CX registers for a ROM BIOS call to
load the appropriate boot record (hard disk booting is only possible from the
first hard disk in the system, where a BIOS drive number of 80h corresponds
to the boot indicator byte).

 All partitions are allocated in cylinder multiples and begin on sector 1,
head 0, with the exception that the partition that is allocated at the beginning
of the disk starts at sector 2, to account for the hard disk's master boot
record.

 Relative (starting) Sector: The number of sectors preceding each partition
on the disk is kept in this 4 byte field. This value is determined by counting
the sectors beginning with cylinder 0, sector 1, head 0 of the disk, and
incrementing the sector, head, and then track values up to the beginning of
the partition. This, if the disk has 17 sectors per track and 4 heads, and the
second partition begins at cylinder 1, sector 1, head 0, then the partition's
starting relative sector is 68 (decimal) - there were 17 sectors on each of 4
heads on 1 track allocated ahead of it. The field is stored with the least
significant word first.

 Number of sectors (#sects): The number of sectors allocated to the partition
is kept in the "# of sects" field. This is a 4 byte field stored least
significant word first.

 Signature: The last 2 bytes of the boot record (55AAh) are used as a signature
to identify a valid boot record. Both this record and the partition boot record
are required to contain the signature at offset 1FEh.



HARD DISK TECHNICAL INFORMATION ....................................... 8**14

 Western Digital's hard disk installation manuals make the claim that MSDOS
can support only 2 hard drives. This is entirely false, and their purpose for
making the claim is unclear. DOS merely performs a function call pointed at
the hard disk driver, which is normally in one of three locations; a ROM at
absolute address C:800, the main BIOS ROM if the machine is an AT, or a device
driver installed through the CONFIG.SYS file. Two hard disk controller cards
can normally not reside in the same machine due to lack of interrupt
arbitration. Perstor's ARLL controller and some cards marketed by Novell can
coexist with other controllers. Perstor's technical department has had four
controllers and eight hard disks in the same IBM XT functioning concurrently.

 A valid hard disk has a boot record arranged in the following manner:

        db      drive           ; 0 or 80h  (80h marks a bootable, active
                                             partition)
        db      head1           ; starting head
        dw      trksec1         ; starting track/sector (CX value for INT 13)
        db      system          ; SYS IND ID from table above
        db      head2           ; ending head
        dw      trksec2         ; ending track/sector
        dd      sector1         ; absolute # of starting sector
        dd      sector2         ; absolute # of last sector

 The master disk boot record invokes ROM BASIC if no indicator byte reflects a
bootable system.

 When a partition's boot record is given control, it is passed its partition
table entry address in the DS:SI registers.



DETERMINING HARD DISK ALLOCATION ...................................... 8**15

DOS determines disk allocation using the following formula:

                                         D * BPD
                            TS - RS -  ÄÄÄÄÄÄÄÄÄÄÄ
                                           BPS
                      SPF = ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                        BPS * SPC
                                 CF + ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                           BPC
where:

     TS      Total number of sectors on the disk
     RS      The number of sectors at the beginning of the disk that are
             reserved for the boot record. DOS normally reserves 1 sector.
     D       The number of directory entries in the root directory.
     BPD     The number of bytes per directory entry. This is always 32.
     BPS     The number of bytes per logical sector. Typically 512, but you can
             specify a different number with VDISK.
     CF      The number of FATS per disk. Usually 2. VDISK is 1.
     SPF     The number of sectors per FAT. Maximum 64.
     SPC     The number of sectors per allocation unit (cluster).
     BPC     The number of bytes per FAT entry. BPC is 1.5 for 12 bit FATs.
             2 for 16 bit FATS.


To calculate the minimum partition size that will force a 16-bit FAT:

        CYL = (max clusters * 8)/(HEADS * SPT)

where:
     CYL           number of cylinders on the disk
     max clusters  4092 (maximum number of clusters for a 12 bit FAT)
     HEADS         number of heads on the hard disk
     SPT           sectors per track  (normally 17 on MFM)


 DOS 2.0 through 3.3 limit partition sizes to 32 megabytes. The limit arises
from the fact that DOS does things by sector number, and each sector is stored
as a word. So the largest sector number DOS can count to is 64k. As each
sector is 512 bytes long, 64k * .5k = 32Mb. The easiest way for an aftermarket
disk handler to break the 32Mb barrier is probably to increase the sector size
- with 2k sectors, maximum partiton size increases to 128Mb. However, the BIOS
boot routines and IBMBIO.COM are hardwired for 512 byte sectors, so you won't
be able to boot from a drive with oversize sectors. That's why Disk Manager
formats a small boot partition by default.

 DOS 2.x uses a "first fit" algorithm when allocating file space on the hard
disk. Each time an application requests disk space, it will scan from the
beginning of the FAT until it finds a contiguous peice of storage large enough
for the file.

 DOS 3.x+ keeps a pointer into the disk space, and begins its search from the
point it last left off. This pointer is lost when the system is rebooted.
This is called the "next fit" algorithm. It is faster than the first fit and
helps minimize fragmentation.

 In either case, if the FCB function calls are used instead of the handle
function calls, the file will be broken into pieces starting with the first
available space on the disk.




BIOS Disk Routines .................................................... 8**16

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 13h  Disk I/O - access the disk drives (floppy and hard disk)      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:004Ch)    1) These calls do not try rereading disk if an error is returned.
             2) In the IBM OS/2 Tech Ref Volume 1, page 7-33, under "DOS
                Environment Software Interrupt Support", it lists:
                13h  disk/diskette     for non-removable media only, these
                                       functions are supported:
                                       01h     read status
                                       02h     read sectors
                                       0Ah     read long
                                       15h     read DASD (disk) type
             3) On hard disk systems these calls may be vectored through the
                int 40h hard disk BIOS.


Function 00h    Reset - reset the disk controller chip
entry   AH      00h
        DL      drive (if bit 7 is set both hard disks and floppy disks reset)
                00h-7Fh  floppy disk
                80h-0FFh hard disk
return  AH      status (see 01h below)
note 1) Forces controller chip to recalibrate read/write heads.
     2) Some systems (Sanyo 55x, Columbia MPC) this resets all drives.
     3) This function should be called after a failed floppy disk Read, Write,
        Verify, or Format request before retrying the operation.
     4) If called with DL >= 80h (i.e., selecting a hard drive), the floppy
        controller and then the hard disk controller are reset.
     5) Function 0Dh allows the hard disk controller to be reset without
        affecting the floppy controller.


Function 01h    Get Status of Disk System
entry   AH      01h
        DL      drive (hard disk if bit 7 set)
                00h-7Fh  floppy disk
                80h-0FFh hard disk
return  AH      00h
        AL      status of most recent disk operation
                00h     successful completion, no errors
                01h     bad command
                02h     address mark not found
                03h     tried to write on write-protected disk    (floppy only)
                04h     sector not found
                05h     reset failed                                (hard disk)
                06h     diskette removed or changed               (floppy only)
                07h     bad parameter table                         (hard disk)
                08h     DMA overrun                               (floppy only)
                09h     attempt to DMA across 64K boundary
                0Ah     bad sector detected                         (hard disk)
                0Bh     bad track detected                          (hard disk)
                0Ch     unsupported track or media type not found (floppy disk)
                0Dh     invalid number of sectors on format         (hard disk)
                0Eh     control data address mark detected          (hard disk)
                0Fh     DMA arbitration level out of range          (hard disk)
                10h     uncorrectable CRC/EEC on read
                11h     ECC corrected data error                    (hard disk)
                20h     controller failure
                40h     seek failed
                80h     timeout
                0AAh    drive not ready                             (hard disk)
                0BBh    undefined error                             (hard disk)
                0CCh    write fault                                 (hard disk)
                0E0h    status error                                (hard disk)
                0FFh    sense operation failed                      (hard disk)
note 1) For hard disks, error code 11h (ECC data error) indicates that a
        recoverable error was detected during a preceding int 13h fn 02h
        (Read Sector) call.


Function 02h    Read Sectors - read one or more sectors from diskette
entry   AH      02h
        AL      number of sectors to read
        BX      address of buffer (ES=segment)
        CH      track (cylinder) number (0-39 or 0-79 for floppies)
                (for hard disk, bits 8,9 in high bits of CL)
        CL      sector number (1 to 18, not value checked)
        DH      head number (0 or 1)
        DL      drive (0=A, 1=B, etc.) (bit 7=0)  (drive 0-7)
                00h-7Fh   floppy disk
                80h-FF0h  hard disk
        ES:BX   address to store/fetch data  (buffer to fill)
       [0000:0078]  dword pointer to diskette parameters
return  CF      clear   successful
                        AL      number of sectors transferred
                set     error
                        AH      status  (00h, 02h, 03h, 04h, 08h, 09h, 10h,
                                         0Ah, 20h, 40h, 80h)
note 1) Number of sectors begins with 1, not 0.
     2) Trying to read zero sectors is considered a programming error; results
        are not defined.
     3) For hard disks, the upper 2 bits of the 10-bit cylinder number are
        placed in the upper 2 bits of register CL.
     4) For hard disks, error code 11h indicates that a read error occurred
        that was corrected by the ECC algorithm; in this case, AL contains the
        burst length. The data read is good within the limits of the ECC code.
        If a multisector transfer was requested, the operation was terminated
        after the sector containing the read error.
     5) For floppy drives, an error may result from the drive motor being off
        at the time of the request. The BIOS does not automatically wait for
        the drive to come up to speed before attempting the read operation. The
        calling program should reset the floppy disk system with function 00h
        and retry the operation three times before assuming that the error
        results from some other cause.


Function 03h    Write Sectors - write from memory to disk
entry   AH      03h
        AL      number of sectors to write (1-8)
        CH      track number (for hard disk, bits 8,9 in high bits of CL)
        CL      beginning sector number
                (if hard disk, high two bits are high bits of track #)
        DH      head number  (head 0=0)
        DL      drive number (0-7)
                00h-7Fh   floppy disk
                80h-FF0h  hard disk
        ES:BX   address of buffer for data
return  CF      clear   success
                        AL      number of sectors written
                set     error
                        AH      status (see 01h above)
note 1) Number of sectors begins with 1, not 0.
     2) Trying to write zero sectors is considered a programming error; results
        are not defined.
     3) For hard disks, the upper 2 bits of the 10-bit cylinder number are
        placed in the upper 2 bits of register CL.
     4) For floppy drives, an error may result from the drive motor being off
        at the time of the request. The BIOS does not automatically wait for
        the drive to come up to speed before attempting the read operation. The
        calling program should reset the floppy disk system with function 00h
        and retry the operation three times before assuming that the error
        results from some other cause.


Function 04h    Verify - verify that a write operation was successful
entry   AH      04h
        AL      number of sectors to verify (1-8)
        CH      track number  (for hard disk, bits 8,9 in high bits of CL)
        CL      beginning sector number
        DH      head number
        DL      drive number (0-7)
        DL      drive number (0-7)
                00h-7Fh   floppy disk
                80h-FF0h  hard disk
        ES:BX   address of buffer for data
return  CF      set on error
                AH      status (see 01h above)
        AL      number of sectors verified
note 1) With IBM PC, XT, and AT with ROM BIOS earlier than 11/15/85, ES:BX
        should point to a valid buffer.
     2) For hard disks, the upper 2 bits of the 10-bit cylinder number are
        placed in the upper 2 bits of register CL.
     3) This function can be used to test whether a readable media is in a
        floppy drive. An error may result from the drive motor being off at the
        time of the request since the BIOS does not automatically wait for the
        drive to come up to speed before attempting the verify operation. The
        requesting program should reset the floppy disk system with function
        00h and retry the operation three times before assuming that a readable
        disk is not present.


Function 05h    Format Track - write sector ID bytes for 1 track (floppy disk)
entry   AH      05h
        AL      number of sectors to create on this track
                interleave (for XT hard disk only)
        CH      track (or cylinder) number (bits 8,9 in high bits of CL)
        CL      sector number
        DH      head number (0, 1)
        DL      drive number (0-3)
                00h-7Fh   floppy disk
                80h-0FFh  hard disk
        ES:BX   pointer to 4-byte address field (C-H-R-N) (except XT hard disk)
                byte 1 = (C) cylinder or track
                byte 2 = (H) head
                byte 3 = (R) sector
                byte 4 = (N) bytes/sector (0 = 128, 1 = 256, 2 = 512, 3 = 1024)
return  CF      set if error occurred
                AH      status code (see 01h above)
note 1) Not valid for ESDI hard disks on PS/2.
     2) For floppy disks, the number of sectors per track is taken from the
        BIOS floppy disk parameter table whose address is stored in the vector
        for int 1Eh.
     3) When this function is used for floppies on ATs or the PS/2, it should
        be preceded by a call to int 13h/fn 17h to select the type of media to
        format.
     4) For hard disks, the upper 2 bits of the 10-bit cylinder number are
        placed in the upper 2 bits of CL.
     5) On the XT/286, AT, and PS/2 hard disks, ES:BX points to a 512-byte
        buffer containing byte pairs for each physical disk sector as follows:
        Byte  Contents
        0       00h     good sector
                80h     bad sector
        1       sector number
        For example, to format a track with 17 sectors and an interleave of
        two, ES:BX would point to the following 34-byte array at the beginning
        of a 512-byte buffer:
        db      00h, 01h, 00h, 0Ah, 00h, 02h, 00h, 0Bh, 00h, 03h, 00h, 0Ch
        db      00h, 04h, 00h, 0Dh, 00h, 05h, 00h, 0Eh, 00h, 06h, 00h, 0Fh
        db      00h, 07h, 00h, 10h, 00h, 08h, 00h, 11h, 00h, 09h


Function 06h    Hard Disk - format track and set bad sector flags
                                                     (PC2, PC-XT, and Portable)
entry   AH      06h
        AL      interleave value (XT only)
        CH      cylinder number (bits 8,9 in high bits of CL)
        CL      sector number
        DH      head
        DL      drive (80h-0FFh for hard disk)
        ES:BX   512 byte format buffer
                the first 2*(sectors/track) bytes contain f,n for each sector
                f       00h     good sector
                        80h     bad sector
                n       sector number
return  CF      error
                AH      status code (see 01h above)


Function 07h    Hard Disk - format the drive starting at the desired track
                                                      (PC2, PC-XT and Portable)
entry   AH      07h
        AL      interleave value (XT only) (01h-10h)
        CH      cylinder number (bits 8,9 in high bits of CL) (00h-03FFh)
        CL      sector number
        DH      head number (0-7)
        DL      drive number (80h-0FFh, 80h=C, 81h=D,...)
        ES:BX   format buffer, size = 512 bytes
                the first 2*(sectors/track) bytes contain f,n for each sector
                f       00h     good sector
                        80h     bad sector
                n       sector number
return  CF      set on error
        AH      status code (see 01h above)
note    Award AT BIOS routines are extended to handle more than 1024 cylinders.
        AL      number of sectors
        CH      cylinder numberm low 8 bits
        CL      sector number bits 0-5, bits 6-7 are high 2 cylinder bits
        DH      head number (bits 0-5) bits 6-7 are extended high cyls (>1024)
        DL      drive number (0-1 for diskette, 80h-81h for hard disk)
        ES:BX   transfer address


Function 08h    Read Drive Parameters                          (except PC, Jr)
entry   AH      08h
        DL      drive number
                00h-7Fh   floppy disk
                80h-0FFh  hard disk
return  CF      set on error
                AH      status code (see above)
        BL      drive type  (AT/PS2 floppies only)
                01h     if 360 Kb, 40 track, 5¬"
                02h     if 1.2 Mb, 80 track, 5¬"
                03h     if 720 Kb, 80 track, 3«"
                04h     if 1.44 Mb, 80 track, 3«"
        CH      low 8 bits of maximum useable value for cylinder number
        CL bits 6-7     high-order 2 bits of maximum cylinder number
                0-5     maximum sector number
        DH      maximum usable value for head number
        DL      number of consecutive acknowledging drives (0-2)
        ES:DI   pointer to drive parameter table
note 1) On the PC and PC/XT, this function is supported on hard disks only.
     2) The Columbia MPC supports functions 6-14 for its hard disk. It returns
        drive information, same as int 13 function 8, except that the BL and
        ES:DI values are omitted and AL <- burst length.


Function 09h    Initialize Two Fixed Disk Base Tables    (XT, AT, XT/286, PS/2)
                (install nonstandard drive)
entry   AH      09h
        DL      80h-0FFh  hard disk number
return  CF      set on error
                AH      status code (see 01h above)
                For PC, XT hard disks, the disk parameter block format is:
                00h-01h maximum number of cylinders
                02h     maximum number of heads
                03h-04h starting reduced write current cylinder
                05h-06h starting write precompensation cylinder
                07h     maximum ECC burst length
                08h     drive options
                   bits 7       1       disable disk access retries
                        6       1       disable ECC retries
                        3-5     set to 0
                        0-2     drive option
                09h     standard timeout value
                0Ah     timeout value for format drive
                0Bh     timeout value for check drive
                0Ch-0Fh reserved

                For AT and PS/2 hard disks:
                00h-01h maximum number of cylinders
                02h     maximum number of heads
                03h-04h reserved
                05h-06h starting write precompensation cylinder
                07h     maximum ECC burst length
                08h     drive options byte
                   bits 6-7     nonzero (10, 01, or 11) if retries disabled
                        5       1       if manufacturer's defect map present at
                                        maximum cylinder + 1
                        4       not used
                        3       1       if more than 8 heads
                        0-2     not used
                09h-0Bh reserved
                0Ch-0Dh landing zone cylinder
                0Eh     sectors per track
                0Fh     reserved
note 1) For the XT, int 41h must point to the Disk Parameter Block.
     2) For the AT and PS/2, int 41h points to table for drive 0 and int 46h
        points to table for drive 1.
     3) Initializes the hard disk controller for subsequent I/O operations
        using the values found in the BIOS disk parameter block(s).
     4) This function is supported on hard disks only.


Function 0Ah    Read Long   (Hard disk)                 (XT, AT, XT/286, PS/2)
entry   AH      0Ah
        CH      cylinder number (bits 8,9 in high bits of CL)
        CL      sector number (upper 2 bits of cyl # in upper 2 bits of CL)
        DH      head number
        DL      drive ID  (80h-0FFh hard disk)
        ES:BX   pointer to buffer to fill
return  CF      set on error
                AH      status code (see 01h above)
        AL      number of sectors actually transferred
note 1) A "long" sector includes a 4 byte EEC (Extended Error Correction) code.
     2) Used for diagnostics only on PS/2 systems.
     3) This function is supported on fixed disks only.
     4) Unlike the normal Read Sector (02h) function, ECC errors are not
        automatically corrected. Multisector transfers are terminated after any
        sector with a read error.


Function 0Bh    Write Long                              (XT, AT, XT/286, PS/2)
entry   AH      0Bh
        AL      number of sectors
        CH      cylinder (bits 8,9 in high bits of CL)
        CL      sector number
        DH      head number
        DL      drive ID  (80h-0FFh hard disk)
        ES:BX   pointer to buffer containing data
return  CF      set on error
                AH      status code (see 01h above)
        AL      number of sectors actually transferred
note 1) A "long" sector includes a 4 byte EEC (Extended Error Correction) code.
     2) Used for diagnostics only on PS/2 systems.
     3) Valid for hard disks only.


Function 0Ch    Seek To Cylinder                        (except PC, PCjr)
entry   AH      0Ch
        CH      lower 8 bits of cylinder
        CL      upper 2 bits of cylinder in bits 6-7
        DH      head number
        DL      drive number (0 or 1)  (80h-0FFh for hard disk)
return  CF      set on error
                AH      status code (see 01h above)
note 1) Positions heads over a particular cylinder, but does not move any data.
     2) This function is supported on hard disks only.
     3) The upper 2 bits of the 10-bit cylinder number are placed in the upper
        2 bits of CL.
     4) The Read Sector, Read Sector Long, Write Sector, and Write Sector Long
        functions include an implied seek operation and need not be preceded by
        an explicit call to this function.


Function 0Dh    Alternate Hard Disk Reset                    (except PC, PCjr)
entry   AH      0Dh
        DL      hard drive number (80h-0FFh hard disk)
return  CF      set on error
                AH      status code (see 01h above)
note 1) Not for PS/2 ESDI hard disks.
     2) Resets the hard disk controller, recalibrates attached drives (moves
        the read/write arm to cylinder 0), and prepares for subsequent disk I/O.
     3) This function is for hard disks only. It differs from fn 00h by not
        resetting the floppy disk controller.


Function 0Eh    Read Sector Buffer                         (XT, Portable, PS/2)
entry   AH      0Eh
        ES:BX   pointer to buffer
return  CF      set on error
                AH      status code (see 01h above)
        AL      number of sectors actually transferred
note 1) Transfers controller's sector buffer. No data is read from the drive.
     2) Used for diagnostics only on PS/2 systems.
     3) This fn is supported by the XT's hard disk adapter only. It is "not
        defined" for hard disk adapters on the AT or PS/2.


Function 0Fh    Write sector buffer                          (XT, Portable)
entry   AH      0Fh
        ES:BX   pointer to buffer
return  CF      set if error
                AH      status code (see 01h above)
        AL      number of sectors actually transferred
note 1) Should be called before formatting to initialize the controller's
        sector buffer.
     2) Used for diagnostics only on PS/2 systems.
     3) Transfers data from system RAM to the hard disk adapter's internal
        sector buffer.
     4) No data is written to the physical disk drive.
     5) This fn is for the XT hard disk controller only. It is "not defined"
        for AT or PS/2 controllers.


Function 10h    Test For Drive Ready                  (XT, AT, XT/286, PS/2)
entry   AH      10h
        DL      hard drive number 0 or 1 (80h-0FFh)
return  CF      set on error
                AH      status code (see 01h above)
note 1) Tests whether the specified hard disk drive is operational and returns
        the drive's status.
     2) This function is supported on hard disks only.
     3) Perstor and Novell controllers allow more than one controller. Does
        not work for multiple Perstor controllers. (reports first two drives
        only).
     4) Does not work with network drives.


Function 11h    Recalibrate Drive                      (XT, AT, XT/286, PS/2)
entry   AH      11h
        DL      hard drive number (80h-0FFh hard disk)
return  CF      set on error
                AH      status code (see 01h above)
note 1) Causes the HD controller to recalibrate itself for the specified drive,
        positioning the read/arm to cylinder 0, and returns the drive's status.
     2) This function is for hard disks only.


Function 12h    Controller RAM Diagnostics                (XT, Portable, PS/2)
entry   AH      12h
return  CF      set on error
                AH      status code (see fn 01h above)
note 1) Used for diagnostics only on PS/2 systems.
     2) Makes the hard disk controller carry out a built-in diagnostic test on
        its internal sector buffer.


Function 13h    Controller Drive Diagnostic               (XT, Portable, PS/2)
entry   AH      13h
return  CF      set on error
                AH      status code (see 01h above)
note 1) Used for diagnostics only on PS/2 systems.
     2) Causes HD controller to run internal diagnostic tests of the attached
        drive, indicating whether the test was passed by the returned status.
     3) This function is supported on XT HDs only.


Function 14h    Controller Internal Diagnostic               (AT, XT/286)
entry   AH      14h
return  CF      set on error
        AH      status code (see 01h above)
note 1) OEM is Western Digital 1003-WA2 hard/floppy combination controller
        in AT and XT/286.
     2) Used for diagnostics only in PS/2 systems.
     3) Causes HD controller to do a built-in diagnostic self-test, indicating
        whether the test was passed by the returned status.
     4) This function is supported on hard disks only.


Function 15h    Get Disk Type                                (except PC and XT)
entry   AH      15h
        DL      drive ID
                00h-7Fh   floppy disk
                80h-0FFh  fixed disk
return  CF      set on error
                AH      error code (see 01h above)
        AH      disk type
                00h     no drive is present
                01h     diskette, no change detection present
                02h     diskette, change detection present
                03h     hard disk
                        CX:DX   number of 512-byte sectors
note 1) Returns a code indicating the type of disk referenced by the specified
        drive code.
     2) This function is not supported on the PC or XT.


Function 16h    Get Disk Change Status (diskette)      (except PC, XT, & Jr)
entry   AH      16h
        DL      drive to check
return  CF      set on error
        AH      disk change status
                00h     no disk change
                01h     disk changed
        DL      drive that had disk change (00h-07Fh floppy disk)
note    Returns the status of the change line, indicating whether the disk in
        the drive may have been replaced since the last disk access. If this
        function returns with CF set, the disk has not necessarily been
        changed; the change line can be activated by simply unlocking and
        relocking the disk drive door without removing the floppy disk.


Function 17h    Set Disk Type for Format (diskette)          (except PC and XT)
entry   AH      17h
        AL      00h     not used
                01h     160, 180, 320, or 360Kb diskette in 360kb drive
                02h     360Kb diskette in 1.2Mb drive
                03h     1.2Mb diskette in 1.2Mb drive
                04h     720Kb diskette in 720Kb drive
        DL      drive number (0-7)
return  CF      set on error
        AH      status of operation (see 01h above)
note 1) This function is probably enhanced for the PS/2 series to detect
        1.44 in 1.44 and 720k in 1.44.
     2) This function is not supported for floppy disks on the PC or XT.
     3) If the change line is active for the specified drive, it is reset.
     4) The BIOS sets the data rate for the specified drive and media type.
        The rate is 250k/sec for double-density media and 500k/sec for high
        density media. The proper hardware is required.


Function 18h    Set Media Type For Format  (diskette)   (AT, XT2, XT/286, PS/2)
entry   AH      18h
        CH      lower 8 bits of number of tracks
        CL      high 2 bits of number of tracks (6,7) sectors per track
                (bits 0-5)
        DL      drive number (0-7)
return  CF      clear   no errors
        AH      00h      if requested combination supported
                01h      if function not available
                0Ch      if not suppported or drive type unknown
                80h      if there is no media in the drive
        ES:DI   pointer to 11-byte disk parameter table for media type
        CF      set     error code (see 01h above)
note 1) A floppy disk must be present in the drive.
     2) This function should be called prior to formatting a disk with Int 13h
        Fn 05h so the BIOS can set the correct data rate for the media.
     3) If the change line is active for the specified drive, it is reset.


Function 19h    Park Hard Disk Heads                         (PS/2)
entry   AH      19h
        DL      drive number (80h-0FFh)
return  CF      set on error
                AH      error code (see fn 01h)
note    This function is defined for PS/2 fixed disks only.


Function 1Ah    ESDI Hard Disk - Low Level Format                      (PS/2)
entry   AH      1Ah
        AL      Relative Block Address (RBA) defect table count
                00h     no errors on disk
                01h+    number of disk errors
        CL      format modifiers byte
           bits 0       ignore primary defect map
                1       ignore secondary defect map
                2       update secondary defect map
                3       perform extended surface analysis
                4       generate periodic interrupt after each cylinder format
                5       reserved - must be 0
                6       reserved - must be 0
                7       reserved - must be 0
        DL      drive  (80h-0FFh)
        ES:BX   pointer to RBA defect table
return  CF      set on error
                AH      error code (see fn 01h above)
note 1) Initializes disk sector and track address fields on a drive attached
        to the IBM "ESDI Fixed Disk Drive Adapter/A."
     2) If periodic interrupt selected, int 15h/fn 0Fh is called after each
        cylinder is formatted
     3) If bit 4 of CL is set, Int 15h, AH=0Fh, AL=phase code after each
        cylinder is formatted or analyzed. The phase code is defined as:
        0       reserved
        1       surface analysis
        2       formatting
     4) If bit 2 of CL is set, the drive's secondary defect map is updated to
        reflect errors found during surface analysis. If both bit 2 and bit 1
        are set, the secondary defect map is replaced.
     5) For an extended surface analysis, the disk should first be formatted by
        calling this function with bit 3 cleared and then analyzed by calling
        this function with bit 3 set.


Function 1Bh    ESDI Hard Disk - Get Manufacturing Header       (PS/2)
entry   AH      1Bh
        AL      number of record
        DL      drive
        ES:BX   pointer to buffer for manufacturing header (defect list)
return  CF      set on error
        AH      status
note    Manufacturing header format (Defect Map Record format) can be found
        in the "IBM 70Mb, 115Mb Fixed Disk Drives Technical Reference."


Function 1Ch    ESDI Hard Disk - Get Configuration                  (PS/2)
entry   AH      1Ch
        AL      0Ah     Get Device Configuration
                        DL      drive
                        ES:BX   pointer to buffer for device configuration
                                (drive physical parameter)
                0Bh     Get Adapter Configuration
                        ES:BX   pointer to buffer for adapter configuration
                0Ch     Get POS Information
                        ES:BX   pointer to POS information
                0Dh     unknown
                0Eh     Translate RBA to ABA
                        CH      low 8 bits of cylinder number
                        CL      sector number, high two bits of cylinder number
                                in bits 6 and 7
                        DH      head number
                        DL      drive number
                        ES:BX   pointer to ABA number

return  CF      set on error
                AH      status (see 01h)
note 1) Device configuration format can be found in IBM ESDI Fixed Disk Drive
        Adapter/A Technical Reference.
     2) ABA (absolute block address) format can be found in IBM ESDI Adapter
        Technical Reference by using its Device Configuration Status Block.


Function 1Dh    IBMCACHE.SYS                                (PS/2 50+)
entry   AH      1Dh
other parameters unknown
note    IBMCACHE.SYS comes on the setup disk for MCA-bus PS/2 machines.


Function 20h    Western Digital HD SuperBIOS
entry   AH      20h
other parameters unknown
note    SuperBIOS may be purchased separately from Western Digital and added
        to standard HD controllers. SuperBIOS contains additional setup
        tables and parameters.


       **  Programmer's Technical Reference for MSDOS and the IBM PC **
                USA copyright TXG 392-616  ALL RIGHTS RESERVED
     ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ISBN 1-878830-02-3 (disk-based text)
                    Copyright (c) 1987, 1994 Dave Williams
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³ Shareware Version, 01/20/94 ³
                        ³  Please Register Your Copy  ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                            C H A P T E R   N I N E


                          INSTALLABLE DEVICE DRIVERS


                                C O N T E N T S

Device Driver Format .................................................... 9**
Types of Devices ........................................................ 9**
        Character Devices ............................................... 9**
        Block Devices ................................................... 9**
Device Header ........................................................... 9**
        Pointer to Next Device Header Field ............................. 9**
        Attribute Field ................................................. 9**
                Bits 0 and 1 ............................................ 9**
                Bit 2 ................................................... 9**
                Bit 3 ................................................... 9**
                Bit 13 .................................................. 9**
                Bit 14 .................................................. 9**
                Bit 15 .................................................. 9**
        Pointer to Strategy and Interrupt Routines ...................... 9**
        Name/Unit Field ................................................. 9**
Creating a Device Driver ................................................ 9**
Installing Device Drivers ............................................... 9**
        Installing Character Devices .................................... 9**
        Installing Block Devices ........................................ 9**
Request Header .......................................................... 9**
        Unit Code Field ................................................. 9**
        Command Code Field .............................................. 9**
        Status Field .................................................... 9**
Device Driver Functions ................................................. 9**
        INIT ............................................................ 9**
        MEDIA CHECK ..................................................... 9**
        Media Descriptor Byte ........................................... 9**
        BUILD BPB (BIOS Parameter Block) ................................ 9**
        INPUT OR OUTPUT ................................................. 9**
        NONDESTRUCTIVE INPUT NO WAIT .................................... 9**
        STATUS .......................................................... 9**
        FLUSH ........................................................... 9**
        OPEN or CLOSE (DOS 3.0+) ........................................ 9**
        REMOVEABLE MEDIA (DOS 3.0+) ..................................... 9**
The CLOCK$ Device ....................................................... 9**




DEVICE DRIVER FORMATÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 A device driver is a handler for communication between the system software
and hardware devices. The motherboard ROM and IBMBIO.COM or IO.SYS files
contain the basic drivers for allowing DOS to talk to the console, disk drives,
serial and parallel ports, clock, and other resources.

 DOS has five builtin drivers, STDIN, STDOUT, STERR, STDPRN, or STDAUX. An
"installable" driver may be loaded in the CONFIG.SYS file, and either replace
one of the builtin drivers or define a new resource, such as a mouse or
expanded memory driver.

 The device driver is a COM (memory image) file that contains all of the code
needed to control an add-in device. An EXE file should not be used since the
EXE loader in some DOS 2.x versions is part of COMMAND.COM, which is not
present when the device driver is being loaded by IBMBIO.COM or IO.SYS. EXE
format drivers could be used in DOS 3.x+, but there is generally no reason to
do so. The COM file must not load at the usual ORG 100h. Since the driver does
not use the Program Segment Prefix, it is simply loaded without offset,
therefore the driver file must have an origin of 0. Most references advise
"ORG 0 or no ORG statement", however with the advent of many new assemblers on
the market, some of which default to .COM files, specifically stating "ORG 0"
may eliminate problems. Driver files should not have a declared stack segment.

 DOS can install the device driver anywhere in memory, so care must be taken
in any FAR memory references. You should not expect that your driver will be
loaded in the same place every time.




TYPES OF DEVICESÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 There are two types of devices: Character devices and Block devices. Their
attributes are as follows:

 Character devices are designed to do serial I/O in a byte-by-byte manner.
These devices have names like CON, AUX, or PRN, and you can open channels
(handles or FCBs) to do I/O much like a disk file. I/O may be in either cooked
or raw mode. (see Chapter 7 for discussion of cooked and raw modes). Because
character devices have only one name, they can only support one device.

 Block devices are normally implemented as disk drives. They can do random I/O
in pieces called blocks, which are usually the physical sector size of the disk.
These devices are not named as character devices are, and cannot be opened
directly. Instead they are accessed by using drive letters such as A, B, C,
etc. Block devices can have units within them. In this way, a single block
driver can be responsible for one or more disk drives. For example, the first
block device driver can be responsible for drives A, B, C, and D. This means it
has four units defined and therefore takes up four drive letters. The position
of the driver in the chain of all drives determines the way in which the drive
letters correspond, i.e, if a second block device driver defines three units,
then those units are E, F, and G.

 DOS 1.x allows 16 block devices. DOS 2.x allows 63, and DOS 3.x allows 26. It
is recommended that drivers limit themselves to 26 devices for compatibility
with DOS 3.x and 4.x. When DOS 2.x passes the Z: drivespec, the drivespecs get
a little wierd, such as ^, [, or #. DOS 3.x+ will return an error message.




CREATING A DEVICE DRIVERÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 To create a device driver that DOS can install, you must do the following:

1) Create a memory image (COM) file with a device header at the start of the
   file.
2) Originate the code (including the device header) at 0, instead of 100h.
3) Set the next device header field. Refer to "Pointer to Next Device Header
   Attribute Field" for more information.
4) Set the attribute field of the device header. Refer to "Attribute Field" for
   more information.
5) Set the entry points for the interrupt and strategy routines.
6) Fill in the name/unit field with the name of the character device or the
   unit number of the block device.

 DOS always processes installable character device drivers before handling the
default devices. So to install a new CON device, simply name the device CON.
Be sure to set the standard input device and standard output device bits in
the attribute field of a new CON device. The scan of the device list stops on
the first match so the installable device driver takes precedence. For
instance, installing ANSI.SYS replaces the builtin CON driver.

 DOS doesn't care about the position of installed character devices versus
block devices.




STRUCTURE OF A DEVICE DRIVERÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 A device driver consists of three major parts:
        a device header
        a strategy routine
        an interrupt routine


DEVICE HEADER

 The driver has a special header to identify it as a device and to define the
strategy and interrupt entry points and its various attributes. This header is
located at the beginning of the file. It contains a pointer to the next driver
in the chain, the attributes of the device, offsets into the strategy and
interrupt routines, and the device ID.

 This is the format of the device header:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                         D E V I C E    H E A D E R                           ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Offset ³ Length ³                       Description                           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  00h  ³  word  ³  Pointer to next device header field, offset value          ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  02h  ³  word  ³  Pointer to next device header field, segment value         ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  04h  ³  word  ³  Attribute                                                  ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  06h  ³  word  ³  Pointer to device strategy routine (offset only)           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  08h  ³  word  ³  Pointer to device interrupt routine (offset only)          ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  0Ah  ³8 bytes ³  Name/Unit field                                            ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


POINTER TO NEXT DEVICE HEADER FIELD

 The device header field is a pointer to the device header of the next device
driver. It is a doubleword field that is set by DOS at the time the device
driver is loaded. The first word is the offset and the second word is the
segment.

 If you are loading only one device driver, set the device header field to -1
before loading the device. If you are loading more than one device driver, set
the first word of the device driver header to the offset of the next device
driver's header. Set the device driver header field of the last device driver
to -1.


ATTRIBUTE FIELD

 The attribute field is a word field used to identify the type of device this
driver is responsible for. This field distinguishes between block and
character devices and determines is selected devices are given special
treatment. The attributes are:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                        A T T R I B U T E   F I E L D                         ³
ÃÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   word   ³ attr. ³                                                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄ´                     description                           ³
³   bits   ³  set  ³                                                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³     0    ³   0   ³   not current standard input device                       ³
³          ³   1   ³   current standard input device                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³     1    ³   0   ³   not current standard output device                      ³
³          ³   1   ³   current standard output device                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³     2    ³   0   ³   not current NUL device                                  ³
³          ³   1   ³   current NUL device                                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³     3    ³   0   ³   not current CLOCK device                                ³
³          ³   1   ³   current CLOCK device                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³     4    ³   0   ³   standard CON I/O routines should be used                ³
³          ³   1   ³   fast screen I/O (int 29h) should be used                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  5 - 10  ³         "reserved for DOS" - unknown - should be set to 0         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    11    ³   0   ³   doesn't support removeable media  (default for DOS 2.x) ³
³          ³   1   ³   supports removeable media         (DOS 3.0+ only)       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    12    ³         "reserved for DOS" - unknown - should be set to 0         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    13    ³   0   ³   IBM format       (block devices)                        ³
³          ³   1   ³   non-IBM format   (block devices)                        ³
³          ³   1   ³   output till busy (character devices)                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    14    ³   0   ³   doesn't support IOCTL                                   ³
³          ³   1   ³   supports IOCTL                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³    15    ³   0   ³   block device                                            ³
³          ³   1   ³   character device                                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

note 1) If a bit in the attribute word is defined only for one type of device,
        a driver for the other type of device must set that bit to 0.
     2) For DOS 2.0 bits 4-12 must be off.


BIT 1   is the standard input and output bit. It is used for character devices
        only. Use this bit to tell DOS if your character device driver is the
        new standard input device or standard output device.

BIT 2   is the NUL attribute bit. It is used for character devices only. Use it
        to tell DOS if your character device driver is a NUL device. Although
        there is a NUL device attribute bit, you cannot reassign the NUL
        device or replace it with your own routine. This attribute exists for
        DOS so that DOS can tell if the NUL device is being used.

BIT 3   is the clock device bit. It is used for character devices only. Default
        is 0. You can use it to tell DOS if your character device driver is the
        new CLOCK device.

BIT 4   is the "fast video output" bit. The default is 0, which uses the BIOS
        for writing to the screen. When set, this bit uses int 29h for much
        faster screen updates.

BITS 5-10  reserved for DOS, unknown. Should be set to 0.

BIT 11  is the open/close removeable media bit. Use it to tell DOS if the
        device driver can handle removeable media. This bit is valid for DOS
        3.0+ only. This bit was reserved in DOS 2.x. Since DOS 2.x does not
        look at this bit, its use is backward compatible.

BIT 12  reserved for DOS, unknown. Should be set to 0.

BIT 13  is the non-IBM format bit. When used for block devices it affects the
        operation of the BUILD BPB (BIOS parameter block) device call. For
        character devices it indicates that the devices implements the OUTPUT
        UNTIL BUSY device call.

BIT 14  is the IOCTL bit. It is used for both character and block devices. Use
        it to tell DOS whether the device driver can handle control strings
        through the IOCTL function call 44h.
         If a device driver cannot process control strings, it should set bit
        14 to 0. This way DOS can return an error if an attempt is made through
        the IOCTL function call to send or receive control strings to the
        device. If a device can process control strings, it should set bit 14
        to 1. This way, DOS makes calls to the IOCTL input and output device
        function to send and receive IOCTL strings.
         The IOCTL functions allow data to be sent to and from the device
        without actually doing a normal read or write. In this way, the device
        driver can use the data for its own use, (for example, setting a baud
        rate or stop bits, changing form lengths, etc.) It is up to the device
        to interpret the information that is passed to it, but the information
        must not be treated as a normal I/O request.

BIT 15  is the device type bit. Use it to tell the system the that driver is a
        block or character device.


POINTER TO STRATEGY ROUTINE

 This field contains a pointer to "device strategy" function in the driver.
This function is called whenever a request is made to the driver, and must
store the location of the request header from DOS. This pointer is a word
value, and so must be in the same segment as the device header.


POINTER TO INTERRUPT ROUTINE

 This field contains a pointer to the function which activates driver routines
to perform the command in the current request header. This is called by DOS
after the call to the strategy function, and should reset to the request header
address stored by "strategy", to allow for the possibility of interrupts
between the two calls. This pointer is a word value, and so must be in the same
segment as the device header.


NAME/UNIT FIELD

 This is an 8-byte field that contains the name of a character device or the
number of units in a block device. For the character names, the name is
left-justified and the space is filled to 8 bytes. For block devices, the
number of units can be placed in the first byte. This is optional because DOS
fills in this location with the value returned by the driver's INIT code. The
other 7 bytes of the block device ID are reserved and should not be used.



INSTALLING DEVICE DRIVERSÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 DOS installs new device drivers dynamically at boot time by reading and
processing the DEVICE command in the CONFIG.SYS file. For example, if you have
written a device driver called RAMDISK, to install it put this command in the
CONFIG.SYS file:
                   DEVICE=[drive][path] RAMDISK [parameters]

 DOS makes a FAR call to the device driver at its strategy entry point first,
using the request header to pass information describing what DOS wants the
device driver to do.

 This strategy routine does not perform the request but rather queues the
request or saves a pointer to the request header. The second entry point is
the interrupt routine and is called by DOS immediately after the strategy
routine returns. The interrupt routine is called with no parameters. Its
function is to perform the operation based on the queued request and set up
any return infromation.

 DOS passes the pointer to the request header in ES:BX. This structure consists
of a fixed length header (Request Header) followed by data pertinent to the
operation to be performed.

NOTE: It is the responsibility of the device driver to preserve the machine
      state. For example, save all registers on entry and restore them on exit.

 The stack used by DOS has enough room on it to save all the registers. If more
stack space is needed, it is the device driver's responsibility to allocate and
maintain another stack.

 All calls to execute device drivers are FAR calls. FAR returns should be
executed to return to DOS.



INSTALLING CHARACTER DEVICES

  One of the functions defined for each device is INIT. This routine is called
only once when the device is installed and never again. The INIT routine returns
the following:

A) A location to the first free byte of memory after the device driver, like a
   TSR that is stored in the terminating address field. This way, the
   initialization code can be used once and then thrown away to save space.
B) After setting the address field, a character device driver can set the status
   word and return.



INSTALLING BLOCK DEVICES

 Block devices are installed in the same way as character devices. The
difference is that block devices return additional information. Block devices
must also return:

A) The number of units in the block device. This number determines the logical
   names the devices will have. For example, if the current logical device
   letter is F at the time of the install call, and the block device driver INIT
   routine returns three logical units, the letters G, H, and I are assigned to
   the units. The mapping is determined by the position of the driver in the
   device list and the number of units in the device. The number of units
   returned by INIT overrides the value in the name/unit field of the device
   header.

B) A pointer to a BPB (BIOS Parameter Block) pointer array. This is a pointer
   to an array of "N" word pointers there "N" is the number of units defined.
   These word pointers point to BPBs. This way, if all of the units are the
   same, the entire array can point to the same BPB to save space.
    The BPB contains information pertinent to the devices such as the sector
   size, number of sectors per allocation unit, and so forth. The sector size of
   the BPB cannot be greater than the maximum allotted size set at DOS
   initialization time. This array must be protected below the free pointer set
    by the return.

C) The media descriptor byte. This byte is passed to devices so that they know
   what parameters DOS is currently using for a particular drive unit.

 Block devices can take several approaches. They can be "dumb" or "smart". A
dumb device would define a unit (and therefore a BPB) for each possible media
drive combination. Unit 0=drive 0;single side, unit 1=drive 0;double side, etc.
For this approach, the media descriptor bytes would mean nothing. A smart
device would allow multiple media per unit. In this case, the BPB table
returned at INIT must define space large enough to acommodate the largest
possible medias supported (sector size in BPB must be as large as maximum
sector size DOS is currently using). Smart drivers will use the media
descriptor byte to pass information about what media is currently in a unit.



REQUEST HEADERÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 The request header passes the information describing what DOS wants the
device driver to do.
 When a valid device driver command code or function is called by your
application program, DOS develops a data structure called the "Request Header"
in ES:BX and passes it to the strategy entry point. This structure consists of
a 13-byte defined header which may be followed by other data bytes depending on
the function requested.
 It is the device driver's responsibility to preserve the machine state, for
example, saving all registers including flags on entry and restoring them on
exit. There is enough room on the stack when strategy or interrupt is called
to do about 20 pushes. If more stack is needed, the driver should set aside
its own stack space.
 The fixed ("static") part of the request header is as follows:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                        R E Q U E S T    H E A D E R                        ³
ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Offset ³Length ³                      F i e l d                             ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  00h  ³  byte ³ Length in bytes of the request header plus any data at end ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  01h  ³  byte ³ Unit code. Determines subunit to use in block devices      ³
³       ³       ³ (minor device)  Has no meaning for character devices       ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  02h  ³  byte ³ Command code                                               ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  03h  ³  word ³ Status                                                     ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  05h  ³8 bytes³ Reserved for DOS                                           ³
ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  0Ch  ³varies ³ Data appropriate for the operation                         ³
ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

REQUEST HEADER LENGTH FIELD

 The length in bytes of the total request header (0-255) plus any data at the
end of the header.


UNIT CODE FIELD

 The unit code field identifies which unit in a block device driver the request
is for. For example, if a block device driver has three units defined, then the
possible values of the unit code field would be 0, 1, and 2. This field is not
valid for character devices.


COMMAND CODE FIELD

 The command code invokes a specific device driver function. Functions 0
through 12 are supported in all device drivers. Functions 13-15 are available
only in DOS 3.0 or higher. Some functions are relevant for either character or
block devices but not both; nonetheless all functions must have an executable
routine present even if it does nothing but set the done flag in the return
status word in the request header.

 The command code field in the request header can have the following values:
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ code ³       name       ³                     function                       ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   0  ³ INIT             ³ initialize driver for later use (used once only)   ³
³   1  ³ MEDIA CHECK      ³ block devices only, NOP for character devices      ³
³   2  ³ BUILD BPB        ³ block devices only, NOP for character devices      ³
³   3  ³ IOCTL input      ³ called only if device has IOCTL bit set            ³
³   4  ³ INPUT            ³ read data                                          ³
³   5  ³ NONDESTRUCTIVE INPUT NO WAIT  character devices only                  ³
³   6  ³ INPUT STATUS     ³ character devices only                             ³
³   7  ³ INPUT FLUSH      ³ character devices only                             ³
³   8  ³ OUTPUT           ³ write data                                         ³
³   9  ³ OUTPUT           ³ write data with verify                             ³
³  10  ³ OUTPUT STATUS    ³ character devices only                             ³
³  11  ³ OUTPUT FLUSH     ³ character devices only                             ³
³  12  ³ IOCTL OUTPUT     ³ called only if device has IOCTL bit is set         ³
³  13  ³ DEVICE OPEN      ³ called only if OPEN/CLOSE/RM bit is set            ³
³  14  ³ DEVICE CLOSE     ³ called only if OPEN/CLOSE/RM bit is set            ³
³  15  ³ REMOVEABLE MEDIA ³ only if OPEN/CLOSE/RM bit set & device is block    ³
³  16  ³ OUTPUT UNTIL BUSY³ only called if bit 13 is set & device is character ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 The individual command codes are described later in this chapter.



STATUS FIELD

 The status word field is zero on entry and is set by the driver interrupt
routine on return.

The status field in the request header contains:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³            D E V I C E    D R I V E R    S T A T U S    F I E L D           ³
ÃÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ size  ³bit³                        definition                               ³
ÃÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ byte  ³ 0 ³                                                                 ³
³       ³ 1 ³                                                                 ³
³       ³ 2 ³                                                                 ³
³       ³ 3 ³  Error message return code                                      ³
³       ³ 4 ³  (with bit 15=1)                                                ³
³       ³ 5 ³                                                                 ³
³       ³ 6 ³                                                                 ³
³       ³ 7 ³                                                                 ³
ÃÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ byte  ³ 8 ³  DONE                                                           ³
³       ÃÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ 9 ³  BUSY                                                           ³
³       ÃÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ A ³  Reserved by DOS, unknown                                       ³
³       ³ B ³                                                                 ³
³       ³ C ³                                                                 ³
³       ³ D ³                                                                 ³
³       ³ E ³                                                                 ³
³       ÃÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³       ³ F ³  Error                                                          ³
ÀÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


 The low 8 bits of the status word define an error message if bit 15 is set.
These errors are:

        00h  write protect violation   01h  unknown unit
        02h  device not ready          03h  unknown command
        04h  CRC error                 05h  bad drive request structure length
        06h  seek error                07h  unknown media
        08h  sector not found          09h  printer out of paper
        0Ah  write fault               0Bh  read fault
        0Ch  general failure           0Dh  reserved
        0Eh  reserved                  0Fh  invalid disk change

BIT 8   is the done bit. If it is set, it means the operation is complete. The
        driver sets the bit to 1 when it exits.

BIT 9   is the busy bit. It is only set by status calls and the removable media
        call.

BITS 10-14 are reserved.

BIT 15  is the error bit. If this bit is set, the low 8 bits of the status word
        (7-0) indicate the error code.


RESERVED FOR DOS
 Official sources label this area as "reserved for DOS". Another source
indicates that this consists of two double-word (4-byte) pointers to be used
to maintain a linked list of request headers for this device and a list of all
current device requests being processed by DOS. This was apparently to be used
for the undelivered multitasking version of DOS.



DEVICE DRIVER FUNCTIONSÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 All strategy routines are called with ES:BX pointing to the request header.
The interrupt routines get the pointers to the request header from the queue
the strategy routines stores them in. The command code in the request header
tells the driver which function to perform.

NOTE: All DWORD pointers are stored offset first, then segment.

                         ############################

INIT
Command code = 0        (all devices)
        Performs all initialization required at DOS boot time to install the
        driver and set local driver variables. This function is called only
        once, when the driver is loaded.

        ES:BX   pointer to 26-byte request header and data structure
 Format of structure:
       offset     length          field
         00h    13 bytes   request header
         0Dh       byte    number of units (not set by character devices)
         11h       dword   ending address of the driver's resident code
         15h       dword   pointer to BPB array (not set by character devices)
                           /pointer to remainder of arguments
         19h       byte    drive number (DOS 3.0+ only)


 When INIT is called, the driver must do the following:

        A) set the number of units (block devices only)
        B) set up the pointer to the BPB array (block devices only)
        C) perform any initialization code (to modems, printers, etc)
        D) set the ending address of the resident program code
        E) set the status word in the request header

 To obtain information obtained from CONFIG.SYS to a device driver at INIT
time, the BPB pointer field points to a buffer containing the information
passed from CONFIG.SYS following the =. The buffer that DOS passes to the
driver at INIT after the file specification contains an ASCII string for the
file OPEN. The ASCII string (ending in 0h) is terminated by a carriage return
(0Dh) and linefeed (0Ah). If there is no parameter information after the file
specification, the file specification is immediately followed by a linefeed
(0Ah).

 NOTE: This information is read-only and only system calls 01h-0Ch and 30h can
       be issued by the INIT code of the driver.

 The last byte parameter contains the drive letter for the first unit of a
block driver. For example, 0=A, 1=B etc.

 If an INIT routine determines that it cannot set up the device and wants to
abort without using any memory, follow this procedure:

        A) set the number of units to 0
        B) set the ending offset address at 0
        C) set the ending offsret segment address to the code segment (CS)

NOTE: If there are multiple device drivers in a single memory image file, the
      ending address returned by the last INIT called is the one DOS uses. It is
      recommended that all device drivers in a single memory image file return
      the same ending address.

                         ############################

MEDIA CHECK
command code = 1        (block devices only)
        Checks to see if disk had been changed since last access.

        ES:BX   pointer to 19-byte request header and data structure
 Format of structure:
        offset  length          field
        00h     13 bytes   request header
        0Dh        byte    media descriptor from BPB
        0Eh        byte    returned
        0Fh       dword    returns a pointer to the previous volume ID (if bit
                           11=1 and disk change is returned) (DOS 3.0+)

 When the command code field is 1, DOS calls MEDIA CHECK for a drive unit and
passes its current media descriptor byte. See "Media Descriptor Byte" later in
this chapter for more information about the byte. MEDIA CHECK returns one of
the following:

        A) media not changed             C) not sure
        B) media changed                 D) error code

The driver must perform the following:
        A) set the status word in the request header
        B) set the return byte
                00h   don't know if media has been changed
                01h   media has not been changed
                -1    media has been changed

 DOS 3.0+: If the driver has set the removable media bit 11 of the device header
attribute word to 1 and the driver returns -1 (media changed), the driver must
set the DWORD pointer to the previous volume identification field. If DOS
determines that the media changed is an error, DOS generates an error 0Fh
(invalid disk change) on behalf of the device. If the driver does not implement
volume identification support, but has bit 11 set to 1, the driver should set a
pointer to the string "NO NAME",0.


MEDIA DESCRIPTOR
 Currently the media descriptor byte has been defined for a few media types.
This byte should be identical to the media byte if the device has the non-IBM
format bit off. These predetermined values are:

media descriptor byte =>    1  1  1  1  1  0  0  0
 (numeric order)            7  6  5  4  3  2  1  0

       BIT                MEANING

        0       0       not double sided
                1       double sided
        1       0       not 8 sector
                1       8 sector
        2       0       nonremoveable
                1       removeable
       3-7      must be set to 1

                         ############################

BUILD BPB (BIOS Parameter Block)
command code = 2        (block devices only)

        ES:BX   pointer to 22-byte request header and data structure
 Format of structure:
        offset   length          field
        00h     13 bytes   request header
        0Dh        byte    media descriptor from DOS
        0Eh       dword    transfer address (buffer address)
        12h       dword    pointer to BPB table

DOS calls BUILD BPB under the following two conditions:

A) If "media changed" is returned.
B) If "not sure" is returned. If so, there are no used buffers. Used buffers
   are buffers with changed data that have not yet been written to the disk.

The driver must do the following:

A) set the pointer to the BPB.
B) set the status word in the request header.

 The driver must determine the correct media type currently in the unit to
return the pointer to the BPB table. The way the buffer is used (pointer
passed by DOS) is determined by the non-IBM format bit in the attribute field
of the device header. If bit 13=0 (device is IBM compatible), the buffer
contains the first sector of the FAT (most importantly the FAT ID byte). The
driver must not alter this buffer in this case. If bit 13=1 the buffer is a
one sector scratch area which can be used for anything.

 For drivers that support volume identification and disk change, the call
should cause a new volume identification to be read off the disk. This call
indicates that the disk has been legally changed.

 If the device is IBM compatible, it must be true that the first sector of the
first FAT is located at the same sector for all possible media. This is
because the FAT sector is read before the media is actually determined.

 The information relating to the BPB for a particular media is kept in the boot
sector for the media. In particular, the format of the boot sector is:

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ For DOS 2.x, 3 byte near jump (0E9h) For DOS 3.x+, 2 byte near jump (0EBh)   ³
³ followed by a NOP (90h)                                                      ³
ÃÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 8 bytes  ³  OEM name and version                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   BYTE   ³     ³  sectors per allocation unit (must be a power of 2)         ³
ÃÄÄÄÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³  B  ³  reserved sectors (strarting at logical sector 0)           ³
ÃÄÄÄÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   BYTE   ³     ³  number of FATs                                             ³
ÃÄÄÄÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³  P  ³  max number of root directory entries                       ³
ÃÄÄÄÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³     ³  number of sectors in logical image (total number of        ³
³          ³     ³  sectors in media, including boot sector directories, etc.) ³
ÃÄÄÄÄÄÄÄÄÄÄ´  B  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   BYTE   ³     ³  media descriptor                                           ³
ÃÄÄÄÄÄÄÄÄÄÄ´     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³     ³  number of sectors occupied by a single FAT                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³  sectors per track                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³  number of heads                                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³   WORD   ³  number of hidden sectors                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 The three words at the end return information about the media. The number of
heads is useful for supporting different multihead drives that have the same
storage capacity but a different number of surfaces. The number of hidden
sectors is useful for drive partitioning schemes.

                         ############################

INPUT / OUTPUT  (IOCTL)
command code = 3   IOCTL Read
               4   Read              (block or character devices)
               8   Write             (block or character devices)
               9   Write With Verify
              12   IOCTL Write
              16   Output Until Busy (character devices only)

        ES:BX   pointer to 24-byte request header and data structure

  Format of structure:
        offset    length          field
        00h     13 bytes     request header
        0Dh        byte      media descriptor byte from BPB
        0Eh       dword      transfer address (buffer address)
        12h        word      byte/sector count
        14h        word      starting sector number (block devices)
                             [no meaning on character devices]
        16h       dword      (DOS 3.0+) pointer to the volume ID if error code
                             0Fh is returned

The driver must perform the following:
        A) set the status word in the request header
        B) perform the requested function
        C) set the actual number of sectors or bytes tranferred

 No error checking is performed on an IOCTL I/O call. However, the driver must
set the return sector or byte count to the actual number of bytes transferred.

 Under certain circumstances a block device driver may be asked to do a write
operation of 64k bytes that seems to be a "wrap around" of the transfer address
in the BIOS I/O packet. This arises due to an optimization added to write code
in DOS. It will only happen in writes that are within a sector size of 64k on
files that are being extended past the current end of file. It is allowable for
the device driver to ignore the balance of the write that wraps around, if it
so chooses. For example, a write of 10000h bytes worth of sectors with a
transfer address of XXX:1 ignores the last two bytes. A user program can never
request an I/O of more than 0FFFFh bytes and cannot wrap around (even to 0) in
the transfer segment, so in that case the last two bytes can be ignored.

 A program that uses DOS function calls can never request an input or output
function of more than 0FFFFh bytes, therefore, a wrap around in the transfer
(buffer) segment can never occur. It is for this reason you can ignore bytes
that would have wrapped around in the tranfer segment.

 If the driver returns an error code of 0Fh (invalid disk change) it must put
a DWORD pointer to an ASCIIZ string which is the correct volume ID to ask the
user to reinsert the disk.

DOS 3.0+:
 The reference count of open files on the field (maintained by the OPEN and
CLOSE calls) allows the driver to determine when to return error 0Fh. If there
are no open files (reference count=0) and the disk has been changed, the I/O
is all right, and error 0Fh is not returned. If there are open files
(reference count > 0) and the disk has been changed, an error 0Fh condition
may exist.

                         ############################

NONDESTRUCTIVE INPUT NO WAIT
command code = 5        (character devices only)
        Reads a character from input stream but does not remove it from the
        buffer

        ES:BX   pointer to 14-byte request header and data structure
 Format of structure:
        offset    length          field
        00h     13 bytes   request header
        0Dh        byte    read from device

The driver must do the following:
        A) return a byte from the device
        B) set the status word in the request header.

 If the character device returns busy bit=0 (characters in the buffer), then
the next character that would be read is returned. This character is not removed
form the buffer (hence the term nondestructive input). This call allows DOS to
look ahead one character.

                         ############################

STATUS
command codes =  6   Input Status      (character devices only)
                10   Output Status     (character devices only)
        Check for characters waiting in input buffer

        ES:BX   pointer to 13-byte request header

This driver must perform the following:
        A) perform the requested function
        B) set the busy bit
        C) set the status word in the request header.

The busy bit is set as follows:

 For input on unbuffered character devices: if the busy bit (bit 9) is 1 on
return, a write request would wait for completion of a current request. If the
busy bit is 0, there is no current request. Therefore, a write request would
start immediately.

 For input on buffered character devices: if the busy bit is 1 on return, a
read request does to the physical device. If the busy bit is 0, there are
characters in the device buffer and a read returns quickly. It also indicates
that a user has typed something. DOS assumes all character devices have a type-
ahead input buffer. Devices that do not have this buffer should always return
busy=0 so that DOS does not hang waiting for information to be put in a buffer
that does not exist.

                         ############################

FLUSH INPUT BUFFERS
command code = 7        (character devices only)
        Forces all data in buffers to specified device.

        ES:BX   pointer to 13-byte request header

 This call tells the driver to flush (terminate) all pending requests that it
has knowledge of. Its primary use is to flush the input queue on character
devices.

 The driver must set the status word in the request header upon return.

                         ############################

FLUSH OUTPUT BUFFERS
command code 11         (character devices only)
        Forces all data in buffers to specified device.

        ES:BX   pointer to 13-byte request header


 This call tells the driver to flush all output buffers and discards any
pending requests. Its primary use is to flush the output queue on character
devices.

 The driver must set the status word in the request header upon return.

                         ############################

OPEN or CLOSE  (DOS 3.0+)
command code = 13   Open      (block or character devices)
               14   Close     (block or character devices)

        ES:BX   pointer to 13-byte static request header

 These calls are designed to give the device information about the current file
activity on the device if bit 11 of the attribute word is set. On block
devices, these calls can be used to manage local buffering. The device can keep
a reference count. Every OPEN causes the device to increment the reference
count. Every CLOSE causes the device to decrement the reference count. When the
reference count is 0, if means there are no open files in the device. Therefore,
the device should flush buffers inside the device it has written to because now
the user can change the media on a removeable media drive. If the media had been
changed, it is advisable to reset the reference count to 0 without flushing the
buffers. This can be thought of as "last close causes flush". These calls are
more useful on character devices. The OPEN call can be used to send a device
initialization string. On a printer, this could cause a string to be sent to set
the font, page size, etc. so that the printer would always be in a known state
in the I/O stream. Similarly, a CLOSE call can be used to send a post string
(like a form feed) at the end of an I/O stream. Using IOCTL to set these pre and
post strings provides a flexible mechanism of serial I/O device stream control.

 Since all processes have access to STDIN, STDOUT, STDERR, STDAUX, and STDPRN
(handles 0, 1, 2, 3, and 4) the CON, AUX, and PRN devices are always open.

                         ############################

REMOVABLE MEDIA  (DOS 3.0+)
command code = 15       (block devices only)
        This call identifies the media type as removable or nonremovable.

        ES:BX   pointer to 13-byte static request header

 To use this call, set bit 11 (removable media) of the attribute field to 1.
Block devices can only use this call through a subfunction of the IOCTL
function call (int 21h fn44h).
 This call is useful because it allows a utility to know whether it is dealing
with a nonremovable media drive or with a removable media drive. For example,
the FORMAT utility needs to know whether a drive is removable or nonremovable
because it prints different versions of some prompts.

note    No error checking is performed. It is assumed that this call always
        succeeds.


THE CLOCK$ DEVICEÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 To allow a clock board to be integrated into the system for TIME and DATE,
the CLOCK$ device is used. This device defines and performs functions like any
other character device (most functions will be reset done bit, reset error bit,
and return). When a read or write to this device occurs, 6 bytes are
transferred. The first 2 bytes are a word, which is the count of days since
01-01-80. The third byte is minutes, the fourth is hours, the fifth is
hundredths of a second, and the sixth is seconds.

 Reading the CLOCK$ device gets the date and time, writing to it sets the date
and time. CLOCK$ is normally called only when the system is initializing or if
the system time and date are set (DOS 3.3+). DOS carries the system time and
date internally after receiving it from the CLOCK$ driver.





   **  Programmer's Technical Reference for MSDOS and the IBM PC **
            USA copyright TXG 392-616  ALL RIGHTS RESERVED
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ DOSREF (tm) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ISBN 1-878830-02-3 (disk-based text)
                Copyright (c) 1987, 1994 Dave Williams
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³ Shareware Version, 01/20/94 ³
                   ³  Please Register Your Copy  ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                             C R E D I T S


  The information presented here was gathered from megabytes of files 
found on BBS systems, conversations on a dozen different BBS systems, 
correspondence, and every reference book I could get my hands on.  On 
occasion, a number of prestigious references didn't agree with each 
other.  Where this has happened, I have used the latest references.  
There is too much information here for me to verify every fact 
personally.  I have used my own judgement as to the reliability of the 
sources. 

  I've been selling copies of the Reference since October 1987.  The 
original basis for the Reference came from Peter Norton's 
"Programmer's Guide to the IBM PC" and the original Janet Jack 
interrupt list circa sometime 1986, as updated by Ross Greenberg, plus 
a copy of the IBM DOS 3.1 Technical Reference.  It's grown a bit, eh?  
Anyway, I've prepared a list of the sources I've used for the 
Reference to clear up any curiosity as to where the material came 
from. 



Tools used in preparing this book:


Microsoft SymDeb, the final gasp of venerable DEBUG.COM and a fine 
program. 

Microsoft CodeView, huge and awkward though it may be.

V Communications Sourcer, the only effective disassembler I've found.



References used in preparing this book:


An Introduction to the DOS Protected Mode Interface
        Software Focus Group
        Intel Corp, March 1991   order # 240787-002

AST EEMS Technical Reference Manual v3.2
        documents 020022-001B and 000408-001B
        provided by AST Corporation, 1987

AT&T 6300 Plus Hardware Reference Manual
        p/n 999-300-194IS
        from AT&T Corp, 1985 (before the Death Star logo, yet...)

Calculus EZ-FAX Developer's Toolkit
        copy 1990, Calculus

Creative Labs Sound Blaster User Reference Manual
        copr. 1989

Data General Programmer's Reference for MS-DOS, Rev.3
        Data General Corporation             (covers through DOS 3.0)
        p/n 069-100157 rev 00 May 1986

Digital Research DR-DOS System and Programmer's Guide v3.32
        Digital Research Corporation 1988
        comment: This manual does not cover the extended disk partition
                 access, file password protection, or any of the other
                 goodies provided in DR-DOS.  In fact, it not only
                 doesn't cover the extended features, it doesn't
                 completely cover DOS calls documented by IBM.  It does
                 have an extensive section on customizing DR-DOS for
                 use from ROM.

Digital Research DR-DOS User's Guide v3.32
        Digital Research Corporation 1988

Digital Research DR-DOS Reference Guide v3.32
        Digital Research Corporation 1988

Digital Research DR-DOS Users and Reference Guide v3.40
        Digital Research Corporation, January 1989

Digital Research DR Multiuser DOS Users and Reference Guide v5.0
        Digital Research Corporation, 1991

Digital Research DR-DOS Users and Reference Guide v5.0
        Digital Research Corporation, 1991

DPMI 0.9 Specification
        Intel Corp, 1990

DPMI 1.0 Specification
        Intel Corp, 1991

G-Host S3 Enhanced Video Graphic Adapter User's Manual
        G-Host, 1992

IBM DOS Operations Manual Version 2.00
        IBM Corp, 1983

IBM DOS Operations Manual Version 2.10
        IBM Corp, 1983

IBM DOS Operations Manual Version 3.1
        IBM Corp, November 1984

IBM DOS Operations Manual Version 3.3
        IBM Corp, April 1987

IBM DOS Technical Reference, Version 4.0
        IBM Corp, 1988

IBM DOS Command Reference, Version 4.0
        p/n 6280254
        IBM Corp, 1988

IBM PC 3270 Emulation Program Entry Level Version 1.10
User's Guide
        pn 84X0280
        IBM Corp, 1986

IBM PC 3270 Emulation Program Entry Level Version 1.10
HLLAPI Programmer's Guide
        pn 84X0301
        IBM Corp, 1986

IBM PC Local Area Network Program Version 1.20
        IBM Corp, April 1987

IBM Technical Reference
        Options and Adapters - Enhanced Graphics Adapter
        p/n 6280131  IBM Publications Aug 1984

IBM Technical Reference
        Personal Computer
        p/n 6322507 IBM Publications

IBM Technical Reference
        Personal Computer - PCjr
        p/n 1502293 IBM Publications

LANtastic Programmer's Information Package, 2/21/89

Logitech Mouse Programmer's Toolkit
        Logitech Corp. 1986

Lotus-Intel-Microsoft Expanded Memory Specification Version 3.20
        part number 300275-003
        provided by Intel Corp.  September, 1985

Lotus-Intel-Microsoft Expanded Memory Specification 4.0
        document 300275-005
        provided by Intel Corp.  October 1987

Lotus-Intel-Microsoft Expanded Memory Specification 4.0
EMS Toolkit for C Developers
        document 302243-001
        provided by Intel Corp, February 1990

Microsoft - various documents provided to MS 5.0 beta testers

Microsoft Extended Memory Specification v2.00
        provided by Microsoft Corporation,  1988

Microsoft Mouse Technical Reference
        Microsoft Press, 1989

Microsoft Virtual DMA Specification 1.0
        Microsoft Part # 098-10869  May 1, 1990 

Mouse Systems Programmer's Toolkit
        p/n 302449-001 Rev A, 1989
        p/n 302375-100, 1989
        p/n 302446-100, 1989

MS-DOS Programmer's Reference                (covers through DOS 2.00)
        by Microsoft
        p/n 135555-001 Intel Corp. 1984

MS-DOS 5.0 Programmer's Reference            (covers DOS 5.0 only)
        by Microsoft
        Microsoft Press 1991, ISBN 1-55615-329-5

Novell Netware 2.19 SFT/Advanced manual set
        by Novell, Incorporated
        Novell, 1988

Phar Lap Virtual Control Program Interface (VCPI) Specification v1.0
        Phar Lap Software 1989

Phoenix System BIOS for PC/XT/AT and Compatibles
        Addison Wesley, 1987

Phoenix System BIOS for PC/XT/AT and Compatibles (Second edition)
        Addison Wesley, 1991

Tandy 1000 TX Technical Reference Manual
        Tandy Corp.
        p/n 25-1514  Tandy Corp 1987

The Software Link
        PC-MOS 4.1 Programmer's Reference (1990)

Toshiba 1000 Technical Reference Manual
        Toshiba Corp. of America 1987

Tseng Labs EVA Chipset Programming Guide
        Tseng Labs, 1986

X3.4-1977: American National Standard Code for Information Interchange
        by American National Standards Institute (ANSI)
        New York, NY  1977

Weitek ABACUS Software Designer's Guide, Doc 8967
        September 1989

Wendin-DOS Programmer's Reference
        Wendin, Inc, 1987

**********************

ATI EGA Wonder Operation Manual
        ATI Technologies, 1987

Everex EV-650 EGA Reference Guide, Version 1.00
        Everex Computer, 1986

FastCard IV User Manual
        Peripheral Marketing Inc.
        p/n 0527        Jan 1987

Hercules Graphics Card User's Manual
        Hercules Computer Technology
        1983

Hercules Graphics Card Plus Owner's Manual
        Hercules Computer Technology
        Model GB112  1987

JDR B-3101 FLoppy Disk Drive Card User's Guide
        470.03002 version 1.00    1988

LANtastic 2.46 Installation Guide
        Artisoft, 1988

LANtastic 3.01 Installation Guide
        Artisoft, 1990

LANtastic 4.0 beta Installation Guide
        Artisoft, 1991

LapLink Release 2 User's Manual
        Traveling Software, 1987

LapLink Release 3 User's Manual
        Traveling Software, 1989

Logitech EGA Reference Manual, EGA+Mouse Board

Mirage Super VGA TVGA-8900 User's Manual

MPC Operations Guide,  Manual #1023
        Columbia Data Products, Inc.
        CDP  1983

Microcomputer Products - 1987 Data Book
        NEC Electronics, Inc.
        p/n 500105      Aug 1987

NEC uPD70108/70116 Microprocessor User's Manual
        p/n 500350      October 1986
        provided by NEC Electronics, Inc.

Novell Advanced Netware System Manager's Reference

pcAnywhere User's Guide v2.00
        Dynamic Microprocessor Associates, Inc  1986

S-286 User Manual, version 2
        Link Computer, 1988

STB VGA Extra/EM
        EM-16 BIOS Features
        STB Corp.

TesSeRact v1.0 documentation

TCXL 5.1 documentation

Toshiba ND352/356 3.5" Diskette Drive Installation Notes
        document number 87019   March 1988
        Toshiba America Corporation

Tseng Labs
        EVA, EVA/480 BIOS Guide
        November 10, 1988

VESA Toolkit v2.0
        summer 1991

VideoTrax Installation Guide
        Alpha Micro, 1987

******************

Advanced MSDOS
        Ray Duncan
        Microsoft Press  1986

Assembly Language Programming for the        (written by one of the  )
IBM Personal Computer                        (IBM PC's original      )
        David J. Bradley                     (developers - and one of)
        Prentice-Hall   1984                 (the few good 8087 refs )

Assembly Language Subroutines for MSDOS Computers
        Leo J. Scanlon
        TAB Books   1986

Atari ST Internals
        Gerits, English, & Bruckmann
        Abacus Software  1985

Compute!'s Guide to Assembly Language Programming on the IBM PC
        COMPUTE! Publications

Compute!'s Mapping the IBM PC and PCjr
        Russ Davis
        COMPUTE! Publications

DOS Power Tools
        Paul Somerson
        Bantam Books  1988

DOS: The Complete Reference
        Kris Jamsa
        Osborne/McGraw-Hill  1987

Exploring the IBM PCjr
        Peter Norton
        Microsoft Press  1984

Discovering the IBM PCjr
        Peter Norton
        Microsoft Press  1984

DOS 5: A Developer's Guide
        Al Williams
        M&T Books, 1991

IBM Video Subsystems
        Richard Wilton
        Microsoft Press  1988

Inside the IBM PC
        Peter Norton

Mapping the IBM PC
        Russ Davies/Compute! Magazine
        Compute! Books   1986

Memory Resident Utilities, Interrupts, and
Disk Management With MS & PC DOS
        Michael Hyman
        MIS Press  1987

Microcomputer Interfacing
        Bruce A. Artwick
        Prentice Hall   1980

Microsoft Systems Journal - March 1987
        "Expanded Memory: Writing Programs that Break the 640k Barrier"
        Marion Hansen, Bill Krueger, Nick Stuecklen

MS-DOS Encyclopedia
        Ray Duncan
        Microsoft Press 1988  (first edition)

Modern Operating Systems           (this is an updated and revised )
        Arthur S. Tanenbaum        (version of the OSD&I book below)
        Prentice Hall 1991

Network Programming in C                (excellent resource for IPX )
        Barry Nance  (barryn on BIX)    (and NETBIOS API info       )
        Que, 1990

Operating Systems Design and Implementation  (this is one of your )
        Arthur S. Tanenbaum                  (OS design references)
        Prentice Hall 1987

Programmer's Guide to the IBM PC
        Peter Norton
        Microsoft Press  1985

Programmer's Problem Solver for the IBM PC, XT, & AT
        Robert Jourdain
        Prentice Hall  1986

Programming Windows
        Charles Petzold
        Microsoft Press, 1987

Programming Windows, Second Edition
        Charles Petzold
        Microsoft Press, 1990

Running MS-DOS
        Van Wolverton
        Microsoft Press

Supercharging MS-DOS
        Van Volverton
        Microsoft Press  1986

The 8080a Bugbook
        Tony-Larsen-Titus
        Howard W. Sams   1977

The 8086 Book                           (strange - though it's been  )
        Russell Rector and George Alexy (through a couple of releases)
        Osborne/McGraw-Hill  1980       (it's basically just a bunch )
                                        (of old Intel data sheets    )
                                        (stamped "PRELIMINARY"       )

The IBM Personal Computer from the Inside Out
        Murray Sargent III and Richard L. Shoemaker
        Addison-Wesley  1984

The IBM ROM BIOS
        Ray Duncan
        Microsoft Press  1988

The Serious Assembler                     (prehistoric stuff, but   )
        Charles A. Crayne and Dian Gerard (some tricks you don't see)
        Baen Books   1985                 (any more                 )

Tricks of the MS-DOS Masters
        Waite Group
        Howard W. Sams  1987

Turbo Pascal Express                    (lots of ASM routine for TP3)
        Robert Jourdain
        Brady Books, 1987

Writing DOS Device Drivers in C         (this one is a real turkey)
        Adams/Tondo
        Prentice Hall, 1990

***********************

Microsoft Macro Assembler 4.0, 5.1 documentation

Microsoft C 4.0, 5.0, 5.1, 6.0, 7.0 documentation

Borland Turbo Pascal 3.02a and 6.0, Borland Pascal 7.0, TPW 1.0 and 
1.1, Turbo C 2.0 documentation

Novell SFT System Administrator's Reference

***************************

  Western Digital, Rodime, Miniscribe, Microscience, Adaptec, Storage 
Technologies, and Connor Peripherals were kind enough to send spec 
sheets on most of their products which helped to expand and verify the 
hard drive information in Appendix 6. 

***************************

  A large amount of miscellaneous information came from various 
computer magazines.  Documenting what came from where would be an 
experience all its own.  A great deal of information came from 
articles by Michael Mefford, Jim Prosise, and Charles Petzold of PC 
Magazine, and Neil Rubenking, Jeff Duntemann, and Ray Duncan, who get 
around a lot. 

   Byte
        ( Byte's kinda weird. They have some really neat, well-
          researched stuff interspersed with mindless drivel.  Still,
          they print some stuff you absolutely, positively won't find
          anywhere else. )

   C Users Journal
        ( Despite the name, it's mainly about programming DOS machines)

   C'T (Computer Technik)
        ( If you read German, this one is sorta like PC Magazine was
          in its heyday. )

   Computer Language
        ( I never decided if I liked CL or not.  Maybe I'm not the 
          sort of programmer they're writing for... ) (04/93 - just
          got word CL is dead.  Maybe nobody else knew who they were
          writing for either)

   Computer Shopper
        ( Though primarily advertising, some information sneaks in
          from time to time. )

   Dr. Dobb's Journal
        ( I always thought the old title, "Doctor Dobbs' Journal of
          Computer Calisthenics and Orthodontia - Running Light
          Without Overbyte" was a killer name, but nobody asked me. )

   InfoWorld
        ( I never really figured out how a weekly magazine could so
          often be both late *and* wrong with their stories, but IW
          tries hard.  Still, you often hear about rumblings you'd
          never find out about in the slicks.  The National Enquirer
          of the computer world? )

   Micro Cornucopia
        ( R.I.P - it was great while it lasted. )

   Microsoft Systems Journal
        ( Hideously expensive and mostly oriented to Windows, the
          early issues had some really good stuff )

   Midnight Engineering
        ( This one's hard to classify.  It's hardcore computer with a
          dash of entrepreneurship, bizarre as the combination may
          sound.  I like it when I can find it. )

   PC Magazine
        ( Despite their new "management format" in mid '89, PC Mag
          still has some good techie stuff from time to time.  I guess
          the bean counters thought managers were more important than
          programmers. )

   PC Resource
        ( There was rarely anything of interest in PC Resource, but
          every now and then I found something.  Now defunct. )

   PC Tech Journal
        ( "Tell 'em what you're going to say, tell 'em what you're
          saying, tell 'em what you just said." - and don't send us
          no steenking submissions unless they're in WordPerfect
          format!  Despite their fascist policies, every now and then
          they printed something useful.  The Little Rock Wild Bunch
          referred to it as "PC Tech Urinal," an apt monicker.  Now
          defunct. )

   PC Techniques
        ( This is the magazine PC Tech Journal tried to advertise
          itself as.  Pure programming, written by programmers for
          programmers, without too many "journalists" pissing in the
          text.  Try it! )

   PC Week
        ( This one used to be a clone of InfoWorld, but since their
          takeover by PC Magazine they've become a sort of mutant
          cross between IW and PCMag. )

   Programmer's Journal
        ( This is a nice magazine, though expensive. - now defunct )

   Tech Specialist (now Windows/DOS Developer's Journal)
        ( One of the few really good magazines for bit-twiddlers.
          Haven't seen a GUI phone-dialer shootout yet! )

   Windows Tech Journal
        ( This one is sort of neat even if you don't like Windows.  It's
          another "by programmers, for programmers" rag, lots of code
          with a dash of humor.)

****************************

various computer bulletin board systems, including

Byte Information Exchange (BIX)
 (check out ibm.dos/old.secrets.2 and ibm.dos/secrets.3)

 Effusive thanks to the gang in the ibm.exchange - these guys are 
*sharp*.  In alphabetic order: 

barryn, billn, bkep, bscherry, bstrauss, daiken, dgh, dmick, dnanian, 
dondumitru, drifkind, geary, glass, gmussar, greenber, hfishman, 
j_vanderbilt, jfleming, jndunlap, jlussmeyer, johnf, jsloman, jsprowl, 
jswitzer, jrichards, karenk, killer1, kquirk, mabrash, matt.trask, 
mcowley, mfsargent, mike123, mheller, mlavelle, rbabcock, rbrukardt, 
rduncan, roedy, ronlepine, sbc, sjgrant, skluger, tanj, terjem, 
twagner, wardc, wcowley, and all the guys whose names I forgot... 
<grin> 

Compuserve's Microsoft beta forums

FIDOnet international network       (various technical echos)

GEnie IBM RT and Borland RT

NorthAmericaNet (NaNet) programming echos

Canada Remote Systems               (Toronto, Canada)

RIME PCRelay international network  (IBM, Technical, Programming echos)

TelePath (M&T Publishing)

usenet ibm*.* groups

...plus I hit the various Wildnet, and GT-Net echos from time to time!

*********************************

  The following text files were of use.  Bear in mind that some of 
them may be seen under several different names.  The author's name is 
given as it appears in the documentation (if any).  As you can see, 
this stuff predated the ARC-vs-ZIP wars... 

10H-BUG  ASM     4680  29/01/87 bug in 2.x int 21h/fn10h       Ray Duncan

1PT4MB   INF     5120   3/10/87 1.44Mb drives   Clyde Washburn 70305,1211

2_JOYSTK.ZIP      723   17/4/89 dual joystick adapter pinout    <no name>

2EH      ASM     2969   3/03/87 info on undoc'd int 2Eh     David Gwillim

386BUG   ARC     9216  15/10/87 bug in early 80386 chips     Compaq Corp.

8086     3      10572   5/12/88 dump of Fidonet?? 8086 conf??   <no name>

8259     ARC     2826  15/03/88 info on 8259 chip               <no name>

ASM-ADRS ARC     6144  20/12/87 low memory vectors   Malcolm McCorquodale

ATCMDS   ARC     3072  20/03/88 Hayes 1200 baud command set     <no name>

BACKDOOR UPL    26115  11/12/89 "back door" through PSP      John Switzer

BIOSDOC  ARC    34816   3/11/87 very good function list   David E. Powell

BIXDOS1  ARC   155648  14/12/87 BIX "MSDOS Secrets" #1          <no name>

BUG40DOS ARC     3200  18/08/88 bugs in DOS 4.0                    "Doug"

CAS      ARC    33792  27/10/88 Communicating Applications Standard 1.0A
                                                          DCA, Intel Corp

CCPM86   ARC    68238  14/10/89 list of Concurrent CP/M calls   <no name>

CDOS     ARC    35584  18/07/89 list of Concurrent DOS calls   Guy Scharf

CDOS2_   ARC   227200  18/07/89 list of Concurrent DOS calls J.F. Jankura

CDOSCALL ARC    19968  18/07/89 list of Concurrent DOS calls J.F. Jankura

CNBDOC   ZIP    32012   9/02/91 CBIS Net Bios Programmer's Ref.
                                                             Tom Thompson

CUFEXT   ARC    13228  13/03/90 common file extensions         J.W. Rider

DEBUGTUT ARC    15655  23/04/88 DEBUG tutorial                  <no name>
                                                  possibly David Whitman?

DIAGNOSE ARC    14336   1/01/86 memory errcodes
                                           Jerry Schneider, Arnold Kischi

DISK144  ARC    23086  16/10/88 info on 1.44Mb diskettes        <no name>

DISKTYPE ARC     5073  14/04/88 IBM floppy formats              <no name>

DOOM     ARC     9216  29/09/88 hard drive information          <no name>

DOS-SIZE ARC      787  27/03/88 size of DOS files 1.1-3.1       <no name>

DOS3TXT  ARX     9168  31/07/85 list of DOS/BIOS ints, data areas
                                                              Dan Rollins

DOS32    ARC    17408  31/05/88 command list for DOS 3.2        <no name>

DOS3BUGS ARC     5639  15/10/87 acknowledged bugs in DOS 3.0-3.2 IBM Corp.

DOS40    ARC    15625  22/07/88 IBM announcement of DOS 4.0     IBM Corp.

DOS401   ARC    18178  19/10/88 errors in DOS 4.0               IBM Corp.

DOS40B   ARC    27008  26/08/88 Compuserve thread on DOS 4.0    <no name>

DOS40FAT ARC     1510  11/09/88 DOS 4.0 File Allocation Table Mike Austin

DOS40FUN ZOO     3410  31/12/99 DOS 4.0 int 24, 25, etc         Pat Myrto

DOS40HLP ARC    53376  28/08/88 DOS 4.0 command set             <no name>

DOS40TXT ARC    46169  16/10/88 DOS 4.0 problems & info         <no name>

DOS4TIPS ARC     1735  19/09/88 problems with DOS 4.0           IBM Corp.

DOSBUG   TXT     1024  15/10/87 info on 2.0 volume label        <no name>

DOSGUIDE ARC    21344  21/02/88 DOS tutorial          Carrington B. Dixon

DOSINT   ARC     4201  15/03/88 list of DOS 2.0 function calls John Chapman

DOSNOTES ARC     5052  15/03/88 info on DOS undoc fns.          <no name>

DOSREF   ARC     9216  21/01/87 partial list of PC BIOS calls   <no name>

DOSREF   ARC    62052  23/08/86 device driver info              "Cracker"
                                                               
DOSTIPS  ARC    28926  15/03/88 info on DOS                  John Chapman

DOSTIPS1 ARC   159657  25/11/85 various DOS info             Dean R. Wood

DOSTIPS3 ARC    59264  25/01/88 various DOS tips (different) Dean R. Wood

DOSUNDOC ARC     3840  03/05/86 one of the very first interrupt lists
                                                     Spyros Sakellariadis

DRIVPARM ARC    11264   7/01/88 info on DRIVPARM parameters Joan Friendman

EGATEK   ARC     8704  15/03/88 IBM EGA registers             Bill Frantz

EMS40BIX ARC     3802  21/09/87 BIX announcement of EMS 4.0           BIX

ENVIRONM ARC     4255  18/09/88 info on DOS environment     Jan Fagerholm

ESC_CODE ARC     3072   3/10/88 Laserjet setup codes               S. Noh

FILEIO   ARC     8192  24/07/88 TSRs and INDOS flag             <no name>
                                                           
FLOPPIES ARC     9216   2/11/87 info on floppy media           Ted Jensen

FOSSIL   ARC     9031  15/07/87 list of FOSSIL functions Vincent Periello

FXN4BH   ASM     4503   1/01/80 odd 4Bh behavior               Ray Duncan

HAYESET2 ARC     6479   4/09/86 modem commands   Ruth Lubow, Fowler Brown

HD-DATA  ARC     4096  19/07/87 list of hard drives & specs     <no name>
                           I've seen many similar files. I believe the
                            original may have been a file or bulletin on
                            Sparta BBS

HDINFO   ARC    11264  19/11/87 updated version of above, evidently by
                                someone else                    <no name>

HDNOISE  ARC     4159  11/11/87 hard disk information       Clancy Malloy

HDTIPS   ARC     9660  11/10/87 hard disk information        Barry Gordon

IBMTAB   ARC     7882  15/03/88 general IBM PC tech info      John S. Lou

IBMTECH  ARC   136064   4/11/88 error codes, other info          IBM Corp.

INT-MDOS ARC    20682  31/07/85 one of the original INT lists
                                                           Ross Greenberg

INTER189 LZH   156368  25/06/89 interrupt list                 Ralf Brown

INTERRUP ARC   157440  19/09/88 interrupt vector list          Ralf Brown

INTERRPT ARC    42632   4/04/88 interrupt vector list   Marshall Presnell
                         this is a very nice list and some programming
                         information. If I'd come across it way back
                         then it would have saved a ton of typing <sigh>

JARGON   ARC    49274  16/07/88 dictionary of computer terms    <no name>

LE_MCLCK.ASM     3489   3/27/86  undoc'd Leading Edge BIOS fns
                                                             Bob Plouffe

LIM-40   ARC    21504  15/10/87 info on LIM 4.0          Stephen Satchell

LISTINTS ARC     6144   3/12/87 small interrupt list            <no name>

MCB      ARC     5120  24/07/88 info on DOS Memory Control Blocks
                                                           David Gwillim

MIDIBOOK ZIP     1338  09/08/89 MIDI book bibliography    Chris Bosshardt

MNP-TEXT ARC     6144  30/09/88 MNP modem info                 Mike Focke

MOUSENG  ARC    10240  13/08/88 Norton Guide file for mouse programming,
                                with C examples                 <no name>

MSLOOKUP ARC    58368  25/12/87 interrupt and function listing
                                                             Frank Bonita

MS-OS2   ARC    25600  15/10/87 MS press release on OS/2  Microsoft Corp.

MSINT125 ARC    48128  12/01/88 interrupt vector listing       Ralf Brown

MDOSDOC  EXE    47104   4/21/91 MultiDos Plus 4.00 Prog. Ref.
                                                             Nanosoft Inc.

NETBIOS  ARC    17280  29/10/88 NetBIOS tutorial & summary   Tom Thompson

NOVELINT ARC     4531  18/10/88 NetBIOS calls                  Marc Guyot

OCOM_520 ARC    53632  19/08/88 FOSSIL tutorial and functions  Rick Moore

ODDITY   ARC     3072  24/07/88 int 2Eh description         Daniel Briggs

PINS     ARC     3072  18/01/88 pinouts of various connectors   <no name>

PORTDIAG ZIP     2261  27/05/89 pinouts of various connectors   <no name>

PRNBIOS  ZIP      7519 29/10/89 programming info on printer   Michael Day

QUES40   ARC     9081   1/09/88 info on DOS 4.0                  IBM Corp.

RAW_COOK ARC     2048  15/10/87 info on DOS raw and cooked modes
                                                                <no name>

RESETSWT TXT     3584  23/01/86 add a reset switch to a PC    Don Jenkins

RLLHINTS ARC    12288  17/10/87 RLL controller info           Steve Sneed

RLLMISC  ARC     5120  17/10/87 info on RLL controllers  Richard Driggers

RLLSTORY ARC     9718  31/07/88 good info on RLL coding     Pete Holzmann

SEAGATE  ARC     2048   3/03/88 specs for many Seagate drives  Jim McKown

SECRETS2 ARC   179625  17/04/88 BIX "MS-DOS Secrets" #2         <no name>

SERCBL2  ARC     4372  16/10/88 serial cable pinouts             Lee Zeis

SERIAL   TXT     1091  07/04/87 PCjr serial cable pinout      Don Watkins

SM2400   ARC     2296   9/08/86 Hayes 2400 baud command set     <no name>

SPOOL    DOC    29704  03/28/89 Versa-Spool API               Jeff Newbro

SSTEP    ARC     2300  11/07/89 explanation of CPU single-step
                                                              Ed Burnette

ST225    ARC    11264   7/10/87 optimizing ST225 and WD cont.   Neil Erbe

TANDON   ARC     3612  21/02/88 info on Tandon drives       David Welcher

TECH     ARC    27827   8/05/88 misc tech info - Fidonet?       <no name>

TOOLS    C      14032   8/10/89 Grid laptop special functions
                                                         Fredrick Coffman

TOS               938  24/03/88 TOS function calls          Mike Crawford

TOSHTEAC ZIP      624   9/07/89 pinout for ext. drive on T1100     "Dave"

TRYST    ARC    29312  29/10/88 DOS and hard disk info        Amy Goebel

UNDOCINT 21H     7168  14/04/87 undocumented DOS calls     Peter Holzmann

VESA     TXT    41269  01/17/90 VESA standard                        VESA

VGAKIT   DOC     7634  05/04/90 VGA programming kit          John Bridges

VGAPIN   ARC     1252  24/10/88 VGA pinout                         "Mike"

WD-27X   ARC     6144  10/10/87 WD 27X HD controller setup  Steve Shelton

WDCONFIG ARC     5504  11/10/87 WD-1002 WXS setup        Richard Driggers

WDCONT   ARC    11264  25/12/87 info on WD hard disk controllers
                                                              Peter Fales

XEB1210  ARC     7947  18/07/87 Xebec HD controller setup 
                                                         Richard Driggers

XEBEC    ARC     1036  30/04/88 setup for Xebec HD controller
                                                         Richard Driggers
                                                       
XEBECTEC ARC     1834  30/04/88 setup for Xebec 1210            <no name>

XGADEMO  LZH    23552  01/27/91 IBM XGA programming info v.50  Bert Tyler

XMS      ARC    75776   1/08/88 Microsoft Extended Memory
                        Specification 1.0           Microsoft Corporation

XTCHARTS ARC    12416   4/11/88 ports, charts                   <no name>

                      **********************************

4DOS.DOC     Tom Rawson         4DOS int 2Eh, 2Fh calls, SHELL= bug

APARDOS4.TXT IBM Corp.          bug reports for DOS 4.0

APARDOS5.TXT IBM Corp.          bug reports for DOS 5.0

BOOKS.TXT    Chriss Bosshardt   bibliography of MIDI references

BMP.HDR      Jim Kent           MS .BMP format

CED10D       Chris Dunford      CED interrupt calls

DESQ10.ASM   James H. LeMay     DESQview API calls

GLOSSARY.ARC no author name     computer terms

LANTSTIC.DOC LANtastic adware   peer-to-peer LAN calls

NBRCV.C      Paul McGinnis      NetBIOS API calls

NETTUT.DOC   Charles L. Hedrick TCP/IP network




  DOSREF isn't a tutorial, and sometimes you need a tutorial.  
Microsoft has finally written a half-decent one - The MS-DOS 
Programmer's Reference, Microsoft Press, 1991, ISBN 1-55615-329-5.  
This is the DOS 5.0 Tech Ref. It covers data structures and DOS 
programming concepts clearly.  However, it has no information on other 
DOS versions, nor does it (of course) cover undocumented calls. 

                     ------------------------------------

  Nothing gets written in a vacuum, and I'd like to express my thanks 
to all the people who have been good enough to furnish information and 
support: 
   (in alphabetical order)

Tommy Apple, Mike Crawford, Herman Diagostino, Joe Felix, Ron Melson, 
Denis Murphy, & Ben Sansing, 
        who all loaned me documentation and reference material for
        so long that some of them have forgotten to ask for their
        stuff back


 And those people who were kind enough to help out:

Mike Blaszczak, MA:
BIX: blaszczak
        who went rampaging through work and client's sites to find and 
        document various model ID bytes, plus plenty of information on 
        MS OBJ file formats 

Carl Bretteville, Drammen Norway:
        who sent me a complete Concurrent DOS Programmer's Reference, 
        considerably enriching the Norwegian postal service thereby 

William Cravener 
CIS: 72230,1306
         who allowed me to include his PORT-IN.OUT file 

John Dallman 
jgd@cix.clink.co.uk
        more information on eDOS 4.0 

Herman Diagostino, Manassas VA: who worked up the TECHMENU menu file 
        and provided a copy of the rare IBM DOS 4.0 Technical 
        Reference and a copy of the original MSDOS Encyclopedia from 
        Microsoft, info on the Pelican 5.5mb floppy drive, IBM DOS 4.0 
        command reference, many hard drive specs, OS/2 DOS Box 
        differences 

James Drenter, Davenport IA:
        additional info on int 1Ch

David Dorling, Buderim, Australia:
        found one embarrassing error in the device driver info and 
        provided many expansions and clarifications 

Chris Dunford, Columbia MD:
CIS: 76703,2002
        who sent me a copy of the PCED 2.0 API and let me use his 
        INTPROTO.TXT 

Sean Goggin
sean@u36.kwnet.on.ca
        several partition table ID bytes from his usenet ID byte list 

Steve Grant, Jersey City NJ:
BIX: sjgrant
        who granted permission to include his excellent SYSID program 
        with my distribution disks, furnished several model IDs 

Roedy Green, Vancouver BC Canada:
BIX: roedy
        many names and addresses for Appendix 5, serial and parallel 
        port details and cabling, granted permission to include some 
        of his very educational essays with my distribution disks, 
        plus many details on DOS disk I/O 

David Holm
BIX: dgh
        Reported minor error in int 15h/4Fh and some TI Pro oddities 

Brad Kepley
BIX: bkep
        furnished copy of Davis' DESQview Programming book

Michael Koepke, Wood Dale IL:
        pinouts on EGA feature connector, PS/2 keyboard connector, DR-
        DOS programming information, much info on Digital's DR-DOS, 
        and the loan of some of his books 

Tom Jeffries, Oakland CA:
BIX: tjeffries
        furnished a copy of the Sound Blaster SDK

Curt Lankford, Little Rock, AR:
        loaned his copy of the AT&T 6300 Plus Hardware Technical 
        Reference 

Ron Lepine
BIX: ronlepine
        much TI Professional keyboard/video programming info

Alan R. Levinstone, Garland TX:
        80286 LOADALL instruction
        BIOS Data Area floppy control parameters 40:8B, 40:8F, 40:90 

Brian Long, Twyford UK:
        provided a copy of the then-nearly-unavailable DPMI 0.9 
        specification, plus port and address info 

John Man, Brighton UK:
JHL14@phx.cam.ac.uk
        Consensys V4 partition ID byte

Keith Meade, Rochester MN:
BIX: keithm
        who provided a Microsoft Windows 2.11 SDK, copy of IBM TopView 

Feico Nater, Hengelo, Netherlands:
        additions to FCB calls, several pages of expansions and 
        clarifications 

Bruce Nevins, Tucson AZ:
BIX: bnevins
        Irwin low-level tape drive info, DEC PC info

Patrick O'Riva, San Jose CA:
        info on what happens to the interleave when the BIOS is 
        finished, and for his interesting online assembly-language 
        magazine 

Klaus Overhage, Stuttgart Germany:
        FANSI-CONSOLE system calls, and translating the TechRef into 
        German 

August C. Quint, Germany:
CIS: 100023,1545
        bug reports on 8250 information, disassembly of DOS 3.1, and 
        many useful comments 

Tom Rawson, MD:
BIX: trawson
        DOS device driver loading information

Peter Rejto, Minneapolis MN:
rejto@math.umn.edu
        many C.A.R.E. packages of documentation and data sheets - 
        hardly a month goes by without something from Peter! 

John Richards, England:
BIX: jrichards
        European DOS 4.0 information

Chris Rutkowski, Botswana:
        Chris donated the list of Epson printer codes that appear in 
        Appendix 36

Ben Sansing, Little Rock AR:
ben.sansing@chaos.lrk.ar.us
        ANSI.SYS information, documentation for the NEC V20/30 chips, 
        reported error in register chart in Chapter 4, loaned his copy 
        of PC-MOS/386 for testing 

Mike Sargent, Canada:
BIX: mfsargent
        sent a copy of the IBM AT Technical Reference with BIOS 
        listings

Hans Schleichert, Marburg Germany:
        information on int 2Fh, fn OAEh (internal DOS commands). Good 
        thing I took some German in high school... <grin> 

Paul Slootman, Borne, Netherlands
        RealTek VGA board video modes

John Switzer, CA:
BIX: jswitzer
        who allowed me to include his discoveries on alternate DOS 
        entries and file mysteries. (see BACKDOOR.ZIP on BIX, or Oct 
        1990 Dr. Dobbs') 

Fred Thompson, Rapid City SD:
        loaned his Sound Blaster manual, provided much info on 
        graphics programming 

Matt Trask:
BIX: matt.trask
        who provided a complete copy of the TopView Programmer's 
        Reference and some OS/2 programming information 

Richard Vogh, Marietta GA:
        found several embarrassing errors in the boot sector chart in 
        Chapter 8. The shame! The shame! <sigh> 

Jim Wenzel, North Little Rock AR:
jim.wenzel@grapevne.lrk.ar.us
        more PC model ID codes, loaned his copy of the Windows 3.0 SDK 


...and these companies:

Alloy Computer Products, Marlborough MA:
        Joe Souza and Frank Gladu, who provided detailed information 
        on the APIs for NTNX, ANSK, and 386 Multiware. 

Artisoft, Tucson AZ:
        Eileen, Sherri, and the beta support people

Digital Research, Monterey CA:
        provided review copies of DR-DOS 5.0 and DRMDOS

H&R Block / Compuserve
CIS: 70003,4100
        Michael Finney, who gave permission to reproduce the GIF89a 
        standard 

Microsoft Corporation, Redmond WA:
        for beta-test versions of DOS 5.0, Windows 3.1, other 
        products, information on DOS 5 and the DOSSHELL API 

NanoSoft, Natick MA:
        Jack van Schouwen, allowed the use of their API materials 
        verbatim 

The Software Link, Atlanta GA:
        provided a review copy of PC/MOS-386 and the programming guide 

Qualitas, Bethesda MD:
        Bill, Andy, and all the gang

Quarterdeck, Santa Monica CA:
        Russ, Bob, Michael, and the guys in beta and tech support


  Special thanks to Chris Dunford, who donated his "CED" program to 
the public domain.  If it wasn't for CED, I would likely have 
abandoned MSDOS machines entirely and bought a Macin...uh... something 
else; and to Haruyasu Yoshizaki for allowing unrestricted use of his 
LHarc program used to compress the files on these diskettes. 


                                                        Dave Williams
                                                    --------------------
                                                      Jacksonville, AR






  ============================== I N V O I C E =================SWv3.3=======

  mail invoice to:                       SHIP TO:

   Dave Williams                     +----------------------------------------
      DOSREF                         |
    PO Box 181                       |
 Jacksonville, AR                    |
  72076-0181 USA                     |
                                     |
          Order #:                   |
          Date   :                   |
          PO #   :                   |
                                     +----------------------------------------
===============================================================================
  item  |    description                             |unit pr| qty |total price
===============================================================================

          Programmer's Technical Reference            _______ _____ _____ _____

            USA:   $20
         Canada:   $24 CDN (checks)
                   $20 US  (postal money orders)
 United Kingdom:   œ14                           check one:
    EuroCheques:   œ14 UK
                                                     | | (2)  1.44 Mb disks
  Cash, checks, or money orders are acceptable.      | | (2)  1.2  Mb disks
     see the PAYMENT file if you need help

===============================================================================
  Orders from other countries, please make payment            DOSREF  _$20.00__
  in one of the currencies listed above.
                                                 packing and postage  _$1.75___

       $5.00 extra charge for 6 x 360K [ ] or 4 x 720K [ ] diskettes  _________


                                                               total  _________


Where did you hear about DOSREF?  __________________________________________

Would you like a copy of the latest shareware version to upload or pass out
to friends or associates?
                              YES___   NO___
                                                            THANK YOU!

          --------------------  QUICK MAILER  ----------------------
            Please support quality shareware by your registration.

                          Thank you for your support!

                         DOSREF 3.3 Registration Form

make check or money order to:                   Dave Williams
                                                PO Box 181  (DOSREF)
see INVOICE.TRF for foreign orders              Jacksonville AR 72078-0181 USA

                                                   unit price  

    Programmer's Technical Reference ................. $20
    shipping and handling ............................ $1.75
                                                 Total $___________________

------------fold------------ INSTANT REGISTRATION ---------here------------

 check disk type          | | (2) 5-1/4 inch, 1.2 Mb
                          | | (2) 3-1/2 inch, 1.44 Mb

Where did you hear about DOSREF? __________________________________________

                                 __________________________________________

Use Address on envelope ( )    check ( )    or:

Name     ___________________________________________________________________

Address  ___________________________________________________________________

         ___________________________________________________________________

         ___________________________________________________________________

E-MAIL:  ___________________________________________________________________

 Copy this file to the printer.  After the first page prints, you will have
to turn it over and print the back side for the address.

 Fold at the page break below with the printing facing out.  Then fold letter
style, putting this side in and the address side out. If necessary, staple
the check to the mailer, then staple or tape the sides and top.

 Check here if you would like a copy of the latest shareware version to
pass around or upload to a local BBS: _____


                                               THANK YOU!


                                                                   ---------
_________________________________                                 |         |
                                                                  |         |
_________________________________                                 |  Stamp  |
                                                                  |         |
_________________________________                                 |         |
                                                                   ---------



                                         Dave Williams
                                         PO Box 181   (DOSREF 3.3)
                                         Jacksonville, AR 72078-0181
                                         USA
DOSREF SWv3.3

